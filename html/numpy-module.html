<?xml version="1.0" encoding="ascii"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
          "DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>numpy</title>
  <link rel="stylesheet" href="epydoc.css" type="text/css" />
  <script type="text/javascript" src="epydoc.js"></script>
</head>

<body bgcolor="white" text="black" link="blue" vlink="#204080"
      alink="#204080">
<!-- ==================== NAVIGATION BAR ==================== -->
<table class="navbar" border="0" width="100%" cellpadding="0"
       bgcolor="#a0c0ff" cellspacing="0">
  <tr valign="middle">
  <!-- Home link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="B1python-module.html">Home</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Tree link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="module-tree.html">Trees</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Index link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="identifier-index.html">Indices</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Help link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="help.html">Help</a>&nbsp;&nbsp;&nbsp;</th>

      <th class="navbar" width="100%"></th>
  </tr>
</table>
<table width="100%" cellpadding="0" cellspacing="0">
  <tr valign="top">
    <td width="100%">
      <span class="breadcrumbs">
        Package&nbsp;numpy
      </span>
    </td>
    <td>
      <table cellpadding="0" cellspacing="0">
        <!-- hide/show private -->
        <tr><td align="right"><span class="options">[<a href="javascript:void(0);" class="privatelink"
    onclick="toggle_private();">hide&nbsp;private</a>]</span></td></tr>
        <tr><td align="right"><span class="options"
            >[<a href="frames.html" target="_top">frames</a
            >]&nbsp;|&nbsp;<a href="numpy-module.html"
            target="_top">no&nbsp;frames</a>]</span></td></tr>
      </table>
    </td>
  </tr>
</table>
<!-- ==================== PACKAGE DESCRIPTION ==================== -->
<h1 class="epydoc">Package numpy</h1><p class="nomargin-top"><span class="codelink"><a href="numpy-pysrc.html">source&nbsp;code</a></span></p>
<pre class="literalblock">

NumPy
=====

Provides
  1. An array object of arbitrary homogeneous items
  2. Fast mathematical operations over arrays
  3. Linear Algebra, Fourier Transforms, Random Number Generation

How to use the documentation
----------------------------
Documentation is available in two forms: docstrings provided
with the code, and a loose standing reference guide, available from
`the NumPy homepage &lt;http://www.scipy.org&gt;`_.

We recommend exploring the docstrings using
`IPython &lt;http://ipython.scipy.org&gt;`_, an advanced Python shell with
TAB-completion and introspection capabilities.  See below for further
instructions.

The docstring examples assume that `numpy` has been imported as `np`::

  &gt;&gt;&gt; import numpy as np

Code snippets are indicated by three greater-than signs::

  &gt;&gt;&gt; x = x + 1

Use the built-in ``help`` function to view a function's docstring::

  &gt;&gt;&gt; help(np.sort)

For some objects, ``np.info(obj)`` may provide additional help.  This is
particularly true if you see the line &quot;Help on ufunc object:&quot; at the top
of the help() page.  Ufuncs are implemented in C, not Python, for speed.
The native Python help() does not know how to view their help, but our
np.info() function does.

To search for documents containing a keyword, do::

  &gt;&gt;&gt; np.lookfor('keyword')

General-purpose documents like a glossary and help on the basic concepts
of numpy are available under the ``doc`` sub-module::

  &gt;&gt;&gt; from numpy import doc
  &gt;&gt;&gt; help(doc)

Available subpackages
---------------------
doc
    Topical documentation on broadcasting, indexing, etc.
lib
    Basic functions used by several sub-packages.
random
    Core Random Tools
linalg
    Core Linear Algebra Tools
fft
    Core FFT routines
testing
    Numpy testing tools
f2py
    Fortran to Python Interface Generator.
distutils
    Enhancements to distutils with support for
    Fortran compilers support and more.

Utilities
---------
test
    Run numpy unittests
show_config
    Show numpy build configuration
dual
    Overwrite certain functions with high-performance Scipy tools
matlib
    Make everything matrices.
__version__
    Numpy version string

Viewing documentation using IPython
-----------------------------------
Start IPython with the NumPy profile (``ipython -p numpy``), which will
import `numpy` under the alias `np`.  Then, use the ``cpaste`` command to
paste examples into the shell.  To see which functions are available in
`numpy`, type ``np.&lt;TAB&gt;`` (where ``&lt;TAB&gt;`` refers to the TAB key), or use
``np.*cos*?&lt;ENTER&gt;`` (where ``&lt;ENTER&gt;`` refers to the ENTER key) to narrow
down the list.  To view the docstring for a function, use
``np.cos?&lt;ENTER&gt;`` (to view the docstring) and ``np.cos??&lt;ENTER&gt;`` (to view
the source code).

Copies vs. in-place operation
-----------------------------
Most of the functions in `numpy` return a copy of the array argument
(e.g., `sort`).  In-place versions of these functions are often
available as array methods, i.e. ``x = np.array([1,2,3]); x.sort()``.
Exceptions to this rule are documented.

</pre>

<hr />
<div class="fields">      <p><strong>Version:</strong>
        1.3.0
      </p>
</div><!-- ==================== SUBMODULES ==================== -->
<a name="section-Submodules"></a>
<table class="summary" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td colspan="2" class="table-header">
    <table border="0" cellpadding="0" cellspacing="0" width="100%">
      <tr valign="top">
        <td align="left"><span class="table-header">Submodules</span></td>
        <td align="right" valign="top"
         ><span class="options">[<a href="#section-Submodules"
         class="privatelink" onclick="toggle_private();"
         >hide private</a>]</span></td>
      </tr>
    </table>
  </td>
</tr>
  <tr><td class="summary">
  <ul class="nomargin">
    <li> <strong class="uidlink"><a href="numpy.add_newdocs-module.html">numpy.add_newdocs</a></strong>    </li>
    <li class="private"> <strong class="uidlink">numpy.core</strong>
    <ul class="private">
    <li class="private"> <strong class="uidlink"><a href="numpy.core.records-module.html" onclick="show_private();">numpy.core.records</a></strong>: <em class="summary">Record arrays expose the fields of structured arrays as properties.</em>    </li>
    <li class="private"> <strong class="uidlink"><a href="numpy.core.defchararray-module.html" onclick="show_private();">numpy.core.defchararray</a></strong>    </li>
    <li class="private"> <strong class="uidlink"><a href="numpy.core.multiarray-module.html" onclick="show_private();">numpy.core.multiarray</a></strong>    </li>
    </ul>
    </li>
    <li> <strong class="uidlink"><a href="numpy.ctypeslib-module.html">numpy.ctypeslib</a></strong>: <em class="summary">============================
``ctypes`` Utility Functions
============================</em>    </li>
    <li> <strong class="uidlink"><a href="numpy.fft-module.html">numpy.fft</a></strong>: <em class="summary">Discrete Fourier Transform (:mod:`numpy.fft`)
=============================================</em>    </li>
    <li class="private"> <strong class="uidlink">numpy.lib</strong>
    <ul class="private">
    <li class="private"> <strong class="uidlink"><a href="numpy.lib.scimath-module.html" onclick="show_private();">numpy.lib.scimath</a></strong>: <em class="summary">Wrapper functions to more user-friendly calling of certain math 
        functions whose output data-type is different than the input 
        data-type in certain domains of the input.</em>    </li>
    </ul>
    </li>
    <li> <strong class="uidlink"><a href="numpy.linalg-module.html">numpy.linalg</a></strong>: <em class="summary">Core Linear Algebra Tools
-------------------------
Linear algebra basics:</em>    </li>
    <li> <strong class="uidlink"><a href="numpy.ma-module.html">numpy.ma</a></strong>: <em class="summary">=============
Masked Arrays
=============</em>
    <ul>
    <li> <strong class="uidlink"><a href="numpy.ma.core-module.html">numpy.ma.core</a></strong>: <em class="summary">numpy.ma : a package to handle missing or invalid values.</em>    </li>
    <li> <strong class="uidlink"><a href="numpy.ma.extras-module.html">numpy.ma.extras</a></strong>: <em class="summary">Masked arrays add-ons.</em>    </li>
    </ul>
    </li>
    <li class="private"> <strong class="uidlink"><a href="numpy.oldnumeric-module.html" onclick="show_private();">numpy.oldnumeric</a></strong>    </li>
    <li> <strong class="uidlink"><a href="numpy.random-module.html">numpy.random</a></strong>: <em class="summary">======================== Random Number Generation 
        ========================</em>    </li>
  </ul></td></tr>
</table>

<br />
<!-- ==================== CLASSES ==================== -->
<a name="section-Classes"></a>
<table class="summary" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td colspan="2" class="table-header">
    <table border="0" cellpadding="0" cellspacing="0" width="100%">
      <tr valign="top">
        <td align="left"><span class="table-header">Classes</span></td>
        <td align="right" valign="top"
         ><span class="options">[<a href="#section-Classes"
         class="privatelink" onclick="toggle_private();"
         >hide private</a>]</span></td>
      </tr>
    </table>
  </td>
</tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.lib._datasource.DataSource-class.html" class="summary-name">DataSource</a><br />
      A generic data source file (file, http, ftp, ...).
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.lib.machar.MachAr-class.html" class="summary-name">MachAr</a><br />
      Diagnosing machine parameters.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy._import_tools.PackageLoader-class.html" class="summary-name">PackageLoader</a>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.lib.polynomial.RankWarning-class.html" class="summary-name">RankWarning</a><br />
      Issued by polyfit when Vandermonde matrix is rank deficient.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.bool_-class.html" class="summary-name">bool8</a><br />
      Boolean.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.bool_-class.html" class="summary-name">bool_</a><br />
      Boolean.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.broadcast-class.html" class="summary-name">broadcast</a><br />
      Produce an object that mimics broadcasting.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.int8-class.html" class="summary-name">byte</a><br />
      8-bit integer.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.complex128-class.html" class="summary-name">cdouble</a><br />
      Composed of two 64 bit floats
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.complex128-class.html" class="summary-name">cfloat</a><br />
      Composed of two 64 bit floats
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.character-class.html" class="summary-name">character</a>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.core.defchararray.chararray-class.html" class="summary-name">chararray</a><br />
      chararray(shape, itemsize=1, unicode=False, buffer=None, offset=0,
          strides=None, order=None)
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.complex192-class.html" class="summary-name">clongdouble</a><br />
      Composed of two 96 bit floats
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.complex192-class.html" class="summary-name">clongfloat</a><br />
      Composed of two 96 bit floats
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.complex128-class.html" class="summary-name">complex128</a><br />
      Composed of two 64 bit floats
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.complex192-class.html" class="summary-name">complex192</a><br />
      Composed of two 96 bit floats
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.complex64-class.html" class="summary-name">complex64</a><br />
      Composed of two 32 bit floats
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.complex128-class.html" class="summary-name">complex_</a><br />
      Composed of two 64 bit floats
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.complexfloating-class.html" class="summary-name">complexfloating</a>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.complex64-class.html" class="summary-name">csingle</a><br />
      Composed of two 32 bit floats
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.float64-class.html" class="summary-name">double</a><br />
      64-bit floating-point number.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.dtype-class.html" class="summary-name">dtype</a><br />
      dtype(obj, align=False, copy=False)
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.core.numeric.errstate-class.html" class="summary-name">errstate</a><br />
      with errstate(**state): --&gt; operations in following block use 
        given state.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.lib.getlimits.finfo-class.html" class="summary-name">finfo</a><br />
      finfo(dtype)
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.flatiter-class.html" class="summary-name">flatiter</a>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.flexible-class.html" class="summary-name">flexible</a>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.float32-class.html" class="summary-name">float32</a><br />
      32-bit floating-point number.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.float64-class.html" class="summary-name">float64</a><br />
      64-bit floating-point number.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.float96-class.html" class="summary-name">float96</a>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.float64-class.html" class="summary-name">float_</a><br />
      64-bit floating-point number.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.floating-class.html" class="summary-name">floating</a>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.core.records.format_parser-class.html" class="summary-name">format_parser</a><br />
      Class to convert formats, names, titles description to a dtype
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.generic-class.html" class="summary-name">generic</a>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.lib.getlimits.iinfo-class.html" class="summary-name">iinfo</a><br />
      iinfo(type)
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.inexact-class.html" class="summary-name">inexact</a>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.core.intc-class.html" class="summary-name">int0</a>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.int16-class.html" class="summary-name">int16</a><br />
      16-bit integer.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.int32-class.html" class="summary-name">int32</a><br />
      32-bit integer.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.int64-class.html" class="summary-name">int64</a><br />
      64-bit integer.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.int8-class.html" class="summary-name">int8</a><br />
      8-bit integer.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.int32-class.html" class="summary-name">int_</a><br />
      32-bit integer.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.core.intc-class.html" class="summary-name">intc</a>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.integer-class.html" class="summary-name">integer</a>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.core.intc-class.html" class="summary-name">intp</a>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.complex192-class.html" class="summary-name">longcomplex</a><br />
      Composed of two 96 bit floats
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.float96-class.html" class="summary-name">longdouble</a>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.float96-class.html" class="summary-name">longfloat</a>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.int64-class.html" class="summary-name">longlong</a><br />
      64-bit integer.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.core.defmatrix.matrix-class.html" class="summary-name">matrix</a><br />
      matrix(data, dtype=None, copy=True)
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.core.memmap-class.html" class="summary-name">memmap</a><br />
      Create a memory-map to an array stored in a file on disk.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.ndarray-class.html" class="summary-name">ndarray</a><br />
      ndarray(shape, dtype=float, buffer=None, offset=0,
        strides=None, order=None)
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.lib.index_tricks.ndenumerate-class.html" class="summary-name">ndenumerate</a><br />
      Multidimensional index iterator.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.lib.index_tricks.ndindex-class.html" class="summary-name">ndindex</a><br />
      An N-dimensional iterator object to index arrays.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.number-class.html" class="summary-name">number</a>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.object_-class.html" class="summary-name">object0</a>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.object_-class.html" class="summary-name">object_</a>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.lib.polynomial.poly1d-class.html" class="summary-name">poly1d</a><br />
      A one-dimensional polynomial class.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.core.records.recarray-class.html" class="summary-name">recarray</a><br />
      Construct an ndarray that allows field access using attributes.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.core.records.record-class.html" class="summary-name">record</a><br />
      A data-type scalar that allows field access as attribute lookup.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.int16-class.html" class="summary-name">short</a><br />
      16-bit integer.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.signedinteger-class.html" class="summary-name">signedinteger</a>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.float32-class.html" class="summary-name">single</a><br />
      32-bit floating-point number.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.complex64-class.html" class="summary-name">singlecomplex</a><br />
      Composed of two 32 bit floats
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.string_-class.html" class="summary-name">str_</a>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.string_-class.html" class="summary-name">string0</a>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.string_-class.html" class="summary-name">string_</a>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.uint8-class.html" class="summary-name">ubyte</a>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.ufunc-class.html" class="summary-name">ufunc</a><br />
      Functions that operate element by element on whole arrays.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.uint32-class.html" class="summary-name">uint</a>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.core.uintc-class.html" class="summary-name">uint0</a>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.uint16-class.html" class="summary-name">uint16</a>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.uint32-class.html" class="summary-name">uint32</a>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.uint64-class.html" class="summary-name">uint64</a>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.uint8-class.html" class="summary-name">uint8</a>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.core.uintc-class.html" class="summary-name">uintc</a>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.core.uintc-class.html" class="summary-name">uintp</a>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.uint64-class.html" class="summary-name">ulonglong</a>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.unicode_-class.html" class="summary-name">unicode0</a>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.unicode_-class.html" class="summary-name">unicode_</a>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.unsignedinteger-class.html" class="summary-name">unsignedinteger</a>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.uint16-class.html" class="summary-name">ushort</a>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.lib.function_base.vectorize-class.html" class="summary-name">vectorize</a><br />
      vectorize(pyfunc, otypes='', doc=None)
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.void-class.html" class="summary-name">void</a>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy.void-class.html" class="summary-name">void0</a>
    </td>
  </tr>
</table>
<!-- ==================== FUNCTIONS ==================== -->
<a name="section-Functions"></a>
<table class="summary" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td colspan="2" class="table-header">
    <table border="0" cellpadding="0" cellspacing="0" width="100%">
      <tr valign="top">
        <td align="left"><span class="table-header">Functions</span></td>
        <td align="right" valign="top"
         ><span class="options">[<a href="#section-Functions"
         class="privatelink" onclick="toggle_private();"
         >hide private</a>]</span></td>
      </tr>
    </table>
  </td>
</tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#add_docstring" class="summary-sig-name">add_docstring</a>(<span class="summary-sig-arg">obj</span>,
        <span class="summary-sig-arg">docstring</span>)</span><br />
      Add a docstring to a built-in obj if possible.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#add_newdoc" class="summary-sig-name">add_newdoc</a>(<span class="summary-sig-arg">place</span>,
        <span class="summary-sig-arg">obj</span>,
        <span class="summary-sig-arg">doc</span>)</span><br />
      Adds documentation to obj which is in module place.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#alen" class="summary-sig-name">alen</a>(<span class="summary-sig-arg">a</span>)</span><br />
      Return the length of the first dimension of the input array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#all" class="summary-sig-name">all</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">axis</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">out</span>=<span class="summary-sig-default">None</span>)</span><br />
      Test whether all array elements along a given axis evaluate to True.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#allclose" class="summary-sig-name">allclose</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">b</span>,
        <span class="summary-sig-arg">rtol</span>=<span class="summary-sig-default">1e-05</span>,
        <span class="summary-sig-arg">atol</span>=<span class="summary-sig-default">1e-08</span>)</span><br />
      Returns True if two arrays are element-wise equal within a tolerance.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#alltrue" class="summary-sig-name">alltrue</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">axis</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">out</span>=<span class="summary-sig-default">None</span>)</span><br />
      Check if all elements of input array are true.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#alterdot" class="summary-sig-name">alterdot</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Change `dot`, `vdot`, and `innerproduct` to use accelerated BLAS functions.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#amax" class="summary-sig-name">amax</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">axis</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">out</span>=<span class="summary-sig-default">None</span>)</span><br />
      Return the maximum along an axis.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#amin" class="summary-sig-name">amin</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">axis</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">out</span>=<span class="summary-sig-default">None</span>)</span><br />
      Return the minimum along an axis.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#angle" class="summary-sig-name">angle</a>(<span class="summary-sig-arg">z</span>,
        <span class="summary-sig-arg">deg</span>=<span class="summary-sig-default">0</span>)</span><br />
      Return the angle of the complex argument.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#any" class="summary-sig-name">any</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">axis</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">out</span>=<span class="summary-sig-default">None</span>)</span><br />
      Test whether any array element along a given axis evaluates to True.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#append" class="summary-sig-name">append</a>(<span class="summary-sig-arg">arr</span>,
        <span class="summary-sig-arg">values</span>,
        <span class="summary-sig-arg">axis</span>=<span class="summary-sig-default">None</span>)</span><br />
      Append values to the end of an array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#apply_along_axis" class="summary-sig-name">apply_along_axis</a>(<span class="summary-sig-arg">func1d</span>,
        <span class="summary-sig-arg">axis</span>,
        <span class="summary-sig-arg">arr</span>,
        <span class="summary-sig-arg">*args</span>)</span><br />
      Apply a function to 1-D slices along the given axis.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#apply_over_axes" class="summary-sig-name">apply_over_axes</a>(<span class="summary-sig-arg">func</span>,
        <span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">axes</span>)</span><br />
      Apply a function repeatedly over multiple axes.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#arange" class="summary-sig-name">arange</a>(<span class="summary-sig-arg">...</span>)</span><br />
      arange([start,] stop[, step,], dtype=None)</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#argmax" class="summary-sig-name">argmax</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">axis</span>=<span class="summary-sig-default">None</span>)</span><br />
      Indices of the maximum values along an axis.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#argmin" class="summary-sig-name">argmin</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">axis</span>=<span class="summary-sig-default">None</span>)</span><br />
      Return the indices of the minimum values along an axis.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#argsort" class="summary-sig-name">argsort</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">axis</span>=<span class="summary-sig-default">-1</span>,
        <span class="summary-sig-arg">kind</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string">quicksort</code><code class="variable-quote">'</code></span>,
        <span class="summary-sig-arg">order</span>=<span class="summary-sig-default">None</span>)</span><br />
      Returns the indices that would sort an array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#argwhere" class="summary-sig-name">argwhere</a>(<span class="summary-sig-arg">a</span>)</span><br />
      Find the indices of array elements that are non-zero, grouped by element.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#around" class="summary-sig-name">around</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">decimals</span>=<span class="summary-sig-default">0</span>,
        <span class="summary-sig-arg">out</span>=<span class="summary-sig-default">None</span>)</span><br />
      Evenly round to the given number of decimals.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#array" class="summary-sig-name">array</a>(<span class="summary-sig-arg">object</span>,
        <span class="summary-sig-arg">dtype</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">copy</span>=<span class="summary-sig-default">True</span>,
        <span class="summary-sig-arg">order</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">subok</span>=<span class="summary-sig-default">False</span>,
        <span class="summary-sig-arg">ndmin</span>=<span class="summary-sig-default">True</span>)</span><br />
      Create an array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#array2string" class="summary-sig-name">array2string</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">max_line_width</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">precision</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">suppress_small</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">separator</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string"> </code><code class="variable-quote">'</code></span>,
        <span class="summary-sig-arg">prefix</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string"></code><code class="variable-quote">'</code></span>,
        <span class="summary-sig-arg">style</span>=<span class="summary-sig-default">&lt;built-in function repr&gt;</span>)</span><br />
      Return a string representation of an array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#array_equal" class="summary-sig-name">array_equal</a>(<span class="summary-sig-arg">a1</span>,
        <span class="summary-sig-arg">a2</span>)</span><br />
      True if two arrays have the same shape and elements, False otherwise.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#array_equiv" class="summary-sig-name">array_equiv</a>(<span class="summary-sig-arg">a1</span>,
        <span class="summary-sig-arg">a2</span>)</span><br />
      Returns True if input arrays are shape consistent and all elements equal.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#array_repr" class="summary-sig-name">array_repr</a>(<span class="summary-sig-arg">arr</span>,
        <span class="summary-sig-arg">max_line_width</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">precision</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">suppress_small</span>=<span class="summary-sig-default">None</span>)</span><br />
      Return the string representation of an array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#array_split" class="summary-sig-name">array_split</a>(<span class="summary-sig-arg">ary</span>,
        <span class="summary-sig-arg">indices_or_sections</span>,
        <span class="summary-sig-arg">axis</span>=<span class="summary-sig-default">0</span>)</span><br />
      Split an array into multiple sub-arrays of equal or near-equal size.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#array_str" class="summary-sig-name">array_str</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">max_line_width</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">precision</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">suppress_small</span>=<span class="summary-sig-default">None</span>)</span><br />
      Return a string representation of an array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#asanyarray" class="summary-sig-name">asanyarray</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">dtype</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">order</span>=<span class="summary-sig-default">None</span>)</span><br />
      Convert the input to a ndarray, but pass ndarray subclasses through.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#asarray" class="summary-sig-name">asarray</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">dtype</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">order</span>=<span class="summary-sig-default">None</span>)</span><br />
      Convert the input to an array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#asarray_chkfinite" class="summary-sig-name">asarray_chkfinite</a>(<span class="summary-sig-arg">a</span>)</span><br />
      Convert the input to an array, checking for NaNs or Infs.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#ascontiguousarray" class="summary-sig-name">ascontiguousarray</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">dtype</span>=<span class="summary-sig-default">None</span>)</span><br />
      Return a contiguous array in memory (C order).</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#asfarray" class="summary-sig-name">asfarray</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">dtype</span>=<span class="summary-sig-default">&lt;type 'numpy.float64'&gt;</span>)</span><br />
      Return an array converted to a float type.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#asfortranarray" class="summary-sig-name">asfortranarray</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">dtype</span>=<span class="summary-sig-default">None</span>)</span><br />
      Return an array laid out in Fortran order in memory.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#asmatrix" class="summary-sig-name">asmatrix</a>(<span class="summary-sig-arg">data</span>,
        <span class="summary-sig-arg">dtype</span>=<span class="summary-sig-default">None</span>)</span><br />
      Interpret the input as a matrix.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#asscalar" class="summary-sig-name">asscalar</a>(<span class="summary-sig-arg">a</span>)</span><br />
      Convert an array of size 1 to its scalar equivalent.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#atleast_1d" class="summary-sig-name">atleast_1d</a>(<span class="summary-sig-arg">*arys</span>)</span><br />
      Convert inputs to arrays with at least one dimension.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#atleast_2d" class="summary-sig-name">atleast_2d</a>(<span class="summary-sig-arg">*arys</span>)</span><br />
      View inputs as arrays with at least two dimensions.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#atleast_3d" class="summary-sig-name">atleast_3d</a>(<span class="summary-sig-arg">*arys</span>)</span><br />
      View inputs as arrays with at least three dimensions.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#average" class="summary-sig-name">average</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">axis</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">weights</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">returned</span>=<span class="summary-sig-default">False</span>)</span><br />
      Return the weighted average of array over the specified axis.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#bartlett" class="summary-sig-name">bartlett</a>(<span class="summary-sig-arg">M</span>)</span><br />
      Return the Bartlett window.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#base_repr" class="summary-sig-name">base_repr</a>(<span class="summary-sig-arg">number</span>,
        <span class="summary-sig-arg">base</span>=<span class="summary-sig-default">2</span>,
        <span class="summary-sig-arg">padding</span>=<span class="summary-sig-default">0</span>)</span><br />
      Return a string representation of a number in the given base system.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#binary_repr" class="summary-sig-name">binary_repr</a>(<span class="summary-sig-arg">num</span>,
        <span class="summary-sig-arg">width</span>=<span class="summary-sig-default">None</span>)</span><br />
      Return the binary representation of the input number as a string.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#bincount" class="summary-sig-name">bincount</a>(<span class="summary-sig-arg">x</span>,
        <span class="summary-sig-arg">weights</span>=<span class="summary-sig-default">None</span>)</span><br />
      Return the number of occurrences of each value in array of nonnegative
integers.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#blackman" class="summary-sig-name">blackman</a>(<span class="summary-sig-arg">M</span>)</span><br />
      Return the Blackman window.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#bmat" class="summary-sig-name">bmat</a>(<span class="summary-sig-arg">obj</span>,
        <span class="summary-sig-arg">ldict</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">gdict</span>=<span class="summary-sig-default">None</span>)</span><br />
      Build a matrix object from a string, nested sequence, or array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#broadcast_arrays" class="summary-sig-name">broadcast_arrays</a>(<span class="summary-sig-arg">*args</span>)</span><br />
      Broadcast any number of arrays against each other.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#byte_bounds" class="summary-sig-name">byte_bounds</a>(<span class="summary-sig-arg">a</span>)</span><br />
      Returns pointers to the end-points of an array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#can_cast" class="summary-sig-name">can_cast</a>(<span class="summary-sig-arg">from</span>=<span class="summary-sig-default">d1</span>,
        <span class="summary-sig-arg">to</span>=<span class="summary-sig-default">d2</span>)</span><br />
      Returns True if cast between data types can occur without losing precision.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#choose" class="summary-sig-name">choose</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">choices</span>,
        <span class="summary-sig-arg">out</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">mode</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string">raise</code><code class="variable-quote">'</code></span>)</span><br />
      Use an index array to construct a new array from a set of choices.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#clip" class="summary-sig-name">clip</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">a_min</span>,
        <span class="summary-sig-arg">a_max</span>,
        <span class="summary-sig-arg">out</span>=<span class="summary-sig-default">None</span>)</span><br />
      Clip (limit) the values in an array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#column_stack" class="summary-sig-name">column_stack</a>(<span class="summary-sig-arg">tup</span>)</span><br />
      Stack 1-D arrays as columns into a 2-D array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#common_type" class="summary-sig-name">common_type</a>(<span class="summary-sig-arg">*arrays</span>)</span><br />
      Return the inexact scalar type which is most common in a list of arrays.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="compare_chararrays"></a><span class="summary-sig-name">compare_chararrays</span>(<span class="summary-sig-arg">...</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#compress" class="summary-sig-name">compress</a>(<span class="summary-sig-arg">condition</span>,
        <span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">axis</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">out</span>=<span class="summary-sig-default">None</span>)</span><br />
      Return selected slices of an array along given axis.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#concatenate" class="summary-sig-name">concatenate</a>(<span class="summary-sig-arg">...</span>)</span><br />
      concatenate((a1, a2, ...), axis=0)</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#convolve" class="summary-sig-name">convolve</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">v</span>,
        <span class="summary-sig-arg">mode</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string">full</code><code class="variable-quote">'</code></span>)</span><br />
      Returns the discrete, linear convolution of two one-dimensional sequences.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#copy" class="summary-sig-name">copy</a>(<span class="summary-sig-arg">a</span>)</span><br />
      Return an array copy of the given object.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#corrcoef" class="summary-sig-name">corrcoef</a>(<span class="summary-sig-arg">x</span>,
        <span class="summary-sig-arg">y</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">rowvar</span>=<span class="summary-sig-default">1</span>,
        <span class="summary-sig-arg">bias</span>=<span class="summary-sig-default">0</span>)</span><br />
      Return correlation coefficients.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#correlate" class="summary-sig-name">correlate</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">v</span>,
        <span class="summary-sig-arg">mode</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string">valid</code><code class="variable-quote">'</code></span>)</span><br />
      Discrete, linear correlation of two 1-dimensional sequences.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#cov" class="summary-sig-name">cov</a>(<span class="summary-sig-arg">m</span>,
        <span class="summary-sig-arg">y</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">rowvar</span>=<span class="summary-sig-default">1</span>,
        <span class="summary-sig-arg">bias</span>=<span class="summary-sig-default">0</span>)</span><br />
      Estimate a covariance matrix, given data.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#cross" class="summary-sig-name">cross</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">b</span>,
        <span class="summary-sig-arg">axisa</span>=<span class="summary-sig-default">-1</span>,
        <span class="summary-sig-arg">axisb</span>=<span class="summary-sig-default">-1</span>,
        <span class="summary-sig-arg">axisc</span>=<span class="summary-sig-default">-1</span>,
        <span class="summary-sig-arg">axis</span>=<span class="summary-sig-default">None</span>)</span><br />
      Return the cross product of two (arrays of) vectors.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#cumprod" class="summary-sig-name">cumprod</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">axis</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">dtype</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">out</span>=<span class="summary-sig-default">None</span>)</span><br />
      Return the cumulative product of elements along a given axis.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#cumproduct" class="summary-sig-name">cumproduct</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">axis</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">dtype</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">out</span>=<span class="summary-sig-default">None</span>)</span><br />
      Return the cumulative product over the given axis.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#cumsum" class="summary-sig-name">cumsum</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">axis</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">dtype</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">out</span>=<span class="summary-sig-default">None</span>)</span><br />
      Return the cumulative sum of the elements along a given axis.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#delete" class="summary-sig-name">delete</a>(<span class="summary-sig-arg">arr</span>,
        <span class="summary-sig-arg">obj</span>,
        <span class="summary-sig-arg">axis</span>=<span class="summary-sig-default">None</span>)</span><br />
      Return a new array with sub-arrays along an axis deleted.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#deprecate" class="summary-sig-name">deprecate</a>(<span class="summary-sig-arg">func</span>,
        <span class="summary-sig-arg">oldname</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">newname</span>=<span class="summary-sig-default">None</span>)</span><br />
      Deprecate old functions.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#deprecate_with_doc" class="summary-sig-name">deprecate_with_doc</a>(<span class="summary-sig-arg">somestr</span>)</span><br />
      Decorator to deprecate functions and provide detailed documentation
with 'somestr' that is added to the functions docstring.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#diag" class="summary-sig-name">diag</a>(<span class="summary-sig-arg">v</span>,
        <span class="summary-sig-arg">k</span>=<span class="summary-sig-default">0</span>)</span><br />
      Extract a diagonal or construct a diagonal array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#diagflat" class="summary-sig-name">diagflat</a>(<span class="summary-sig-arg">v</span>,
        <span class="summary-sig-arg">k</span>=<span class="summary-sig-default">0</span>)</span><br />
      Create a two-dimensional array with the flattened input as a diagonal.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#diagonal" class="summary-sig-name">diagonal</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">offset</span>=<span class="summary-sig-default">0</span>,
        <span class="summary-sig-arg">axis1</span>=<span class="summary-sig-default">0</span>,
        <span class="summary-sig-arg">axis2</span>=<span class="summary-sig-default">1</span>)</span><br />
      Return specified diagonals.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#diff" class="summary-sig-name">diff</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">n</span>=<span class="summary-sig-default">1</span>,
        <span class="summary-sig-arg">axis</span>=<span class="summary-sig-default">-1</span>)</span><br />
      Calculate the nth order discrete difference along given axis.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#digitize" class="summary-sig-name">digitize</a>(<span class="summary-sig-arg">x</span>,
        <span class="summary-sig-arg">bins</span>)</span><br />
      Return the indices of the bins to which each value in input array belongs.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#disp" class="summary-sig-name">disp</a>(<span class="summary-sig-arg">mesg</span>,
        <span class="summary-sig-arg">device</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">linefeed</span>=<span class="summary-sig-default">True</span>)</span><br />
      Display a message on a device</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#dot" class="summary-sig-name">dot</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">b</span>)</span><br />
      Dot product of two arrays.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#dsplit" class="summary-sig-name">dsplit</a>(<span class="summary-sig-arg">ary</span>,
        <span class="summary-sig-arg">indices_or_sections</span>)</span><br />
      Split array into multiple sub-arrays along the 3rd axis (depth).</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#dstack" class="summary-sig-name">dstack</a>(<span class="summary-sig-arg">tup</span>)</span><br />
      Stack arrays in sequence depth wise (along third axis).</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#ediff1d" class="summary-sig-name">ediff1d</a>(<span class="summary-sig-arg">ary</span>,
        <span class="summary-sig-arg">to_end</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">to_begin</span>=<span class="summary-sig-default">None</span>)</span><br />
      The differences between consecutive elements of an array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#empty" class="summary-sig-name">empty</a>(<span class="summary-sig-arg">shape</span>,
        <span class="summary-sig-arg">dtype</span>=<span class="summary-sig-default">float</span>,
        <span class="summary-sig-arg">order</span>=<span class="summary-sig-default">'C'</span>)</span><br />
      Return a new array of given shape and type, without initialising entries.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#empty_like" class="summary-sig-name">empty_like</a>(<span class="summary-sig-arg">a</span>)</span><br />
      Create a new array with the same shape and type as another.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#expand_dims" class="summary-sig-name">expand_dims</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">axis</span>)</span><br />
      Expand the shape of an array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#extract" class="summary-sig-name">extract</a>(<span class="summary-sig-arg">condition</span>,
        <span class="summary-sig-arg">arr</span>)</span><br />
      Return the elements of an array that satisfy some condition.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#eye" class="summary-sig-name">eye</a>(<span class="summary-sig-arg">N</span>,
        <span class="summary-sig-arg">M</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">k</span>=<span class="summary-sig-default">0</span>,
        <span class="summary-sig-arg">dtype</span>=<span class="summary-sig-default">&lt;type 'float'&gt;</span>)</span><br />
      Return a 2-D array with ones on the diagonal and zeros elsewhere.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="fastCopyAndTranspose"></a><span class="summary-sig-name">fastCopyAndTranspose</span>(<span class="summary-sig-arg">a</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#find_common_type" class="summary-sig-name">find_common_type</a>(<span class="summary-sig-arg">array_types</span>,
        <span class="summary-sig-arg">scalar_types</span>)</span><br />
      Determine common type following standard coercion rules</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#fix" class="summary-sig-name">fix</a>(<span class="summary-sig-arg">x</span>,
        <span class="summary-sig-arg">y</span>=<span class="summary-sig-default">None</span>)</span><br />
      Round to nearest integer towards zero.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#flatnonzero" class="summary-sig-name">flatnonzero</a>(<span class="summary-sig-arg">a</span>)</span><br />
      Return indices that are non-zero in the flattened version of a.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#fliplr" class="summary-sig-name">fliplr</a>(<span class="summary-sig-arg">m</span>)</span><br />
      Flip array in the left/right direction.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#flipud" class="summary-sig-name">flipud</a>(<span class="summary-sig-arg">m</span>)</span><br />
      Flip array in the up/down direction.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#frombuffer" class="summary-sig-name">frombuffer</a>(<span class="summary-sig-arg">buffer</span>,
        <span class="summary-sig-arg">dtype</span>=<span class="summary-sig-default">float</span>,
        <span class="summary-sig-arg">count</span>=<span class="summary-sig-default">-1</span>,
        <span class="summary-sig-arg">offset</span>=<span class="summary-sig-default">0</span>)</span><br />
      Interpret a buffer as a 1-dimensional array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#fromfile" class="summary-sig-name">fromfile</a>(<span class="summary-sig-arg">file</span>,
        <span class="summary-sig-arg">dtype</span>=<span class="summary-sig-default">float</span>,
        <span class="summary-sig-arg">count</span>=<span class="summary-sig-default">-1</span>,
        <span class="summary-sig-arg">sep</span>=<span class="summary-sig-default">''</span>)</span><br />
      Construct an array from data in a text or binary file.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#fromfunction" class="summary-sig-name">fromfunction</a>(<span class="summary-sig-arg">function</span>,
        <span class="summary-sig-arg">shape</span>,
        <span class="summary-sig-arg">**kwargs</span>)</span><br />
      Construct an array by executing a function over each coordinate.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#fromiter" class="summary-sig-name">fromiter</a>(<span class="summary-sig-arg">iterable</span>,
        <span class="summary-sig-arg">dtype</span>,
        <span class="summary-sig-arg">count</span>=<span class="summary-sig-default">-1</span>)</span><br />
      Create a new 1-dimensional array from an iterable object.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#frompyfunc" class="summary-sig-name">frompyfunc</a>(<span class="summary-sig-arg">...</span>)</span><br />
      frompyfunc(func, nin, nout) take an arbitrary python function that 
      takes nin objects as input and returns nout objects and return a 
      universal function (ufunc).</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#fromregex" class="summary-sig-name">fromregex</a>(<span class="summary-sig-arg">file</span>,
        <span class="summary-sig-arg">regexp</span>,
        <span class="summary-sig-arg">dtype</span>)</span><br />
      Construct an array from a text file, using regular-expressions parsing.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#fromstring" class="summary-sig-name">fromstring</a>(<span class="summary-sig-arg">string</span>,
        <span class="summary-sig-arg">dtype</span>=<span class="summary-sig-default">float</span>,
        <span class="summary-sig-arg">count</span>=<span class="summary-sig-default">-1</span>,
        <span class="summary-sig-arg">sep</span>=<span class="summary-sig-default">''</span>)</span><br />
      Return a new 1d array initialized from raw binary or text data in
string.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#fv" class="summary-sig-name">fv</a>(<span class="summary-sig-arg">rate</span>,
        <span class="summary-sig-arg">nper</span>,
        <span class="summary-sig-arg">pmt</span>,
        <span class="summary-sig-arg">pv</span>,
        <span class="summary-sig-arg">when</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string">end</code><code class="variable-quote">'</code></span>)</span><br />
      Compute the future value.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#genfromtxt" class="summary-sig-name">genfromtxt</a>(<span class="summary-sig-arg">fname</span>,
        <span class="summary-sig-arg">dtype</span>=<span class="summary-sig-default">&lt;type 'float'&gt;</span>,
        <span class="summary-sig-arg">comments</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string">#</code><code class="variable-quote">'</code></span>,
        <span class="summary-sig-arg">delimiter</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">skiprows</span>=<span class="summary-sig-default">0</span>,
        <span class="summary-sig-arg">converters</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">missing</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string"></code><code class="variable-quote">'</code></span>,
        <span class="summary-sig-arg">missing_values</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">usecols</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">names</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">excludelist</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">deletechars</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">case_sensitive</span>=<span class="summary-sig-default">True</span>,
        <span class="summary-sig-arg">unpack</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">usemask</span>=<span class="summary-sig-default">False</span>,
        <span class="summary-sig-arg">loose</span>=<span class="summary-sig-default">True</span>)</span><br />
      Load data from a text file.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#get_array_wrap" class="summary-sig-name">get_array_wrap</a>(<span class="summary-sig-arg">*args</span>)</span><br />
      Find the wrapper for the array with the highest priority.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#get_include" class="summary-sig-name">get_include</a>()</span><br />
      Return the directory that contains the numpy \*.h header files.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#get_numarray_include" class="summary-sig-name">get_numarray_include</a>(<span class="summary-sig-arg">type</span>=<span class="summary-sig-default">None</span>)</span><br />
      Return the directory that contains the numarray \*.h header files.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#get_numpy_include" class="summary-sig-name">get_numpy_include</a>(<span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      get_numpy_include is DEPRECATED!! -- use get_include instead</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#get_printoptions" class="summary-sig-name">get_printoptions</a>()</span><br />
      Return the current print options.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#getbuffer" class="summary-sig-name">getbuffer</a>(<span class="summary-sig-arg">obj</span>,
        <span class="summary-sig-arg">offset</span>=<span class="summary-sig-default">...</span>,
        <span class="summary-sig-arg">size</span>=<span class="summary-sig-default">...</span>)</span><br />
      Create a buffer object from the given object referencing a slice of 
      length size starting at offset.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="getbufsize"></a><span class="summary-sig-name">getbufsize</span>()</span><br />
      Return the size of the buffer used in ufuncs.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#geterr" class="summary-sig-name">geterr</a>()</span><br />
      Get the current way of handling floating-point errors.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="geterrcall"></a><span class="summary-sig-name">geterrcall</span>()</span><br />
      Return the current callback function used on floating-point errors.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#geterrobj" class="summary-sig-name">geterrobj</a>()</span><br />
      Used internally by `geterr`.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#gradient" class="summary-sig-name">gradient</a>(<span class="summary-sig-arg">f</span>,
        <span class="summary-sig-arg">*varargs</span>)</span><br />
      Return the gradient of an N-dimensional array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#hamming" class="summary-sig-name">hamming</a>(<span class="summary-sig-arg">M</span>)</span><br />
      Return the Hamming window.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#hanning" class="summary-sig-name">hanning</a>(<span class="summary-sig-arg">M</span>)</span><br />
      Return the Hanning window.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#histogram" class="summary-sig-name">histogram</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">bins</span>=<span class="summary-sig-default">10</span>,
        <span class="summary-sig-arg">range</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">normed</span>=<span class="summary-sig-default">False</span>,
        <span class="summary-sig-arg">weights</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">new</span>=<span class="summary-sig-default">None</span>)</span><br />
      Compute the histogram of a set of data.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#histogram2d" class="summary-sig-name">histogram2d</a>(<span class="summary-sig-arg">x</span>,
        <span class="summary-sig-arg">y</span>,
        <span class="summary-sig-arg">bins</span>=<span class="summary-sig-default">10</span>,
        <span class="summary-sig-arg">range</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">normed</span>=<span class="summary-sig-default">False</span>,
        <span class="summary-sig-arg">weights</span>=<span class="summary-sig-default">None</span>)</span><br />
      Compute the bidimensional histogram of two data samples.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#histogramdd" class="summary-sig-name">histogramdd</a>(<span class="summary-sig-arg">sample</span>,
        <span class="summary-sig-arg">bins</span>=<span class="summary-sig-default">10</span>,
        <span class="summary-sig-arg">range</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">normed</span>=<span class="summary-sig-default">False</span>,
        <span class="summary-sig-arg">weights</span>=<span class="summary-sig-default">None</span>)</span><br />
      Compute the multidimensional histogram of some data.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#hsplit" class="summary-sig-name">hsplit</a>(<span class="summary-sig-arg">ary</span>,
        <span class="summary-sig-arg">indices_or_sections</span>)</span><br />
      Split an array into multiple sub-arrays horizontally (column-wise).</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#hstack" class="summary-sig-name">hstack</a>(<span class="summary-sig-arg">tup</span>)</span><br />
      Stack arrays in sequence horizontally (column wise).</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#i0" class="summary-sig-name">i0</a>(<span class="summary-sig-arg">x</span>)</span><br />
      Modified Bessel function of the first kind, order 0.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#identity" class="summary-sig-name">identity</a>(<span class="summary-sig-arg">n</span>,
        <span class="summary-sig-arg">dtype</span>=<span class="summary-sig-default">None</span>)</span><br />
      Return the identity array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#imag" class="summary-sig-name">imag</a>(<span class="summary-sig-arg">val</span>)</span><br />
      Return the imaginary part of array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#indices" class="summary-sig-name">indices</a>(<span class="summary-sig-arg">dimensions</span>,
        <span class="summary-sig-arg">dtype</span>=<span class="summary-sig-default">&lt;type 'int'&gt;</span>)</span><br />
      Return an array representing the indices of a grid.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#info" class="summary-sig-name">info</a>(<span class="summary-sig-arg">object</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">maxwidth</span>=<span class="summary-sig-default">76</span>,
        <span class="summary-sig-arg">output</span>=<span class="summary-sig-default">&lt;epydoc.docintrospecter._DevNull instance at 0x9c5774c&gt;</span>,
        <span class="summary-sig-arg">toplevel</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string">numpy</code><code class="variable-quote">'</code></span>)</span><br />
      Get help information for a function, class, or module.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#inner" class="summary-sig-name">inner</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">b</span>)</span><br />
      Inner product of two arrays.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#insert" class="summary-sig-name">insert</a>(<span class="summary-sig-arg">arr</span>,
        <span class="summary-sig-arg">obj</span>,
        <span class="summary-sig-arg">values</span>,
        <span class="summary-sig-arg">axis</span>=<span class="summary-sig-default">None</span>)</span><br />
      Insert values along the given axis before the given indices.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="int_asbuffer"></a><span class="summary-sig-name">int_asbuffer</span>(<span class="summary-sig-arg">...</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#interp" class="summary-sig-name">interp</a>(<span class="summary-sig-arg">x</span>,
        <span class="summary-sig-arg">xp</span>,
        <span class="summary-sig-arg">fp</span>,
        <span class="summary-sig-arg">left</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">right</span>=<span class="summary-sig-default">None</span>)</span><br />
      One-dimensional linear interpolation.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#intersect1d" class="summary-sig-name">intersect1d</a>(<span class="summary-sig-arg">ar1</span>,
        <span class="summary-sig-arg">ar2</span>)</span><br />
      Intersection returning repeated or unique elements common to both arrays.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#intersect1d_nu" class="summary-sig-name">intersect1d_nu</a>(<span class="summary-sig-arg">ar1</span>,
        <span class="summary-sig-arg">ar2</span>)</span><br />
      Intersection returning unique elements common to both arrays.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#ipmt" class="summary-sig-name">ipmt</a>(<span class="summary-sig-arg">rate</span>,
        <span class="summary-sig-arg">per</span>,
        <span class="summary-sig-arg">nper</span>,
        <span class="summary-sig-arg">pv</span>,
        <span class="summary-sig-arg">fv</span>=<span class="summary-sig-default">0.0</span>,
        <span class="summary-sig-arg">when</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string">end</code><code class="variable-quote">'</code></span>)</span><br />
      Not implemented.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#irr" class="summary-sig-name">irr</a>(<span class="summary-sig-arg">values</span>)</span><br />
      Return the Internal Rate of Return (IRR).</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#iscomplex" class="summary-sig-name">iscomplex</a>(<span class="summary-sig-arg">x</span>)</span><br />
      Returns a bool array, where True if input element is complex.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#iscomplexobj" class="summary-sig-name">iscomplexobj</a>(<span class="summary-sig-arg">x</span>)</span><br />
      Return True if x is a complex type or an array of complex numbers.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#isfortran" class="summary-sig-name">isfortran</a>(<span class="summary-sig-arg">a</span>)</span><br />
      Returns True if array is arranged in Fortran-order in memory
and dimension &gt; 1.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#isneginf" class="summary-sig-name">isneginf</a>(<span class="summary-sig-arg">x</span>,
        <span class="summary-sig-arg">y</span>=<span class="summary-sig-default">None</span>)</span><br />
      Test element-wise for negative infinity, return result as bool array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#isposinf" class="summary-sig-name">isposinf</a>(<span class="summary-sig-arg">x</span>,
        <span class="summary-sig-arg">y</span>=<span class="summary-sig-default">None</span>)</span><br />
      Test element-wise for positive infinity, return result as bool array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#isreal" class="summary-sig-name">isreal</a>(<span class="summary-sig-arg">x</span>)</span><br />
      Returns a bool array, where True if input element is real.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#isrealobj" class="summary-sig-name">isrealobj</a>(<span class="summary-sig-arg">x</span>)</span><br />
      Return True if x is a not complex type or an array of complex numbers.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#isscalar" class="summary-sig-name">isscalar</a>(<span class="summary-sig-arg">num</span>)</span><br />
      Returns True if the type of `num` is a scalar type.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="issctype"></a><span class="summary-sig-name">issctype</span>(<span class="summary-sig-arg">rep</span>)</span><br />
      Determines whether the given object represents a numeric array type.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="issubclass_"></a><span class="summary-sig-name">issubclass_</span>(<span class="summary-sig-arg">arg1</span>,
        <span class="summary-sig-arg">arg2</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#issubdtype" class="summary-sig-name">issubdtype</a>(<span class="summary-sig-arg">arg1</span>,
        <span class="summary-sig-arg">arg2</span>)</span><br />
      Returns True if first argument is a typecode lower/equal in type hierarchy.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="issubsctype"></a><span class="summary-sig-name">issubsctype</span>(<span class="summary-sig-arg">arg1</span>,
        <span class="summary-sig-arg">arg2</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="iterable"></a><span class="summary-sig-name">iterable</span>(<span class="summary-sig-arg">y</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#ix_" class="summary-sig-name">ix_</a>(<span class="summary-sig-arg">*args</span>)</span><br />
      Construct an open mesh from multiple sequences.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#kaiser" class="summary-sig-name">kaiser</a>(<span class="summary-sig-arg">M</span>,
        <span class="summary-sig-arg">beta</span>)</span><br />
      Return the Kaiser window.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#kron" class="summary-sig-name">kron</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">b</span>)</span><br />
      Kronecker product of two arrays.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#lexsort" class="summary-sig-name">lexsort</a>(<span class="summary-sig-arg">keys</span>,
        <span class="summary-sig-arg">axis</span>=<span class="summary-sig-default">-1</span>)</span><br />
      Perform an indirect sort using a sequence of keys.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#linspace" class="summary-sig-name">linspace</a>(<span class="summary-sig-arg">start</span>,
        <span class="summary-sig-arg">stop</span>,
        <span class="summary-sig-arg">num</span>=<span class="summary-sig-default">50</span>,
        <span class="summary-sig-arg">endpoint</span>=<span class="summary-sig-default">True</span>,
        <span class="summary-sig-arg">retstep</span>=<span class="summary-sig-default">False</span>)</span><br />
      Return evenly spaced numbers over a specified interval.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#load" class="summary-sig-name">load</a>(<span class="summary-sig-arg">file</span>,
        <span class="summary-sig-arg">mmap_mode</span>=<span class="summary-sig-default">None</span>)</span><br />
      Load a pickled, ``.npy``, or ``.npz`` binary file.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="loads"></a><span class="summary-sig-name">loads</span>(<span class="summary-sig-arg">string</span>)</span><br />
      Load a pickle from the given string</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#loadtxt" class="summary-sig-name">loadtxt</a>(<span class="summary-sig-arg">fname</span>,
        <span class="summary-sig-arg">dtype</span>=<span class="summary-sig-default">&lt;type 'float'&gt;</span>,
        <span class="summary-sig-arg">comments</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string">#</code><code class="variable-quote">'</code></span>,
        <span class="summary-sig-arg">delimiter</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">converters</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">skiprows</span>=<span class="summary-sig-default">0</span>,
        <span class="summary-sig-arg">usecols</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">unpack</span>=<span class="summary-sig-default">False</span>)</span><br />
      Load data from a text file.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#log2" class="summary-sig-name">log2</a>(<span class="summary-sig-arg">x</span>,
        <span class="summary-sig-arg">y</span>=<span class="summary-sig-default">None</span>)</span><br />
      Return the base 2 logarithm.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#logspace" class="summary-sig-name">logspace</a>(<span class="summary-sig-arg">start</span>,
        <span class="summary-sig-arg">stop</span>,
        <span class="summary-sig-arg">num</span>=<span class="summary-sig-default">50</span>,
        <span class="summary-sig-arg">endpoint</span>=<span class="summary-sig-default">True</span>,
        <span class="summary-sig-arg">base</span>=<span class="summary-sig-default">10.0</span>)</span><br />
      Return numbers spaced evenly on a log scale.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#lookfor" class="summary-sig-name">lookfor</a>(<span class="summary-sig-arg">what</span>,
        <span class="summary-sig-arg">module</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">import_modules</span>=<span class="summary-sig-default">True</span>,
        <span class="summary-sig-arg">regenerate</span>=<span class="summary-sig-default">False</span>)</span><br />
      Do a keyword search on docstrings.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#mafromtxt" class="summary-sig-name">mafromtxt</a>(<span class="summary-sig-arg">fname</span>,
        <span class="summary-sig-arg">dtype</span>=<span class="summary-sig-default">&lt;type 'float'&gt;</span>,
        <span class="summary-sig-arg">comments</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string">#</code><code class="variable-quote">'</code></span>,
        <span class="summary-sig-arg">delimiter</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">skiprows</span>=<span class="summary-sig-default">0</span>,
        <span class="summary-sig-arg">converters</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">missing</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string"></code><code class="variable-quote">'</code></span>,
        <span class="summary-sig-arg">missing_values</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">usecols</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">unpack</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">names</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">excludelist</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">deletechars</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">case_sensitive</span>=<span class="summary-sig-default">True</span>)</span><br />
      Load ASCII data stored in fname and returns a MaskedArray.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#mat" class="summary-sig-name">mat</a>(<span class="summary-sig-arg">data</span>,
        <span class="summary-sig-arg">dtype</span>=<span class="summary-sig-default">None</span>)</span><br />
      Interpret the input as a matrix.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="maximum_sctype"></a><span class="summary-sig-name">maximum_sctype</span>(<span class="summary-sig-arg">t</span>)</span><br />
      returns the sctype of highest precision of the same general kind as 
      't'</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#may_share_memory" class="summary-sig-name">may_share_memory</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">b</span>)</span><br />
      Determine if two arrays can share memory</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#mean" class="summary-sig-name">mean</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">axis</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">dtype</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">out</span>=<span class="summary-sig-default">None</span>)</span><br />
      Compute the arithmetic mean along the specified axis.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#median" class="summary-sig-name">median</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">axis</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">out</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">overwrite_input</span>=<span class="summary-sig-default">False</span>)</span><br />
      Compute the median along the specified axis.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#meshgrid" class="summary-sig-name">meshgrid</a>(<span class="summary-sig-arg">x</span>,
        <span class="summary-sig-arg">y</span>)</span><br />
      Return coordinate matrices from two coordinate vectors.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#mintypecode" class="summary-sig-name">mintypecode</a>(<span class="summary-sig-arg">typechars</span>,
        <span class="summary-sig-arg">typeset</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string">GDFgdf</code><code class="variable-quote">'</code></span>,
        <span class="summary-sig-arg">default</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string">d</code><code class="variable-quote">'</code></span>)</span><br />
      Return a minimum data type character from typeset that handles all 
      typechars given</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#mirr" class="summary-sig-name">mirr</a>(<span class="summary-sig-arg">values</span>,
        <span class="summary-sig-arg">finance_rate</span>,
        <span class="summary-sig-arg">reinvest_rate</span>)</span><br />
      Modified internal rate of return.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#msort" class="summary-sig-name">msort</a>(<span class="summary-sig-arg">a</span>)</span><br />
      Return a copy of an array sorted along the first axis.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#nan_to_num" class="summary-sig-name">nan_to_num</a>(<span class="summary-sig-arg">x</span>)</span><br />
      Replace nan with zero and inf with finite numbers.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#nanargmax" class="summary-sig-name">nanargmax</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">axis</span>=<span class="summary-sig-default">None</span>)</span><br />
      Return indices of the maximum values over an axis, ignoring NaNs.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#nanargmin" class="summary-sig-name">nanargmin</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">axis</span>=<span class="summary-sig-default">None</span>)</span><br />
      Return indices of the minimum values along an axis, ignoring NaNs.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#nanmax" class="summary-sig-name">nanmax</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">axis</span>=<span class="summary-sig-default">None</span>)</span><br />
      Return the maximum of array elements over the given axis ignoring any NaNs.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#nanmin" class="summary-sig-name">nanmin</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">axis</span>=<span class="summary-sig-default">None</span>)</span><br />
      Return the minimum of array elements over the given axis ignoring any NaNs.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#nansum" class="summary-sig-name">nansum</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">axis</span>=<span class="summary-sig-default">None</span>)</span><br />
      Return the sum of array elements over a given axis treating
Not a Numbers (NaNs) as zero.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#ndfromtxt" class="summary-sig-name">ndfromtxt</a>(<span class="summary-sig-arg">fname</span>,
        <span class="summary-sig-arg">dtype</span>=<span class="summary-sig-default">&lt;type 'float'&gt;</span>,
        <span class="summary-sig-arg">comments</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string">#</code><code class="variable-quote">'</code></span>,
        <span class="summary-sig-arg">delimiter</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">skiprows</span>=<span class="summary-sig-default">0</span>,
        <span class="summary-sig-arg">converters</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">missing</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string"></code><code class="variable-quote">'</code></span>,
        <span class="summary-sig-arg">missing_values</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">usecols</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">unpack</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">names</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">excludelist</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">deletechars</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">case_sensitive</span>=<span class="summary-sig-default">True</span>)</span><br />
      Load ASCII data stored in fname and returns a ndarray.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#ndim" class="summary-sig-name">ndim</a>(<span class="summary-sig-arg">a</span>)</span><br />
      Return the number of dimensions of an array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="newbuffer"></a><span class="summary-sig-name">newbuffer</span>(<span class="summary-sig-arg">size</span>)</span><br />
      Return a new uninitialized buffer object of size bytes</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#nonzero" class="summary-sig-name">nonzero</a>(<span class="summary-sig-arg">a</span>)</span><br />
      Return the indices of the elements that are non-zero.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#nper" class="summary-sig-name">nper</a>(<span class="summary-sig-arg">rate</span>,
        <span class="summary-sig-arg">pmt</span>,
        <span class="summary-sig-arg">pv</span>,
        <span class="summary-sig-arg">fv</span>=<span class="summary-sig-default">0</span>,
        <span class="summary-sig-arg">when</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string">end</code><code class="variable-quote">'</code></span>)</span><br />
      Compute the number of periods.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#npv" class="summary-sig-name">npv</a>(<span class="summary-sig-arg">rate</span>,
        <span class="summary-sig-arg">values</span>)</span><br />
      Returns the NPV (Net Present Value) of a cash flow series.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="obj2sctype"></a><span class="summary-sig-name">obj2sctype</span>(<span class="summary-sig-arg">rep</span>,
        <span class="summary-sig-arg">default</span>=<span class="summary-sig-default">None</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#ones" class="summary-sig-name">ones</a>(<span class="summary-sig-arg">shape</span>,
        <span class="summary-sig-arg">dtype</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">order</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string">C</code><code class="variable-quote">'</code></span>)</span><br />
      Return a new array of given shape and type, filled with ones.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#outer" class="summary-sig-name">outer</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">b</span>)</span><br />
      Returns the outer product of two vectors.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#packbits" class="summary-sig-name">packbits</a>(<span class="summary-sig-arg">myarray</span>,
        <span class="summary-sig-arg">axis</span>=<span class="summary-sig-default">None</span>)</span><br />
      Packs the elements of a binary-valued array into bits in a uint8 array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#piecewise" class="summary-sig-name">piecewise</a>(<span class="summary-sig-arg">x</span>,
        <span class="summary-sig-arg">condlist</span>,
        <span class="summary-sig-arg">funclist</span>,
        <span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kw</span>)</span><br />
      Evaluate a piecewise-defined function.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#pkgload" class="summary-sig-name">pkgload</a>(<span class="summary-sig-arg">*packages</span>,
        <span class="summary-sig-arg">**options</span>)</span><br />
      Load one or more packages into parent package top-level namespace.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="numpy-pysrc.html#pkgload">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#place" class="summary-sig-name">place</a>(<span class="summary-sig-arg">arr</span>,
        <span class="summary-sig-arg">mask</span>,
        <span class="summary-sig-arg">vals</span>)</span><br />
      Changes elements of an array based on conditional and input values.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#pmt" class="summary-sig-name">pmt</a>(<span class="summary-sig-arg">rate</span>,
        <span class="summary-sig-arg">nper</span>,
        <span class="summary-sig-arg">pv</span>,
        <span class="summary-sig-arg">fv</span>=<span class="summary-sig-default">0</span>,
        <span class="summary-sig-arg">when</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string">end</code><code class="variable-quote">'</code></span>)</span><br />
      Compute the payment against loan principal plus interest.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#poly" class="summary-sig-name">poly</a>(<span class="summary-sig-arg">seq_of_zeros</span>)</span><br />
      Return polynomial coefficients given a sequence of roots.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#polyadd" class="summary-sig-name">polyadd</a>(<span class="summary-sig-arg">a1</span>,
        <span class="summary-sig-arg">a2</span>)</span><br />
      Returns sum of two polynomials.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#polyder" class="summary-sig-name">polyder</a>(<span class="summary-sig-arg">p</span>,
        <span class="summary-sig-arg">m</span>=<span class="summary-sig-default">1</span>)</span><br />
      Return the derivative of the specified order of a polynomial.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#polydiv" class="summary-sig-name">polydiv</a>(<span class="summary-sig-arg">u</span>,
        <span class="summary-sig-arg">v</span>)</span><br />
      Returns the quotient and remainder of polynomial division.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#polyfit" class="summary-sig-name">polyfit</a>(<span class="summary-sig-arg">x</span>,
        <span class="summary-sig-arg">y</span>,
        <span class="summary-sig-arg">deg</span>,
        <span class="summary-sig-arg">rcond</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">full</span>=<span class="summary-sig-default">False</span>)</span><br />
      Least squares polynomial fit.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#polyint" class="summary-sig-name">polyint</a>(<span class="summary-sig-arg">p</span>,
        <span class="summary-sig-arg">m</span>=<span class="summary-sig-default">1</span>,
        <span class="summary-sig-arg">k</span>=<span class="summary-sig-default">None</span>)</span><br />
      Return an antiderivative (indefinite integral) of a polynomial.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#polymul" class="summary-sig-name">polymul</a>(<span class="summary-sig-arg">a1</span>,
        <span class="summary-sig-arg">a2</span>)</span><br />
      Returns product of two polynomials represented as sequences.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#polysub" class="summary-sig-name">polysub</a>(<span class="summary-sig-arg">a1</span>,
        <span class="summary-sig-arg">a2</span>)</span><br />
      Returns difference from subtraction of two polynomials input as sequences.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#polyval" class="summary-sig-name">polyval</a>(<span class="summary-sig-arg">p</span>,
        <span class="summary-sig-arg">x</span>)</span><br />
      Evaluate a polynomial at specific values.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#ppmt" class="summary-sig-name">ppmt</a>(<span class="summary-sig-arg">rate</span>,
        <span class="summary-sig-arg">per</span>,
        <span class="summary-sig-arg">nper</span>,
        <span class="summary-sig-arg">pv</span>,
        <span class="summary-sig-arg">fv</span>=<span class="summary-sig-default">0.0</span>,
        <span class="summary-sig-arg">when</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string">end</code><code class="variable-quote">'</code></span>)</span><br />
      Not implemented.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#prod" class="summary-sig-name">prod</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">axis</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">dtype</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">out</span>=<span class="summary-sig-default">None</span>)</span><br />
      Return the product of array elements over a given axis.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#product" class="summary-sig-name">product</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">axis</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">dtype</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">out</span>=<span class="summary-sig-default">None</span>)</span><br />
      Return the product of array elements over a given axis.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#ptp" class="summary-sig-name">ptp</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">axis</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">out</span>=<span class="summary-sig-default">None</span>)</span><br />
      Range of values (maximum - minimum) along an axis.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#put" class="summary-sig-name">put</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">ind</span>,
        <span class="summary-sig-arg">v</span>,
        <span class="summary-sig-arg">mode</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string">raise</code><code class="variable-quote">'</code></span>)</span><br />
      Changes specific elements of one array by replacing from another array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#putmask" class="summary-sig-name">putmask</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">mask</span>,
        <span class="summary-sig-arg">values</span>)</span><br />
      Changes elements of an array based on conditional and input values.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#pv" class="summary-sig-name">pv</a>(<span class="summary-sig-arg">rate</span>,
        <span class="summary-sig-arg">nper</span>,
        <span class="summary-sig-arg">pmt</span>,
        <span class="summary-sig-arg">fv</span>=<span class="summary-sig-default">0.0</span>,
        <span class="summary-sig-arg">when</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string">end</code><code class="variable-quote">'</code></span>)</span><br />
      Compute the present value.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#rank" class="summary-sig-name">rank</a>(<span class="summary-sig-arg">a</span>)</span><br />
      Return the number of dimensions of an array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#rate" class="summary-sig-name">rate</a>(<span class="summary-sig-arg">nper</span>,
        <span class="summary-sig-arg">pmt</span>,
        <span class="summary-sig-arg">pv</span>,
        <span class="summary-sig-arg">fv</span>,
        <span class="summary-sig-arg">when</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string">end</code><code class="variable-quote">'</code></span>,
        <span class="summary-sig-arg">guess</span>=<span class="summary-sig-default">0.1</span>,
        <span class="summary-sig-arg">tol</span>=<span class="summary-sig-default">1e-06</span>,
        <span class="summary-sig-arg">maxiter</span>=<span class="summary-sig-default">100</span>)</span><br />
      Compute the rate of interest per period.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#ravel" class="summary-sig-name">ravel</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">order</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string">C</code><code class="variable-quote">'</code></span>)</span><br />
      Return a flattened array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#real" class="summary-sig-name">real</a>(<span class="summary-sig-arg">val</span>)</span><br />
      Return the real part of the elements of the array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#real_if_close" class="summary-sig-name">real_if_close</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">tol</span>=<span class="summary-sig-default">100</span>)</span><br />
      If complex input returns a real array if complex parts are close to zero.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#recfromcsv" class="summary-sig-name">recfromcsv</a>(<span class="summary-sig-arg">fname</span>,
        <span class="summary-sig-arg">dtype</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">comments</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string">#</code><code class="variable-quote">'</code></span>,
        <span class="summary-sig-arg">skiprows</span>=<span class="summary-sig-default">0</span>,
        <span class="summary-sig-arg">converters</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">missing</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string"></code><code class="variable-quote">'</code></span>,
        <span class="summary-sig-arg">missing_values</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">usecols</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">unpack</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">names</span>=<span class="summary-sig-default">True</span>,
        <span class="summary-sig-arg">excludelist</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">deletechars</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">case_sensitive</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string">lower</code><code class="variable-quote">'</code></span>,
        <span class="summary-sig-arg">usemask</span>=<span class="summary-sig-default">False</span>)</span><br />
      Load ASCII data stored in comma-separated file and returns a recarray (if 
`usemask=False`) or a MaskedRecords (if `usemask=True`).</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#recfromtxt" class="summary-sig-name">recfromtxt</a>(<span class="summary-sig-arg">fname</span>,
        <span class="summary-sig-arg">dtype</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">comments</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string">#</code><code class="variable-quote">'</code></span>,
        <span class="summary-sig-arg">delimiter</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">skiprows</span>=<span class="summary-sig-default">0</span>,
        <span class="summary-sig-arg">converters</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">missing</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string"></code><code class="variable-quote">'</code></span>,
        <span class="summary-sig-arg">missing_values</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">usecols</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">unpack</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">names</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">excludelist</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">deletechars</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">case_sensitive</span>=<span class="summary-sig-default">True</span>,
        <span class="summary-sig-arg">usemask</span>=<span class="summary-sig-default">False</span>)</span><br />
      Load ASCII data stored in fname and returns a standard recarray (if 
`usemask=False`) or a MaskedRecords (if `usemask=True`).</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#repeat" class="summary-sig-name">repeat</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">repeats</span>,
        <span class="summary-sig-arg">axis</span>=<span class="summary-sig-default">None</span>)</span><br />
      Repeat elements of an array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#require" class="summary-sig-name">require</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">dtype</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">requirements</span>=<span class="summary-sig-default">None</span>)</span><br />
      Return an ndarray of the provided type that satisfies requirements.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#reshape" class="summary-sig-name">reshape</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">newshape</span>,
        <span class="summary-sig-arg">order</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string">C</code><code class="variable-quote">'</code></span>)</span><br />
      Gives a new shape to an array without changing its data.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#resize" class="summary-sig-name">resize</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">new_shape</span>)</span><br />
      Return a new array with the specified shape.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#restoredot" class="summary-sig-name">restoredot</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Restore `dot`, `vdot`, and `innerproduct` to the default non-BLAS
implementations.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#roll" class="summary-sig-name">roll</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">shift</span>,
        <span class="summary-sig-arg">axis</span>=<span class="summary-sig-default">None</span>)</span><br />
      Roll array elements along a given axis.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#rollaxis" class="summary-sig-name">rollaxis</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">axis</span>,
        <span class="summary-sig-arg">start</span>=<span class="summary-sig-default">0</span>)</span><br />
      Roll the specified axis backwards, until it lies in a given position.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#roots" class="summary-sig-name">roots</a>(<span class="summary-sig-arg">p</span>)</span><br />
      Return the roots of a polynomial with coefficients given in p.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#rot90" class="summary-sig-name">rot90</a>(<span class="summary-sig-arg">m</span>,
        <span class="summary-sig-arg">k</span>=<span class="summary-sig-default">1</span>)</span><br />
      Rotate an array by 90 degrees in the counter-clockwise direction.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#round_" class="summary-sig-name">round_</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">decimals</span>=<span class="summary-sig-default">0</span>,
        <span class="summary-sig-arg">out</span>=<span class="summary-sig-default">None</span>)</span><br />
      Round an array to the given number of decimals.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#row_stack" class="summary-sig-name">row_stack</a>(<span class="summary-sig-arg">tup</span>)</span><br />
      Stack arrays in sequence vertically (row wise).</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#safe_eval" class="summary-sig-name">safe_eval</a>(<span class="summary-sig-arg">source</span>)</span><br />
      Protected string evaluation.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#save" class="summary-sig-name">save</a>(<span class="summary-sig-arg">file</span>,
        <span class="summary-sig-arg">arr</span>)</span><br />
      Save an array to a binary file in NumPy format.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#savetxt" class="summary-sig-name">savetxt</a>(<span class="summary-sig-arg">fname</span>,
        <span class="summary-sig-arg">X</span>,
        <span class="summary-sig-arg">fmt</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string">%.18e</code><code class="variable-quote">'</code></span>,
        <span class="summary-sig-arg">delimiter</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string"> </code><code class="variable-quote">'</code></span>)</span><br />
      Save an array to file.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#savez" class="summary-sig-name">savez</a>(<span class="summary-sig-arg">file</span>,
        <span class="summary-sig-arg">*args</span>,
        <span class="summary-sig-arg">**kwds</span>)</span><br />
      Save several arrays into a single, compressed file with extension &quot;.npz&quot;</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="sctype2char"></a><span class="summary-sig-name">sctype2char</span>(<span class="summary-sig-arg">sctype</span>)</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#searchsorted" class="summary-sig-name">searchsorted</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">v</span>,
        <span class="summary-sig-arg">side</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string">left</code><code class="variable-quote">'</code></span>)</span><br />
      Find indices where elements should be inserted to maintain order.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#select" class="summary-sig-name">select</a>(<span class="summary-sig-arg">condlist</span>,
        <span class="summary-sig-arg">choicelist</span>,
        <span class="summary-sig-arg">default</span>=<span class="summary-sig-default">0</span>)</span><br />
      Return an array drawn from elements in choicelist, depending on conditions.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#set_numeric_ops" class="summary-sig-name">set_numeric_ops</a>(<span class="summary-sig-arg">op1</span>=<span class="summary-sig-default">func1</span>,
        <span class="summary-sig-arg">op2</span>=<span class="summary-sig-default">func2</span>,
        <span class="summary-sig-arg">...</span>)</span><br />
      Set numerical operators for array objects.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#set_printoptions" class="summary-sig-name">set_printoptions</a>(<span class="summary-sig-arg">precision</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">threshold</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">edgeitems</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">linewidth</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">suppress</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">nanstr</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">infstr</span>=<span class="summary-sig-default">None</span>)</span><br />
      Set printing options.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#set_string_function" class="summary-sig-name">set_string_function</a>(<span class="summary-sig-arg">f</span>,
        <span class="summary-sig-arg">repr</span>=<span class="summary-sig-default">1</span>)</span><br />
      Set a Python function to be used when pretty printing arrays.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#setbufsize" class="summary-sig-name">setbufsize</a>(<span class="summary-sig-arg">size</span>)</span><br />
      Set the size of the buffer used in ufuncs.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#setdiff1d" class="summary-sig-name">setdiff1d</a>(<span class="summary-sig-arg">ar1</span>,
        <span class="summary-sig-arg">ar2</span>)</span><br />
      Set difference of 1D arrays with unique elements.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#seterr" class="summary-sig-name">seterr</a>(<span class="summary-sig-arg">all</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">divide</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">over</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">under</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">invalid</span>=<span class="summary-sig-default">None</span>)</span><br />
      Set how floating-point errors are handled.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#seterrcall" class="summary-sig-name">seterrcall</a>(<span class="summary-sig-arg">func</span>)</span><br />
      Set the floating-point error callback function or log object.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#seterrobj" class="summary-sig-name">seterrobj</a>(<span class="summary-sig-arg">errobj</span>)</span><br />
      Used internally by `seterr`.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#setmember1d" class="summary-sig-name">setmember1d</a>(<span class="summary-sig-arg">ar1</span>,
        <span class="summary-sig-arg">ar2</span>)</span><br />
      Return a boolean array set True where first element is in second array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#setxor1d" class="summary-sig-name">setxor1d</a>(<span class="summary-sig-arg">ar1</span>,
        <span class="summary-sig-arg">ar2</span>)</span><br />
      Set exclusive-or of 1D arrays with unique elements.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#shape" class="summary-sig-name">shape</a>(<span class="summary-sig-arg">a</span>)</span><br />
      Return the shape of an array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="show_config"></a><span class="summary-sig-name">show_config</span>()</span></td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#sinc" class="summary-sig-name">sinc</a>(<span class="summary-sig-arg">x</span>)</span><br />
      Return the sinc function.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#size" class="summary-sig-name">size</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">axis</span>=<span class="summary-sig-default">None</span>)</span><br />
      Return the number of elements along a given axis.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#sometrue" class="summary-sig-name">sometrue</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">axis</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">out</span>=<span class="summary-sig-default">None</span>)</span><br />
      Check whether some values are true.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#sort" class="summary-sig-name">sort</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">axis</span>=<span class="summary-sig-default">-1</span>,
        <span class="summary-sig-arg">kind</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string">quicksort</code><code class="variable-quote">'</code></span>,
        <span class="summary-sig-arg">order</span>=<span class="summary-sig-default">None</span>)</span><br />
      Return a sorted copy of an array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#sort_complex" class="summary-sig-name">sort_complex</a>(<span class="summary-sig-arg">a</span>)</span><br />
      Sort a complex array using the real part first, then the imaginary part.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#source" class="summary-sig-name">source</a>(<span class="summary-sig-arg">object</span>,
        <span class="summary-sig-arg">output</span>=<span class="summary-sig-default">&lt;epydoc.docintrospecter._DevNull instance at 0x9c5774c&gt;</span>)</span><br />
      Print or write to a file the source code for a Numpy object.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#split" class="summary-sig-name">split</a>(<span class="summary-sig-arg">ary</span>,
        <span class="summary-sig-arg">indices_or_sections</span>,
        <span class="summary-sig-arg">axis</span>=<span class="summary-sig-default">0</span>)</span><br />
      Split an array into multiple sub-arrays of equal size.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#squeeze" class="summary-sig-name">squeeze</a>(<span class="summary-sig-arg">a</span>)</span><br />
      Remove single-dimensional entries from the shape of an array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#std" class="summary-sig-name">std</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">axis</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">dtype</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">out</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">ddof</span>=<span class="summary-sig-default">0</span>)</span><br />
      Compute the standard deviation along the specified axis.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#sum" class="summary-sig-name">sum</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">axis</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">dtype</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">out</span>=<span class="summary-sig-default">None</span>)</span><br />
      Return the sum of array elements over a given axis.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#swapaxes" class="summary-sig-name">swapaxes</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">axis1</span>,
        <span class="summary-sig-arg">axis2</span>)</span><br />
      Interchange two axes of an array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#take" class="summary-sig-name">take</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">indices</span>,
        <span class="summary-sig-arg">axis</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">out</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">mode</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string">raise</code><code class="variable-quote">'</code></span>)</span><br />
      Take elements from an array along an axis.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#tensordot" class="summary-sig-name">tensordot</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">b</span>,
        <span class="summary-sig-arg">axes</span>=<span class="summary-sig-default">2</span>)</span><br />
      Returns the tensor dot product for (ndim &gt;= 1) arrays along an axes.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#tile" class="summary-sig-name">tile</a>(<span class="summary-sig-arg">A</span>,
        <span class="summary-sig-arg">reps</span>)</span><br />
      Construct an array by repeating A the number of times given by reps.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#trace" class="summary-sig-name">trace</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">offset</span>=<span class="summary-sig-default">0</span>,
        <span class="summary-sig-arg">axis1</span>=<span class="summary-sig-default">0</span>,
        <span class="summary-sig-arg">axis2</span>=<span class="summary-sig-default">1</span>,
        <span class="summary-sig-arg">dtype</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">out</span>=<span class="summary-sig-default">None</span>)</span><br />
      Return the sum along diagonals of the array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#transpose" class="summary-sig-name">transpose</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">axes</span>=<span class="summary-sig-default">None</span>)</span><br />
      Permute the dimensions of an array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#trapz" class="summary-sig-name">trapz</a>(<span class="summary-sig-arg">y</span>,
        <span class="summary-sig-arg">x</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">dx</span>=<span class="summary-sig-default">1.0</span>,
        <span class="summary-sig-arg">axis</span>=<span class="summary-sig-default">-1</span>)</span><br />
      Integrate along the given axis using the composite trapezoidal rule.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#tri" class="summary-sig-name">tri</a>(<span class="summary-sig-arg">N</span>,
        <span class="summary-sig-arg">M</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">k</span>=<span class="summary-sig-default">0</span>,
        <span class="summary-sig-arg">dtype</span>=<span class="summary-sig-default">&lt;type 'float'&gt;</span>)</span><br />
      Construct an array filled with ones at and below the given diagonal.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#tril" class="summary-sig-name">tril</a>(<span class="summary-sig-arg">m</span>,
        <span class="summary-sig-arg">k</span>=<span class="summary-sig-default">0</span>)</span><br />
      Lower triangle of an array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#trim_zeros" class="summary-sig-name">trim_zeros</a>(<span class="summary-sig-arg">filt</span>,
        <span class="summary-sig-arg">trim</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string">fb</code><code class="variable-quote">'</code></span>)</span><br />
      Trim the leading and/or trailing zeros from a 1-D array or sequence.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#triu" class="summary-sig-name">triu</a>(<span class="summary-sig-arg">m</span>,
        <span class="summary-sig-arg">k</span>=<span class="summary-sig-default">0</span>)</span><br />
      Upper triangle of an array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#typename" class="summary-sig-name">typename</a>(<span class="summary-sig-arg">char</span>)</span><br />
      Return a description for the given data type code.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#union1d" class="summary-sig-name">union1d</a>(<span class="summary-sig-arg">ar1</span>,
        <span class="summary-sig-arg">ar2</span>)</span><br />
      Union of 1D arrays with unique elements.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#unique" class="summary-sig-name">unique</a>(<span class="summary-sig-arg">x</span>)</span><br />
      Return the sorted, unique elements of an array or sequence.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#unique1d" class="summary-sig-name">unique1d</a>(<span class="summary-sig-arg">ar1</span>,
        <span class="summary-sig-arg">return_index</span>=<span class="summary-sig-default">False</span>,
        <span class="summary-sig-arg">return_inverse</span>=<span class="summary-sig-default">False</span>)</span><br />
      Find the unique elements of an array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#unpackbits" class="summary-sig-name">unpackbits</a>(<span class="summary-sig-arg">myarray</span>,
        <span class="summary-sig-arg">axis</span>=<span class="summary-sig-default">None</span>)</span><br />
      Unpacks elements of a uint8 array into a binary-valued output array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#unravel_index" class="summary-sig-name">unravel_index</a>(<span class="summary-sig-arg">x</span>,
        <span class="summary-sig-arg">dims</span>)</span><br />
      Convert a flat index into an index tuple for an array of given shape.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#unwrap" class="summary-sig-name">unwrap</a>(<span class="summary-sig-arg">p</span>,
        <span class="summary-sig-arg">discont</span>=<span class="summary-sig-default">3.14159265359</span>,
        <span class="summary-sig-arg">axis</span>=<span class="summary-sig-default">-1</span>)</span><br />
      Unwrap by changing deltas between values to 2*pi complement.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#vander" class="summary-sig-name">vander</a>(<span class="summary-sig-arg">x</span>,
        <span class="summary-sig-arg">N</span>=<span class="summary-sig-default">None</span>)</span><br />
      Generate a Van der Monde matrix.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#var" class="summary-sig-name">var</a>(<span class="summary-sig-arg">a</span>,
        <span class="summary-sig-arg">axis</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">dtype</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">out</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">ddof</span>=<span class="summary-sig-default">0</span>)</span><br />
      Compute the variance along the specified axis.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#vdot" class="summary-sig-name">vdot</a>(<span class="summary-sig-arg">...</span>)</span><br />
      Return the dot product of two vectors.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#vsplit" class="summary-sig-name">vsplit</a>(<span class="summary-sig-arg">ary</span>,
        <span class="summary-sig-arg">indices_or_sections</span>)</span><br />
      Split an array into multiple sub-arrays vertically (row-wise).</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#vstack" class="summary-sig-name">vstack</a>(<span class="summary-sig-arg">tup</span>)</span><br />
      Stack arrays in sequence vertically (row wise).</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#where" class="summary-sig-name">where</a>(<span class="summary-sig-arg">...</span>)</span><br />
      where(condition, [x, y])</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#who" class="summary-sig-name">who</a>(<span class="summary-sig-arg">vardict</span>=<span class="summary-sig-default">None</span>)</span><br />
      Print the Numpy arrays in the given dictionary.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#zeros" class="summary-sig-name">zeros</a>(<span class="summary-sig-arg">shape</span>,
        <span class="summary-sig-arg">dtype</span>=<span class="summary-sig-default">float</span>,
        <span class="summary-sig-arg">order</span>=<span class="summary-sig-default">'C'</span>)</span><br />
      Return a new array of given shape and type, filled with zeros.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="numpy-module.html#zeros_like" class="summary-sig-name">zeros_like</a>(<span class="summary-sig-arg">a</span>)</span><br />
      Returns an array of zeros with the same shape and type as a given array.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
</table>
<!-- ==================== VARIABLES ==================== -->
<a name="section-Variables"></a>
<table class="summary" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td colspan="2" class="table-header">
    <table border="0" cellpadding="0" cellspacing="0" width="100%">
      <tr valign="top">
        <td align="left"><span class="table-header">Variables</span></td>
        <td align="right" valign="top"
         ><span class="options">[<a href="#section-Variables"
         class="privatelink" onclick="toggle_private();"
         >hide private</a>]</span></td>
      </tr>
    </table>
  </td>
</tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="ALLOW_THREADS"></a><span class="summary-name">ALLOW_THREADS</span> = <code title="1">1</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="BUFSIZE"></a><span class="summary-name">BUFSIZE</span> = <code title="10000">10000</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="CLIP"></a><span class="summary-name">CLIP</span> = <code title="0">0</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="ERR_CALL"></a><span class="summary-name">ERR_CALL</span> = <code title="3">3</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="ERR_DEFAULT"></a><span class="summary-name">ERR_DEFAULT</span> = <code title="0">0</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="ERR_DEFAULT2"></a><span class="summary-name">ERR_DEFAULT2</span> = <code title="2084">2084</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="ERR_IGNORE"></a><span class="summary-name">ERR_IGNORE</span> = <code title="0">0</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="ERR_LOG"></a><span class="summary-name">ERR_LOG</span> = <code title="5">5</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="ERR_PRINT"></a><span class="summary-name">ERR_PRINT</span> = <code title="4">4</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="ERR_RAISE"></a><span class="summary-name">ERR_RAISE</span> = <code title="2">2</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="ERR_WARN"></a><span class="summary-name">ERR_WARN</span> = <code title="1">1</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="FLOATING_POINT_SUPPORT"></a><span class="summary-name">FLOATING_POINT_SUPPORT</span> = <code title="1">1</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="FPE_DIVIDEBYZERO"></a><span class="summary-name">FPE_DIVIDEBYZERO</span> = <code title="1">1</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="FPE_INVALID"></a><span class="summary-name">FPE_INVALID</span> = <code title="8">8</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="FPE_OVERFLOW"></a><span class="summary-name">FPE_OVERFLOW</span> = <code title="2">2</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="FPE_UNDERFLOW"></a><span class="summary-name">FPE_UNDERFLOW</span> = <code title="4">4</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="False_"></a><span class="summary-name">False_</span> = <code title="False">False</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="Inf"></a><span class="summary-name">Inf</span> = <code title="inf">inf</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="Infinity"></a><span class="summary-name">Infinity</span> = <code title="inf">inf</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="MAXDIMS"></a><span class="summary-name">MAXDIMS</span> = <code title="32">32</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="NAN"></a><span class="summary-name">NAN</span> = <code title="nan">nan</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="NINF"></a><span class="summary-name">NINF</span> = <code title="-inf">-inf</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="NZERO"></a><span class="summary-name">NZERO</span> = <code title="-0.0">-0.0</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="NaN"></a><span class="summary-name">NaN</span> = <code title="nan">nan</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="PINF"></a><span class="summary-name">PINF</span> = <code title="inf">inf</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="PZERO"></a><span class="summary-name">PZERO</span> = <code title="0.0">0.0</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="RAISE"></a><span class="summary-name">RAISE</span> = <code title="2">2</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="SHIFT_DIVIDEBYZERO"></a><span class="summary-name">SHIFT_DIVIDEBYZERO</span> = <code title="0">0</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="SHIFT_INVALID"></a><span class="summary-name">SHIFT_INVALID</span> = <code title="9">9</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="SHIFT_OVERFLOW"></a><span class="summary-name">SHIFT_OVERFLOW</span> = <code title="3">3</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="SHIFT_UNDERFLOW"></a><span class="summary-name">SHIFT_UNDERFLOW</span> = <code title="6">6</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy-module.html#ScalarType" class="summary-name">ScalarType</a> = <code title="(&lt;type 'int'&gt;,
 &lt;type 'float'&gt;,
 &lt;type 'complex'&gt;,
 &lt;type 'long'&gt;,
 &lt;type 'bool'&gt;,
 &lt;type 'str'&gt;,
 &lt;type 'unicode'&gt;,
 &lt;type 'buffer'&gt;,
..."><code class="variable-group">(</code>&lt;type 'int'&gt;<code class="variable-op">, </code>&lt;type 'float'&gt;<code class="variable-op">, </code>&lt;type 'complex'&gt;<code class="variable-op">, </code><code class="variable-ellipsis">...</code></code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="True_"></a><span class="summary-name">True_</span> = <code title="True">True</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="UFUNC_BUFSIZE_DEFAULT"></a><span class="summary-name">UFUNC_BUFSIZE_DEFAULT</span> = <code title="10000">10000</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="UFUNC_PYVALS_NAME"></a><span class="summary-name">UFUNC_PYVALS_NAME</span> = <code title="'UFUNC_PYVALS'"><code class="variable-quote">'</code><code class="variable-string">UFUNC_PYVALS</code><code class="variable-quote">'</code></code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="WRAP"></a><span class="summary-name">WRAP</span> = <code title="1">1</code>
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="__NUMPY_SETUP__"></a><span class="summary-name">__NUMPY_SETUP__</span> = <code title="False">False</code>
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="__package__"></a><span class="summary-name">__package__</span> = <code title="'numpy'"><code class="variable-quote">'</code><code class="variable-string">numpy</code><code class="variable-quote">'</code></code>
    </td>
  </tr>
<tr class="private">
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="abs"></a><span class="summary-name">abs</span> = <code title="&lt;ufunc 'absolute'&gt;">&lt;ufunc 'absolute'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="absolute"></a><span class="summary-name">absolute</span> = <code title="&lt;ufunc 'absolute'&gt;">&lt;ufunc 'absolute'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="add"></a><span class="summary-name">add</span> = <code title="&lt;ufunc 'add'&gt;">&lt;ufunc 'add'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="arccos"></a><span class="summary-name">arccos</span> = <code title="&lt;ufunc 'arccos'&gt;">&lt;ufunc 'arccos'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="arccosh"></a><span class="summary-name">arccosh</span> = <code title="&lt;ufunc 'arccosh'&gt;">&lt;ufunc 'arccosh'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="arcsin"></a><span class="summary-name">arcsin</span> = <code title="&lt;ufunc 'arcsin'&gt;">&lt;ufunc 'arcsin'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="arcsinh"></a><span class="summary-name">arcsinh</span> = <code title="&lt;ufunc 'arcsinh'&gt;">&lt;ufunc 'arcsinh'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="arctan"></a><span class="summary-name">arctan</span> = <code title="&lt;ufunc 'arctan'&gt;">&lt;ufunc 'arctan'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="arctan2"></a><span class="summary-name">arctan2</span> = <code title="&lt;ufunc 'arctan2'&gt;">&lt;ufunc 'arctan2'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="arctanh"></a><span class="summary-name">arctanh</span> = <code title="&lt;ufunc 'arctanh'&gt;">&lt;ufunc 'arctanh'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="bitwise_and"></a><span class="summary-name">bitwise_and</span> = <code title="&lt;ufunc 'bitwise_and'&gt;">&lt;ufunc 'bitwise_and'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="bitwise_not"></a><span class="summary-name">bitwise_not</span> = <code title="&lt;ufunc 'invert'&gt;">&lt;ufunc 'invert'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="bitwise_or"></a><span class="summary-name">bitwise_or</span> = <code title="&lt;ufunc 'bitwise_or'&gt;">&lt;ufunc 'bitwise_or'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="bitwise_xor"></a><span class="summary-name">bitwise_xor</span> = <code title="&lt;ufunc 'bitwise_xor'&gt;">&lt;ufunc 'bitwise_xor'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="c_"></a><span class="summary-name">c_</span> = <code title="&lt;numpy.lib.index_tricks.CClass object at 0x9fa650c&gt;">&lt;numpy.lib.index_tricks.CClass object at 0x9fa650c&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy-module.html#cast" class="summary-name">cast</a> = <code title="{&lt;type 'numpy.int64'&gt;: &lt;function &lt;lambda&gt; at 0x9e727d4&gt;, &lt;type 'numpy.\
int16'&gt;: &lt;function &lt;lambda&gt; at 0x9e7280c&gt;, &lt;type 'numpy.object_'&gt;: &lt;fu\
nction &lt;lambda&gt; at 0x9e72844&gt;, &lt;type 'numpy.uint32'&gt;: &lt;function &lt;lambd\
a&gt; at 0x9e7287c&gt;, &lt;type 'numpy.bool_'&gt;: &lt;function &lt;lambda&gt; at 0x9e728b\
4&gt;, &lt;type 'numpy.float96'&gt;: &lt;function &lt;lambda&gt; at 0x9e728ec&gt;, &lt;type 'n\
umpy.int32'&gt;: &lt;function &lt;lambda&gt; at 0x9e72924&gt;, &lt;type 'numpy.string_'&gt;\
: &lt;function &lt;lambda&gt; at 0x9e7295c&gt;, &lt;type 'numpy.uint32'&gt;: &lt;function &lt;\
lambda&gt; at 0x9e72994&gt;, &lt;type 'numpy.complex64'&gt;: &lt;function &lt;lambda&gt; at\
...">{&lt;type 'numpy.int64'&gt;: &lt;function &lt;lambda&gt; at 0x9e727d4&gt;<code class="variable-ellipsis">...</code></code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="ceil"></a><span class="summary-name">ceil</span> = <code title="&lt;ufunc 'ceil'&gt;">&lt;ufunc 'ceil'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="conj"></a><span class="summary-name">conj</span> = <code title="&lt;ufunc 'conjugate'&gt;">&lt;ufunc 'conjugate'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="conjugate"></a><span class="summary-name">conjugate</span> = <code title="&lt;ufunc 'conjugate'&gt;">&lt;ufunc 'conjugate'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="cos"></a><span class="summary-name">cos</span> = <code title="&lt;ufunc 'cos'&gt;">&lt;ufunc 'cos'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="cosh"></a><span class="summary-name">cosh</span> = <code title="&lt;ufunc 'cosh'&gt;">&lt;ufunc 'cosh'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="deg2rad"></a><span class="summary-name">deg2rad</span> = <code title="&lt;ufunc 'deg2rad'&gt;">&lt;ufunc 'deg2rad'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="degrees"></a><span class="summary-name">degrees</span> = <code title="&lt;ufunc 'degrees'&gt;">&lt;ufunc 'degrees'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="divide"></a><span class="summary-name">divide</span> = <code title="&lt;ufunc 'divide'&gt;">&lt;ufunc 'divide'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="e"></a><span class="summary-name">e</span> = <code title="2.71828182846">2.71828182846</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="equal"></a><span class="summary-name">equal</span> = <code title="&lt;ufunc 'equal'&gt;">&lt;ufunc 'equal'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="exp"></a><span class="summary-name">exp</span> = <code title="&lt;ufunc 'exp'&gt;">&lt;ufunc 'exp'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="exp2"></a><span class="summary-name">exp2</span> = <code title="&lt;ufunc 'exp2'&gt;">&lt;ufunc 'exp2'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="expm1"></a><span class="summary-name">expm1</span> = <code title="&lt;ufunc 'expm1'&gt;">&lt;ufunc 'expm1'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="fabs"></a><span class="summary-name">fabs</span> = <code title="&lt;ufunc 'fabs'&gt;">&lt;ufunc 'fabs'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="floor"></a><span class="summary-name">floor</span> = <code title="&lt;ufunc 'floor'&gt;">&lt;ufunc 'floor'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="floor_divide"></a><span class="summary-name">floor_divide</span> = <code title="&lt;ufunc 'floor_divide'&gt;">&lt;ufunc 'floor_divide'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="fmax"></a><span class="summary-name">fmax</span> = <code title="&lt;ufunc 'fmax'&gt;">&lt;ufunc 'fmax'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="fmin"></a><span class="summary-name">fmin</span> = <code title="&lt;ufunc 'fmin'&gt;">&lt;ufunc 'fmin'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="fmod"></a><span class="summary-name">fmod</span> = <code title="&lt;ufunc 'fmod'&gt;">&lt;ufunc 'fmod'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="frexp"></a><span class="summary-name">frexp</span> = <code title="&lt;ufunc 'frexp'&gt;">&lt;ufunc 'frexp'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="greater"></a><span class="summary-name">greater</span> = <code title="&lt;ufunc 'greater'&gt;">&lt;ufunc 'greater'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="greater_equal"></a><span class="summary-name">greater_equal</span> = <code title="&lt;ufunc 'greater_equal'&gt;">&lt;ufunc 'greater_equal'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="hypot"></a><span class="summary-name">hypot</span> = <code title="&lt;ufunc 'hypot'&gt;">&lt;ufunc 'hypot'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy-module.html#index_exp" class="summary-name">index_exp</a> = <code title="&lt;numpy.lib.index_tricks.IndexExpression object at 0x9fa666c&gt;">&lt;numpy.lib.index_tricks.IndexExpression object at <code class="variable-ellipsis">...</code></code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="inf"></a><span class="summary-name">inf</span> = <code title="inf">inf</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="infty"></a><span class="summary-name">infty</span> = <code title="inf">inf</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="invert"></a><span class="summary-name">invert</span> = <code title="&lt;ufunc 'invert'&gt;">&lt;ufunc 'invert'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="isfinite"></a><span class="summary-name">isfinite</span> = <code title="&lt;ufunc 'isfinite'&gt;">&lt;ufunc 'isfinite'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="isinf"></a><span class="summary-name">isinf</span> = <code title="&lt;ufunc 'isinf'&gt;">&lt;ufunc 'isinf'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="isnan"></a><span class="summary-name">isnan</span> = <code title="&lt;ufunc 'isnan'&gt;">&lt;ufunc 'isnan'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="ldexp"></a><span class="summary-name">ldexp</span> = <code title="&lt;ufunc 'ldexp'&gt;">&lt;ufunc 'ldexp'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="left_shift"></a><span class="summary-name">left_shift</span> = <code title="&lt;ufunc 'left_shift'&gt;">&lt;ufunc 'left_shift'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="less"></a><span class="summary-name">less</span> = <code title="&lt;ufunc 'less'&gt;">&lt;ufunc 'less'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="less_equal"></a><span class="summary-name">less_equal</span> = <code title="&lt;ufunc 'less_equal'&gt;">&lt;ufunc 'less_equal'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="little_endian"></a><span class="summary-name">little_endian</span> = <code title="True">True</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="log"></a><span class="summary-name">log</span> = <code title="&lt;ufunc 'log'&gt;">&lt;ufunc 'log'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="log10"></a><span class="summary-name">log10</span> = <code title="&lt;ufunc 'log10'&gt;">&lt;ufunc 'log10'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="log1p"></a><span class="summary-name">log1p</span> = <code title="&lt;ufunc 'log1p'&gt;">&lt;ufunc 'log1p'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="logaddexp"></a><span class="summary-name">logaddexp</span> = <code title="&lt;ufunc 'logaddexp'&gt;">&lt;ufunc 'logaddexp'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="logaddexp2"></a><span class="summary-name">logaddexp2</span> = <code title="&lt;ufunc 'logaddexp2'&gt;">&lt;ufunc 'logaddexp2'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="logical_and"></a><span class="summary-name">logical_and</span> = <code title="&lt;ufunc 'logical_and'&gt;">&lt;ufunc 'logical_and'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="logical_not"></a><span class="summary-name">logical_not</span> = <code title="&lt;ufunc 'logical_not'&gt;">&lt;ufunc 'logical_not'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="logical_or"></a><span class="summary-name">logical_or</span> = <code title="&lt;ufunc 'logical_or'&gt;">&lt;ufunc 'logical_or'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="logical_xor"></a><span class="summary-name">logical_xor</span> = <code title="&lt;ufunc 'logical_xor'&gt;">&lt;ufunc 'logical_xor'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="maximum"></a><span class="summary-name">maximum</span> = <code title="&lt;ufunc 'maximum'&gt;">&lt;ufunc 'maximum'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="mgrid"></a><span class="summary-name">mgrid</span> = <code title="&lt;numpy.lib.index_tricks.nd_grid object at 0x9fa63ec&gt;">&lt;numpy.lib.index_tricks.nd_grid object at 0x9fa63ec&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="minimum"></a><span class="summary-name">minimum</span> = <code title="&lt;ufunc 'minimum'&gt;">&lt;ufunc 'minimum'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="mod"></a><span class="summary-name">mod</span> = <code title="&lt;ufunc 'remainder'&gt;">&lt;ufunc 'remainder'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="modf"></a><span class="summary-name">modf</span> = <code title="&lt;ufunc 'modf'&gt;">&lt;ufunc 'modf'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="multiply"></a><span class="summary-name">multiply</span> = <code title="&lt;ufunc 'multiply'&gt;">&lt;ufunc 'multiply'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="nan"></a><span class="summary-name">nan</span> = <code title="nan">nan</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy-module.html#nbytes" class="summary-name">nbytes</a> = <code title="{&lt;type 'numpy.int64'&gt;: 8, &lt;type 'numpy.int16'&gt;: 2, &lt;type 'numpy.object\
_'&gt;: 4, &lt;type 'numpy.uint32'&gt;: 4, &lt;type 'numpy.bool_'&gt;: 1, &lt;type 'nump\
y.float96'&gt;: 12, &lt;type 'numpy.int32'&gt;: 4, &lt;type 'numpy.string_'&gt;: 0, &lt;\
type 'numpy.uint32'&gt;: 4, &lt;type 'numpy.complex64'&gt;: 8, &lt;type 'numpy.uni\
code_'&gt;: 0, &lt;type 'numpy.uint64'&gt;: 8, &lt;type 'numpy.int8'&gt;: 1, &lt;type 'n\
umpy.complex128'&gt;: 16, &lt;type 'numpy.uint8'&gt;: 1, &lt;type 'numpy.void'&gt;: 0\
, &lt;type 'numpy.float32'&gt;: 4, &lt;type 'numpy.int32'&gt;: 4, &lt;type 'numpy.com\
plex192'&gt;: 24, &lt;type 'numpy.uint16'&gt;: 2, &lt;type 'numpy.float64'&gt;: 8}">{&lt;type 'numpy.int64'&gt;: 8, &lt;type 'numpy.int16'&gt;: 2, &lt;t<code class="variable-ellipsis">...</code></code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="negative"></a><span class="summary-name">negative</span> = <code title="&lt;ufunc 'negative'&gt;">&lt;ufunc 'negative'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="newaxis"></a><span class="summary-name">newaxis</span> = <code title="None">None</code><br />
      hash(x)
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="not_equal"></a><span class="summary-name">not_equal</span> = <code title="&lt;ufunc 'not_equal'&gt;">&lt;ufunc 'not_equal'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="ogrid"></a><span class="summary-name">ogrid</span> = <code title="&lt;numpy.lib.index_tricks.nd_grid object at 0x9fa640c&gt;">&lt;numpy.lib.index_tricks.nd_grid object at 0x9fa640c&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="ones_like"></a><span class="summary-name">ones_like</span> = <code title="&lt;ufunc 'ones_like'&gt;">&lt;ufunc 'ones_like'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="pi"></a><span class="summary-name">pi</span> = <code title="3.14159265359">3.14159265359</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="power"></a><span class="summary-name">power</span> = <code title="&lt;ufunc 'power'&gt;">&lt;ufunc 'power'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="r_"></a><span class="summary-name">r_</span> = <code title="&lt;numpy.lib.index_tricks.RClass object at 0x9fa648c&gt;">&lt;numpy.lib.index_tricks.RClass object at 0x9fa648c&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="rad2deg"></a><span class="summary-name">rad2deg</span> = <code title="&lt;ufunc 'rad2deg'&gt;">&lt;ufunc 'rad2deg'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="radians"></a><span class="summary-name">radians</span> = <code title="&lt;ufunc 'radians'&gt;">&lt;ufunc 'radians'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="reciprocal"></a><span class="summary-name">reciprocal</span> = <code title="&lt;ufunc 'reciprocal'&gt;">&lt;ufunc 'reciprocal'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="remainder"></a><span class="summary-name">remainder</span> = <code title="&lt;ufunc 'remainder'&gt;">&lt;ufunc 'remainder'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="right_shift"></a><span class="summary-name">right_shift</span> = <code title="&lt;ufunc 'right_shift'&gt;">&lt;ufunc 'right_shift'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="rint"></a><span class="summary-name">rint</span> = <code title="&lt;ufunc 'rint'&gt;">&lt;ufunc 'rint'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="s_"></a><span class="summary-name">s_</span> = <code title="&lt;numpy.lib.index_tricks.IndexExpression object at 0x9fa66ac&gt;">&lt;numpy.lib.index_tricks.IndexExpression object at 0x9fa66ac&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy-module.html#sctypeDict" class="summary-name">sctypeDict</a> = <code title="{0: &lt;type 'numpy.bool_'&gt;,
 1: &lt;type 'numpy.int8'&gt;,
 2: &lt;type 'numpy.uint8'&gt;,
 3: &lt;type 'numpy.int16'&gt;,
 4: &lt;type 'numpy.uint16'&gt;,
 5: &lt;type 'numpy.int32'&gt;,
 6: &lt;type 'numpy.uint32'&gt;,
 7: &lt;type 'numpy.int32'&gt;,
..."><code class="variable-group">{</code>0<code class="variable-op">: </code>&lt;type 'numpy.bool_'&gt;<code class="variable-op">, </code>1<code class="variable-op">: </code>&lt;type 'numpy.int8'&gt;<code class="variable-op">,</code><code class="variable-ellipsis">...</code></code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy-module.html#sctypeNA" class="summary-name">sctypeNA</a> = <code title="{'?': 'Bool',
 'B': 'UInt8',
 'Bool': &lt;type 'numpy.bool_'&gt;,
 'Complex32': &lt;type 'numpy.complex64'&gt;,
 'Complex64': &lt;type 'numpy.complex128'&gt;,
 'Complex96': &lt;type 'numpy.complex192'&gt;,
 'D': 'Complex64',
 'F': 'Complex32',
..."><code class="variable-group">{</code><code class="variable-quote">'</code><code class="variable-string">?</code><code class="variable-quote">'</code><code class="variable-op">: </code><code class="variable-quote">'</code><code class="variable-string">Bool</code><code class="variable-quote">'</code><code class="variable-op">, </code><code class="variable-quote">'</code><code class="variable-string">B</code><code class="variable-quote">'</code><code class="variable-op">: </code><code class="variable-quote">'</code><code class="variable-string">UInt8</code><code class="variable-quote">'</code><code class="variable-op">, </code><code class="variable-quote">'</code><code class="variable-string">Bool</code><code class="variable-quote">'</code><code class="variable-op">: </code>&lt;type 'numpy.bo<code class="variable-ellipsis">...</code></code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy-module.html#sctypes" class="summary-name">sctypes</a> = <code title="{'complex': [&lt;type 'numpy.complex64'&gt;,
             &lt;type 'numpy.complex128'&gt;,
             &lt;type 'numpy.complex192'&gt;],
 'float': [&lt;type 'numpy.float32'&gt;,
           &lt;type 'numpy.float64'&gt;,
           &lt;type 'numpy.float96'&gt;],
 'int': [&lt;type 'numpy.int8'&gt;,
         &lt;type 'numpy.int16'&gt;,
..."><code class="variable-group">{</code><code class="variable-quote">'</code><code class="variable-string">complex</code><code class="variable-quote">'</code><code class="variable-op">: </code><code class="variable-group">[</code>&lt;type 'numpy.complex64'&gt;<code class="variable-op">, </code>&lt;type 'numpy.<code class="variable-ellipsis">...</code></code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="sign"></a><span class="summary-name">sign</span> = <code title="&lt;ufunc 'sign'&gt;">&lt;ufunc 'sign'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="signbit"></a><span class="summary-name">signbit</span> = <code title="&lt;ufunc 'signbit'&gt;">&lt;ufunc 'signbit'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="sin"></a><span class="summary-name">sin</span> = <code title="&lt;ufunc 'sin'&gt;">&lt;ufunc 'sin'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="sinh"></a><span class="summary-name">sinh</span> = <code title="&lt;ufunc 'sinh'&gt;">&lt;ufunc 'sinh'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="sqrt"></a><span class="summary-name">sqrt</span> = <code title="&lt;ufunc 'sqrt'&gt;">&lt;ufunc 'sqrt'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="square"></a><span class="summary-name">square</span> = <code title="&lt;ufunc 'square'&gt;">&lt;ufunc 'square'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="subtract"></a><span class="summary-name">subtract</span> = <code title="&lt;ufunc 'subtract'&gt;">&lt;ufunc 'subtract'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="tan"></a><span class="summary-name">tan</span> = <code title="&lt;ufunc 'tan'&gt;">&lt;ufunc 'tan'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="tanh"></a><span class="summary-name">tanh</span> = <code title="&lt;ufunc 'tanh'&gt;">&lt;ufunc 'tanh'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="true_divide"></a><span class="summary-name">true_divide</span> = <code title="&lt;ufunc 'true_divide'&gt;">&lt;ufunc 'true_divide'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="trunc"></a><span class="summary-name">trunc</span> = <code title="&lt;ufunc 'trunc'&gt;">&lt;ufunc 'trunc'&gt;</code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy-module.html#typeDict" class="summary-name">typeDict</a> = <code title="{0: &lt;type 'numpy.bool_'&gt;,
 1: &lt;type 'numpy.int8'&gt;,
 2: &lt;type 'numpy.uint8'&gt;,
 3: &lt;type 'numpy.int16'&gt;,
 4: &lt;type 'numpy.uint16'&gt;,
 5: &lt;type 'numpy.int32'&gt;,
 6: &lt;type 'numpy.uint32'&gt;,
 7: &lt;type 'numpy.int32'&gt;,
..."><code class="variable-group">{</code>0<code class="variable-op">: </code>&lt;type 'numpy.bool_'&gt;<code class="variable-op">, </code>1<code class="variable-op">: </code>&lt;type 'numpy.int8'&gt;<code class="variable-op">, </code>2<code class="variable-ellipsis">...</code></code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy-module.html#typeNA" class="summary-name">typeNA</a> = <code title="{'?': 'Bool',
 'B': 'UInt8',
 'Bool': &lt;type 'numpy.bool_'&gt;,
 'Complex32': &lt;type 'numpy.complex64'&gt;,
 'Complex64': &lt;type 'numpy.complex128'&gt;,
 'Complex96': &lt;type 'numpy.complex192'&gt;,
 'D': 'Complex64',
 'F': 'Complex32',
..."><code class="variable-group">{</code><code class="variable-quote">'</code><code class="variable-string">?</code><code class="variable-quote">'</code><code class="variable-op">: </code><code class="variable-quote">'</code><code class="variable-string">Bool</code><code class="variable-quote">'</code><code class="variable-op">, </code><code class="variable-quote">'</code><code class="variable-string">B</code><code class="variable-quote">'</code><code class="variable-op">: </code><code class="variable-quote">'</code><code class="variable-string">UInt8</code><code class="variable-quote">'</code><code class="variable-op">, </code><code class="variable-quote">'</code><code class="variable-string">Bool</code><code class="variable-quote">'</code><code class="variable-op">: </code>&lt;type 'numpy.bool<code class="variable-ellipsis">...</code></code>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="numpy-module.html#typecodes" class="summary-name">typecodes</a> = <code title="{'All': '?bhilqpBHILQPfdgFDGSUVO',
 'AllFloat': 'fdgFDG',
 'AllInteger': 'bBhHiIlLqQpP',
 'Character': 'c',
 'Complex': 'FDG',
 'Float': 'fdg',
 'Integer': 'bhilqp',
 'UnsignedInteger': 'BHILQP'}"><code class="variable-group">{</code><code class="variable-quote">'</code><code class="variable-string">All</code><code class="variable-quote">'</code><code class="variable-op">: </code><code class="variable-quote">'</code><code class="variable-string">?bhilqpBHILQPfdgFDGSUVO</code><code class="variable-quote">'</code><code class="variable-op">, </code><code class="variable-quote">'</code><code class="variable-string">AllFloat</code><code class="variable-quote">'</code><code class="variable-op">: </code><code class="variable-quote">'</code><code class="variable-string">fd</code><code class="variable-ellipsis">...</code></code>
    </td>
  </tr>
</table>
<!-- ==================== FUNCTION DETAILS ==================== -->
<a name="section-FunctionDetails"></a>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td colspan="2" class="table-header">
    <table border="0" cellpadding="0" cellspacing="0" width="100%">
      <tr valign="top">
        <td align="left"><span class="table-header">Function Details</span></td>
        <td align="right" valign="top"
         ><span class="options">[<a href="#section-FunctionDetails"
         class="privatelink" onclick="toggle_private();"
         >hide private</a>]</span></td>
      </tr>
    </table>
  </td>
</tr>
</table>
<a name="add_docstring"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">add_docstring</span>(<span class="sig-arg">obj</span>,
        <span class="sig-arg">docstring</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Add a docstring to a built-in obj if possible. If the obj already has 
  a docstring raise a RuntimeError If this routine does not know how to add
  a docstring to the object raise a TypeError</p>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="add_newdoc"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">add_newdoc</span>(<span class="sig-arg">place</span>,
        <span class="sig-arg">obj</span>,
        <span class="sig-arg">doc</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Adds documentation to obj which is in module place.</p>
<p>If doc is a string add it to obj as a docstring</p>
<dl class="rst-docutils">
<dt>If doc is a tuple, then the first element is interpreted as</dt>
<dd><dl class="rst-first rst-last rst-docutils">
<dt>an attribute of obj and the second as the docstring</dt>
<dd>(method, docstring)</dd>
</dl>
</dd>
<dt>If doc is a list, then each element of the list should be a</dt>
<dd>sequence of length two --&gt; [(method1, docstring1),
(method2, docstring2), ...]</dd>
</dl>
<p>This routine never raises an error.</p>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="alen"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">alen</span>(<span class="sig-arg">a</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return the length of the first dimension of the input array.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Input array.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>alen <span class="classifier-delimiter">:</span> <span class="rst-classifier">int</span></dt>
<dd>Length of the first dimension of <code class="link">a</code>.</dd>
</dl>
</div>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<p>shape</p>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>a = np.zeros((7,4,5))
<span class="py-prompt">&gt;&gt;&gt; </span>a.shape[0]
<span class="py-output">7</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.alen(a)
<span class="py-output">7</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="all"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">all</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">axis</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">out</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Test whether all array elements along a given axis evaluate to True.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Input array or object that can be converted to an array.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="rst-classifier">int, optional</span></dt>
<dd>Axis along which an logical AND is performed.
The default (<code class="link">axis</code> = <code class="link">None</code>) is to perform a logical AND
over a flattened input array. <code class="link">axis</code> may be negative, in which
case it counts from the last to the first axis.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray, optional</span></dt>
<dd>Alternative output array in which to place the result.
It must have the same shape as the expected output and
the type is preserved.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>all <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray, bool</span></dt>
<dd>A new boolean or array is returned unless <code class="link">out</code> is
specified, in which case a reference to <code class="link">out</code> is returned.</dd>
</dl>
</div>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<p>ndarray.all : equivalent method</p>
</div>
<div class="rst-section" id="rst-notes">
<h1 class="heading">Notes</h1>
<p>Not a Number (NaN), positive infinity and negative infinity
evaluate to <code class="link">True</code> because these are not equal to zero.</p>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.all([[True,False],[True,True]])
<span class="py-output">False</span></pre>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.all([[True,False],[True,True]], axis=0)
<span class="py-output">array([ True, False], dtype=bool)</span></pre>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.all([-1, 4, 5])
<span class="py-output">True</span></pre>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.all([1.0, np.nan])
<span class="py-output">True</span></pre>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>o=np.array([False])
<span class="py-prompt">&gt;&gt;&gt; </span>z=np.all([-1, 4, 5], out=o)
<span class="py-prompt">&gt;&gt;&gt; </span>id(z), id(o), z
<span class="py-output">(28293632, 28293632, array([ True], dtype=bool))</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="allclose"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">allclose</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">b</span>,
        <span class="sig-arg">rtol</span>=<span class="sig-default">1e-05</span>,
        <span class="sig-arg">atol</span>=<span class="sig-default">1e-08</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Returns True if two arrays are element-wise equal within a tolerance.

The tolerance values are positive, typically very small numbers.  The
relative difference (`rtol` * abs(`b`)) and the absolute difference
`atol` are added together to compare against the absolute difference
between `a` and `b`.

Parameters
----------
a, b : array_like
    Input arrays to compare.
rtol : float
    The relative tolerance parameter (see Notes).
atol : float
    The absolute tolerance parameter (see Notes).

Returns
-------
y : bool
    Returns True if the two arrays are equal within the given
    tolerance; False otherwise. If either array contains NaN, then
    False is returned.

See Also
--------
all, any, alltrue, sometrue

Notes
-----
If the following equation is element-wise True, then allclose returns
True.

 absolute(`a` - `b`) &lt;= (`atol` + `rtol` * absolute(`b`))

Examples
--------
&gt;&gt;&gt; np.allclose([1e10,1e-7], [1.00001e10,1e-8])
False
&gt;&gt;&gt; np.allclose([1e10,1e-8], [1.00001e10,1e-9])
True
&gt;&gt;&gt; np.allclose([1e10,1e-8], [1.0001e10,1e-9])
False
&gt;&gt;&gt; np.allclose([1.0, np.nan], [1.0, np.nan])
False

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="alltrue"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">alltrue</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">axis</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">out</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Check if all elements of input array are true.</p>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<p>numpy.all : Equivalent function; see for details.</p>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="alterdot"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">alterdot</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">
Change `dot`, `vdot`, and `innerproduct` to use accelerated BLAS functions.

Typically, as a user of Numpy, you do not explicitly call this function. If
Numpy is built with an accelerated BLAS, this function is automatically
called when Numpy is imported.

When Numpy is built with an accelerated BLAS like ATLAS, these functions
are replaced to make use of the faster implementations.  The faster
implementations only affect float32, float64, complex64, and complex128
arrays. Furthermore, the BLAS API only includes matrix-matrix,
matrix-vector, and vector-vector products. Products of arrays with larger
dimensionalities use the built in functions and are not accelerated.

See Also
--------
restoredot : `restoredot` undoes the effects of `alterdot`.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="amax"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">amax</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">axis</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">out</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return the maximum along an axis.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Input data.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="rst-classifier">int, optional</span></dt>
<dd>Axis along which to operate.  By default flattened input is used.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray, optional</span></dt>
<dd>Alternative output array in which to place the result.  Must
be of the same shape and buffer length as the expected output.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>amax <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray</span></dt>
<dd>A new array or a scalar with the result, or a reference to <code class="link">out</code>
if it was specified.</dd>
</dl>
</div>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<p>nanmax: nan values are ignored instead of being propagated
fmax: same behavior as the C99 fmax function</p>
</div>
<div class="rst-section" id="rst-notes">
<h1 class="heading">Notes</h1>
<p>NaN values are propagated, that is if at least one item is nan, the
corresponding max value will be nan as well. To ignore NaN values (matlab
behavior), please use nanmax.</p>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>a = np.arange(4).reshape((2,2))
<span class="py-prompt">&gt;&gt;&gt; </span>a
<span class="py-output">array([[0, 1],</span>
<span class="py-output">       [2, 3]])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.amax(a, axis=0)
<span class="py-output">array([2, 3])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.amax(a, axis=1)
<span class="py-output">array([1, 3])</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="amin"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">amin</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">axis</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">out</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return the minimum along an axis.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Input data.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="rst-classifier">int, optional</span></dt>
<dd>Axis along which to operate.  By default a flattened input is used.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray, optional</span></dt>
<dd>Alternative output array in which to place the result.  Must
be of the same shape and buffer length as the expected output.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>amin <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray</span></dt>
<dd>A new array or a scalar with the result, or a reference to <code class="link">out</code> if it
was specified.</dd>
</dl>
</div>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<p>nanmin: nan values are ignored instead of being propagated
fmin: same behavior as the C99 fmin function</p>
</div>
<div class="rst-section" id="rst-notes">
<h1 class="heading">Notes</h1>
<p>NaN values are propagated, that is if at least one item is nan, the
corresponding min value will be nan as well. To ignore NaN values (matlab
behavior), please use nanmin.</p>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>a = np.arange(4).reshape((2,2))
<span class="py-prompt">&gt;&gt;&gt; </span>a
<span class="py-output">array([[0, 1],</span>
<span class="py-output">       [2, 3]])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.amin(a)           <span class="py-comment"># Minimum of the flattened array</span>
<span class="py-output">0</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.amin(a, axis=0)         <span class="py-comment"># Minima along the first axis</span>
<span class="py-output">array([0, 1])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.amin(a, axis=1)         <span class="py-comment"># Minima along the second axis</span>
<span class="py-output">array([0, 2])</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="angle"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">angle</span>(<span class="sig-arg">z</span>,
        <span class="sig-arg">deg</span>=<span class="sig-default">0</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return the angle of the complex argument.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>z <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>A complex number or sequence of complex numbers.</dd>
<dt>deg <span class="classifier-delimiter">:</span> <span class="rst-classifier">bool, optional</span></dt>
<dd>Return angle in degrees if True, radians if False (default).</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>angle <span class="classifier-delimiter">:</span> <span class="rst-classifier">{ndarray, scalar}</span></dt>
<dd>The counterclockwise angle from the positive real axis on
the complex plane, with dtype as numpy.float64.</dd>
</dl>
</div>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<p>arctan2</p>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.angle([1.0, 1.0j, 1+1j])               <span class="py-comment"># in radians</span>
<span class="py-output">array([ 0.        ,  1.57079633,  0.78539816])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.angle(1+1j, deg=True)                  <span class="py-comment"># in degrees</span>
<span class="py-output">45.0</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="any"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">any</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">axis</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">out</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Test whether any array element along a given axis evaluates to True.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Input array or object that can be converted to an array.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="rst-classifier">int, optional</span></dt>
<dd>Axis along which an logical OR is performed.
The default (<code class="link">axis</code> = <code class="link">None</code>) is to perform a logical OR
over a flattened input array. <code class="link">axis</code> may be negative, in which
case it counts from the last to the first axis.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray, optional</span></dt>
<dd>Alternative output array in which to place the result.
It must have the same shape as the expected output and
the type is preserved.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>any <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray, bool</span></dt>
<dd>A new boolean or array is returned unless <code class="link">out</code> is
specified, in which case a reference to <code class="link">out</code> is returned.</dd>
</dl>
</div>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<p>ndarray.any : equivalent method</p>
</div>
<div class="rst-section" id="rst-notes">
<h1 class="heading">Notes</h1>
<p>Not a Number (NaN), positive infinity and negative infinity
evaluate to <code class="link">True</code> because these are not equal to zero.</p>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.any([[True, False], [True, True]])
<span class="py-output">True</span></pre>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.any([[True, False], [False, False]], axis=0)
<span class="py-output">array([ True, False], dtype=bool)</span></pre>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.any([-1, 0, 5])
<span class="py-output">True</span></pre>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.any(np.nan)
<span class="py-output">True</span></pre>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>o=np.array([False])
<span class="py-prompt">&gt;&gt;&gt; </span>z=np.any([-1, 4, 5], out=o)
<span class="py-prompt">&gt;&gt;&gt; </span>id(z), id(o), z
<span class="py-output">(28224368, 28224368, array([ True], dtype=bool))</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="append"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">append</span>(<span class="sig-arg">arr</span>,
        <span class="sig-arg">values</span>,
        <span class="sig-arg">axis</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Append values to the end of an array.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>arr <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Values are appended to a copy of this array.</dd>
<dt>values <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>These values are appended to a copy of <code class="link">arr</code>.  It must be of the
correct shape (the same shape as <code class="link">arr</code>, excluding <code class="link">axis</code>).  If <code class="link">axis</code>
is not specified, <code class="link">values</code> can be any shape and will be flattened
before use.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="rst-classifier">int, optional</span></dt>
<dd>The axis along which <code class="link">values</code> are appended.  If <code class="link">axis</code> is not given,
both <code class="link">arr</code> and <code class="link">values</code> are flattened before use.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray</span></dt>
<dd>A copy of <code class="link">arr</code> with <code class="link">values</code> appended to <code class="link">axis</code>.  Note that <code class="link">append</code>
does not occur in-place: a new array is allocated and filled.  If
<code class="link">axis</code> is None, <code class="link">out</code> is a flattened array.</dd>
</dl>
</div>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<p>insert : Insert elements into an array.
delete : Delete elements from an array.</p>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.append([1, 2, 3], [[4, 5, 6], [7, 8, 9]])
<span class="py-output">array([1, 2, 3, 4, 5, 6, 7, 8, 9])</span></pre>
<p>When <code class="link">axis</code> is specified, <code class="link">values</code> must have the correct shape.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.append([[1, 2, 3], [4, 5, 6]], [[7, 8, 9]], axis=0)
<span class="py-output">array([[1, 2, 3],</span>
<span class="py-output">       [4, 5, 6],</span>
<span class="py-output">       [7, 8, 9]])</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="apply_along_axis"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">apply_along_axis</span>(<span class="sig-arg">func1d</span>,
        <span class="sig-arg">axis</span>,
        <span class="sig-arg">arr</span>,
        <span class="sig-arg">*args</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Apply a function to 1-D slices along the given axis.

Execute `func1d(a, *args)` where `func1d` operates on 1-D arrays and `a`
is a 1-D slice of `arr` along `axis`.

Parameters
----------
func1d : function
    This function should accept 1-D arrays. It is applied to 1-D
    slices of `arr` along the specified axis.
axis : integer
    Axis along which `arr` is sliced.
arr : ndarray
    Input array.
args : any
    Additional arguments to `func1d`.

Returns
-------
outarr : ndarray
    The output array. The shape of `outarr` is identical to the shape of
    `arr`, except along the `axis` dimension, where the length of `outarr`
    is equal to the size of the return value of `func1d`.  If `func1d`
    returns a scalar `outarr` will have one fewer dimensions than `arr`.

See Also
--------
apply_over_axes : Apply a function repeatedly over multiple axes.

Examples
--------
&gt;&gt;&gt; def my_func(a):
...     &quot;&quot;&quot;Average first and last element of a 1-D array&quot;&quot;&quot;
...     return (a[0] + a[-1]) * 0.5
&gt;&gt;&gt; b = np.array([[1,2,3], [4,5,6], [7,8,9]])
&gt;&gt;&gt; np.apply_along_axis(my_func, 0, b)
array([4., 5., 6.])
&gt;&gt;&gt; np.apply_along_axis(my_func, 1, b)
array([2., 5., 8.])

For a function that doesn't return a scalar, the number of dimensions in
`outarr` is the same as `arr`.

&gt;&gt;&gt; def new_func(a):
...     &quot;&quot;&quot;Divide elements of a by 2.&quot;&quot;&quot;
...     return a * 0.5
&gt;&gt;&gt; b = np.array([[1,2,3], [4,5,6], [7,8,9]])
&gt;&gt;&gt; np.apply_along_axis(new_func, 0, b)
array([[ 0.5,  1. ,  1.5],
       [ 2. ,  2.5,  3. ],
       [ 3.5,  4. ,  4.5]])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="apply_over_axes"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">apply_over_axes</span>(<span class="sig-arg">func</span>,
        <span class="sig-arg">a</span>,
        <span class="sig-arg">axes</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Apply a function repeatedly over multiple axes.

`func` is called as `res = func(a, axis)`, where `axis` is the first
element of `axes`.  The result `res` of the function call must have
either the same dimensions as `a` or one less dimension. If `res` has one
less dimension than `a`, a dimension is inserted before `axis`.
The call to `func` is then repeated for each axis in  `axes`,
with `res` as the first argument.

Parameters
----------
func : function
    This function must take two arguments, `func(a, axis)`.
a : ndarray
    Input array.
axes : array_like
    Axes over which `func` is applied, the elements must be
    integers.

Returns
-------
val : ndarray
    The output array. The number of dimensions is the same as `a`, but
    the shape can be different. This depends on whether `func` changes
    the shape of its output with respect to its input.

See Also
--------
apply_along_axis :
    Apply a function to 1-D slices of an array along the given axis.

Examples
--------
&gt;&gt;&gt; a = np.arange(24).reshape(2,3,4)
&gt;&gt;&gt; a
array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]],
       [[12, 13, 14, 15],
        [16, 17, 18, 19],
        [20, 21, 22, 23]]])

Sum over axes 0 and 2. The result has same number of dimensions
as the original array:

&gt;&gt;&gt; np.apply_over_axes(np.sum, a, [0,2])
array([[[ 60],
        [ 92],
        [124]]])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="arange"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">arange</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">
arange([start,] stop[, step,], dtype=None)

Return evenly spaced values within a given interval.

Values are generated within the half-open interval ``[start, stop)``
(in other words, the interval including `start` but excluding `stop`).
For integer arguments the function is equivalent to the Python built-in
`range &lt;http://docs.python.org/lib/built-in-funcs.html&gt;`_ function,
but returns a ndarray rather than a list.

Parameters
----------
start : number, optional
    Start of interval.  The interval includes this value.  The default
    start value is 0.
stop : number
    End of interval.  The interval does not include this value.
step : number, optional
    Spacing between values.  For any output `out`, this is the distance
    between two adjacent values, ``out[i+1] - out[i]``.  The default
    step size is 1.  If `step` is specified, `start` must also be given.
dtype : dtype
    The type of the output array.  If `dtype` is not given, infer the data
    type from the other input arguments.

Returns
-------
out : ndarray
    Array of evenly spaced values.

    For floating point arguments, the length of the result is
    ``ceil((stop - start)/step)``.  Because of floating point overflow,
    this rule may result in the last element of `out` being greater
    than `stop`.

See Also
--------
linspace : Evenly spaced numbers with careful handling of endpoints.
ogrid: Arrays of evenly spaced numbers in N-dimensions
mgrid: Grid-shaped arrays of evenly spaced numbers in N-dimensions

Examples
--------
&gt;&gt;&gt; np.arange(3)
array([0, 1, 2])
&gt;&gt;&gt; np.arange(3.0)
array([ 0.,  1.,  2.])
&gt;&gt;&gt; np.arange(3,7)
array([3, 4, 5, 6])
&gt;&gt;&gt; np.arange(3,7,2)
array([3, 5])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="argmax"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">argmax</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">axis</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Indices of the maximum values along an axis.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Input array.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="rst-classifier">int, optional</span></dt>
<dd>By default, the index is into the flattened array, otherwise
along the specified axis.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>index_array <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray, int</span></dt>
<dd>Array of indices into the array.  It has the same shape as <code class="link">a</code>,
except with <code class="link">axis</code> removed.</dd>
</dl>
</div>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<p>argmin : Indices of the minimum values along an axis.
amax : The maximum value along a given axis.
unravel_index : Convert a flat index into an index tuple.</p>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>a = np.arange(6).reshape(2,3)
<span class="py-prompt">&gt;&gt;&gt; </span>np.argmax(a)
<span class="py-output">5</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.argmax(a, axis=0)
<span class="py-output">array([1, 1, 1])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.argmax(a, axis=1)
<span class="py-output">array([2, 2])</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="argmin"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">argmin</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">axis</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return the indices of the minimum values along an axis.</p>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<dl class="rst-docutils">
<dt>argmax <span class="classifier-delimiter">:</span> <span class="rst-classifier">Similar function.  Please refer to <code class="link">numpy.argmax</code> for detailed</span></dt>
<dd>documentation.</dd>
</dl>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="argsort"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">argsort</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">axis</span>=<span class="sig-default">-1</span>,
        <span class="sig-arg">kind</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string">quicksort</code><code class="variable-quote">'</code></span>,
        <span class="sig-arg">order</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Returns the indices that would sort an array.</p>
<p>Perform an indirect sort along the given axis using the algorithm specified
by the <code class="link">kind</code> keyword. It returns an array of indices of the same shape as
<code class="link">a</code> that index data along the given axis in sorted order.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Array to sort.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="rst-classifier">int or None, optional</span></dt>
<dd>Axis along which to sort.  The default is -1 (the last axis). If None,
the flattened array is used.</dd>
<dt>kind <span class="classifier-delimiter">:</span> <span class="rst-classifier">{'quicksort', 'mergesort', 'heapsort'}, optional</span></dt>
<dd>Sorting algorithm.</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="rst-classifier">list, optional</span></dt>
<dd>When <code class="link">a</code> is an array with fields defined, this argument specifies
which fields to compare first, second, etc.  Not all fields need be
specified.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>index_array <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray, int</span></dt>
<dd>Array of indices that sort <code class="link">a</code> along the specified axis.
In other words, <tt class="rst-docutils literal"><span class="pre">a[index_array]</span></tt> yields a sorted <code class="link">a</code>.</dd>
</dl>
</div>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<p>sort : Describes sorting algorithms used.
lexsort : Indirect stable sort with multiple keys.
ndarray.sort : Inplace sort.</p>
</div>
<div class="rst-section" id="rst-notes">
<h1 class="heading">Notes</h1>
<p>See <code class="link">sort</code> for notes on the different sorting algorithms.</p>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<p>One dimensional array:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>x = np.array([3, 1, 2])
<span class="py-prompt">&gt;&gt;&gt; </span>np.argsort(x)
<span class="py-output">array([1, 2, 0])</span></pre>
<p>Two-dimensional array:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>x = np.array([[0, 3], [2, 2]])
<span class="py-prompt">&gt;&gt;&gt; </span>x
<span class="py-output">array([[0, 3],</span>
<span class="py-output">       [2, 2]])</span></pre>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.argsort(x, axis=0)
<span class="py-output">array([[0, 1],</span>
<span class="py-output">       [1, 0]])</span></pre>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.argsort(x, axis=1)
<span class="py-output">array([[0, 1],</span>
<span class="py-output">       [0, 1]])</span></pre>
<p>Sorting with keys:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>x = np.array([(1, 0), (0, 1)], dtype=[(<span class="py-string">'x'</span>, <span class="py-string">'&lt;i4'</span>), (<span class="py-string">'y'</span>, <span class="py-string">'&lt;i4'</span>)])
<span class="py-prompt">&gt;&gt;&gt; </span>x
<span class="py-output">array([(1, 0), (0, 1)],</span>
<span class="py-output">      dtype=[('x', '&lt;i4'), ('y', '&lt;i4')])</span></pre>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.argsort(x, order=(<span class="py-string">'x'</span>,<span class="py-string">'y'</span>))
<span class="py-output">array([1, 0])</span></pre>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.argsort(x, order=(<span class="py-string">'y'</span>,<span class="py-string">'x'</span>))
<span class="py-output">array([0, 1])</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="argwhere"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">argwhere</span>(<span class="sig-arg">a</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Find the indices of array elements that are non-zero, grouped by element.

Parameters
----------
a : array_like
    Input data.

Returns
-------
index_array : ndarray
    Indices of elements that are non-zero. Indices are grouped by element.

See Also
--------
where, nonzero

Notes
-----
``np.argwhere(a)`` is the same as ``np.transpose(np.nonzero(a))``.

The output of ``argwhere`` is not suitable for indexing arrays.
For this purpose use ``where(a)`` instead.

Examples
--------
&gt;&gt;&gt; x = np.arange(6).reshape(2,3)
&gt;&gt;&gt; x
array([[0, 1, 2],
       [3, 4, 5]])
&gt;&gt;&gt; np.argwhere(x&gt;1)
array([[0, 2],
       [1, 0],
       [1, 1],
       [1, 2]])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="around"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">around</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">decimals</span>=<span class="sig-default">0</span>,
        <span class="sig-arg">out</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Evenly round to the given number of decimals.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Input data.</dd>
<dt>decimals <span class="classifier-delimiter">:</span> <span class="rst-classifier">int, optional</span></dt>
<dd>Number of decimal places to round to (default: 0).  If
decimals is negative, it specifies the number of positions to
the left of the decimal point.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray, optional</span></dt>
<dd>Alternative output array in which to place the result. It must have
the same shape as the expected output, but the type of the output
values will be cast if necessary.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>rounded_array <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray</span></dt>
<dd><p class="rst-first">An array of the same type as <code class="link">a</code>, containing the rounded values.
Unless <code class="link">out</code> was specified, a new array is created.  A reference to
the result is returned.</p>
<p class="rst-last">The real and imaginary parts of complex numbers are rounded
separately.  The result of rounding a float is a float.</p>
</dd>
</dl>
</div>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<p>ndarray.round : equivalent method</p>
</div>
<div class="rst-section" id="rst-notes">
<h1 class="heading">Notes</h1>
<p>For values exactly halfway between rounded decimal values, Numpy
rounds to the nearest even value. Thus 1.5 and 2.5 round to 2.0,
-0.5 and 0.5 round to 0.0, etc. Results may also be surprising due
to the inexact representation of decimal fractions in the IEEE
floating point standard <a class="rst-footnote-reference" href="#rst-id2" id="rst-id1">[1]</a> and errors introduced when scaling
by powers of ten.</p>
</div>
<div class="rst-section" id="rst-references">
<h1 class="heading">References</h1>
<table class="rst-docutils footnote" frame="void" id="rst-id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="rst-label"><a class="fn-backref" href="#id1">[1]</a></td><td>&quot;Lecture Notes on the Status of  IEEE 754&quot;, William Kahan,
<a class="rst-reference external" href="http://www.cs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF" target="_top">http://www.cs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF</a></td></tr>
</tbody>
</table>
<table class="rst-docutils footnote" frame="void" id="rst-id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="rst-label">[2]</td><td>&quot;How Futile are Mindless Assessments of
Roundoff in Floating-Point Computation?&quot;, William Kahan,
<a class="rst-reference external" href="http://www.cs.berkeley.edu/~wkahan/Mindless.pdf" target="_top">http://www.cs.berkeley.edu/~wkahan/Mindless.pdf</a></td></tr>
</tbody>
</table>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.around([.5, 1.5, 2.5, 3.5, 4.5])
<span class="py-output">array([ 0.,  2.,  2.,  4.,  4.])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.around([1,2,3,11], decimals=1)
<span class="py-output">array([ 1,  2,  3, 11])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.around([1,2,3,11], decimals=-1)
<span class="py-output">array([ 0,  0,  0, 10])</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="array"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">array</span>(<span class="sig-arg">object</span>,
        <span class="sig-arg">dtype</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">copy</span>=<span class="sig-default">True</span>,
        <span class="sig-arg">order</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">subok</span>=<span class="sig-default">False</span>,
        <span class="sig-arg">ndmin</span>=<span class="sig-default">True</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">
Create an array.

Parameters
----------
object : array_like
    An array, any object exposing the array interface, an
    object whose __array__ method returns an array, or any
    (nested) sequence.
dtype : data-type, optional
    The desired data-type for the array.  If not given, then
    the type will be determined as the minimum type required
    to hold the objects in the sequence.  This argument can only
    be used to 'upcast' the array.  For downcasting, use the
    .astype(t) method.
copy : bool, optional
    If true (default), then the object is copied.  Otherwise, a copy
    will only be made if __array__ returns a copy, if obj is a
    nested sequence, or if a copy is needed to satisfy any of the other
    requirements (`dtype`, `order`, etc.).
order : {'C', 'F', 'A'}, optional
    Specify the order of the array.  If order is 'C' (default), then the
    array will be in C-contiguous order (last-index varies the
    fastest).  If order is 'F', then the returned array
    will be in Fortran-contiguous order (first-index varies the
    fastest).  If order is 'A', then the returned array may
    be in any order (either C-, Fortran-contiguous, or even
    discontiguous).
subok : bool, optional
    If True, then sub-classes will be passed-through, otherwise
    the returned array will be forced to be a base-class array (default).
ndmin : int, optional
    Specifies the minimum number of dimensions that the resulting
    array should have.  Ones will be pre-pended to the shape as
    needed to meet this requirement.

Examples
--------
&gt;&gt;&gt; np.array([1, 2, 3])
array([1, 2, 3])

Upcasting:

&gt;&gt;&gt; np.array([1, 2, 3.0])
array([ 1.,  2.,  3.])

More than one dimension:

&gt;&gt;&gt; np.array([[1, 2], [3, 4]])
array([[1, 2],
       [3, 4]])

Minimum dimensions 2:

&gt;&gt;&gt; np.array([1, 2, 3], ndmin=2)
array([[1, 2, 3]])

Type provided:

&gt;&gt;&gt; np.array([1, 2, 3], dtype=complex)
array([ 1.+0.j,  2.+0.j,  3.+0.j])

Data-type consisting of more than one element:

&gt;&gt;&gt; x = np.array([(1,2),(3,4)],dtype=[('a','&lt;i4'),('b','&lt;i4')])
&gt;&gt;&gt; x['a']
array([1, 3])

Creating an array from sub-classes:

&gt;&gt;&gt; np.array(np.mat('1 2; 3 4'))
array([[1, 2],
       [3, 4]])

&gt;&gt;&gt; np.array(np.mat('1 2; 3 4'), subok=True)
matrix([[1, 2],
        [3, 4]])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="array2string"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">array2string</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">max_line_width</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">precision</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">suppress_small</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">separator</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string"> </code><code class="variable-quote">'</code></span>,
        <span class="sig-arg">prefix</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string"></code><code class="variable-quote">'</code></span>,
        <span class="sig-arg">style</span>=<span class="sig-default">&lt;built-in function repr&gt;</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return a string representation of an array.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray</span></dt>
<dd>Input array.</dd>
<dt>max_line_width <span class="classifier-delimiter">:</span> <span class="rst-classifier">int, optional</span></dt>
<dd>The maximum number of columns the string should span. Newline
characters splits the string appropriately after array elements.</dd>
<dt>precision <span class="classifier-delimiter">:</span> <span class="rst-classifier">int, optional</span></dt>
<dd>Floating point precision. Default is the current printing
precision (usually 8), which can be altered using <code class="link">set_printoptions</code>.</dd>
<dt>suppress_small <span class="classifier-delimiter">:</span> <span class="rst-classifier">bool, optional</span></dt>
<dd>Represent very small numbers as zero. A number is &quot;very small&quot; if it
is smaller than the current printing precision.</dd>
<dt>separator <span class="classifier-delimiter">:</span> <span class="rst-classifier">string, optional</span></dt>
<dd>Inserted between elements.</dd>
<dt>prefix <span class="classifier-delimiter">:</span> <span class="rst-classifier">string, optional</span></dt>
<dd><p class="rst-first">An array is typically printed as:</p>
<pre class="rst-literal-block">
'prefix(' + array2string(a) + ')'
</pre>
<p class="rst-last">The length of the prefix string is used to align the
output correctly.</p>
</dd>
<dt>style <span class="classifier-delimiter">:</span> <span class="rst-classifier">function, optional</span></dt>
<dd>A function that accepts an ndarray and returns a string.  Used only
when the shape of <code class="link">a</code> is equal to ().</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>array_str <span class="classifier-delimiter">:</span> <span class="rst-classifier">str</span></dt>
<dd>String representation of the array.</dd>
</dl>
</div>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<p>array_str, array_repr, set_printoptions</p>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>x = np.array([1e-16,1,2,3])
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> np.array2string(x, precision=2, separator=<span class="py-string">','</span>,
<span class="py-more">... </span>                      suppress_small=True)
<span class="py-output">[ 0., 1., 2., 3.]</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="array_equal"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">array_equal</span>(<span class="sig-arg">a1</span>,
        <span class="sig-arg">a2</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

True if two arrays have the same shape and elements, False otherwise.

Parameters
----------
a1, a2 : array_like
    Input arrays.

Returns
-------
b : bool
    Returns True if the arrays are equal.

See Also
--------
allclose: Returns True if two arrays are element-wise equal within a
          tolerance.
array_equiv: Returns True if input arrays are shape consistent and all
             elements equal.

Examples
--------
&gt;&gt;&gt; np.array_equal([1, 2], [1, 2])
True
&gt;&gt;&gt; np.array_equal(np.array([1, 2]), np.array([1, 2]))
True
&gt;&gt;&gt; np.array_equal([1, 2], [1, 2, 3])
False
&gt;&gt;&gt; np.array_equal([1, 2], [1, 4])
False

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="array_equiv"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">array_equiv</span>(<span class="sig-arg">a1</span>,
        <span class="sig-arg">a2</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Returns True if input arrays are shape consistent and all elements equal.

Shape consistent means they are either the same shape, or one input array
can be broadcasted to create the same shape as the other one.

Parameters
----------
a1, a2 : array_like
    Input arrays.

Returns
-------
out : bool
    True if equivalent, False otherwise.

Examples
--------
&gt;&gt;&gt; np.array_equiv([1, 2], [1, 2])
&gt;&gt;&gt; True
&gt;&gt;&gt; np.array_equiv([1, 2], [1, 3])
&gt;&gt;&gt; False

Showing the shape equivalence:

&gt;&gt;&gt; np.array_equiv([1, 2], [[1, 2], [1, 2]])
&gt;&gt;&gt; True
&gt;&gt;&gt; np.array_equiv([1, 2], [[1, 2, 1, 2], [1, 2, 1, 2]])
&gt;&gt;&gt; False

&gt;&gt;&gt; np.array_equiv([1, 2], [[1, 2], [1, 3]])
&gt;&gt;&gt; False

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="array_repr"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">array_repr</span>(<span class="sig-arg">arr</span>,
        <span class="sig-arg">max_line_width</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">precision</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">suppress_small</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return the string representation of an array.

Parameters
----------
arr : ndarray
  Input array.
max_line_width : int
  The maximum number of columns the string should span. Newline
  characters splits the string appropriately after array elements.
precision : int
  Floating point precision.
suppress_small : bool
  Represent very small numbers as zero.

Returns
-------
string : str
  The string representation of an array.


Examples
--------
&gt;&gt;&gt; np.array_repr(np.array([1,2]))
'array([1, 2])'
&gt;&gt;&gt; np.array_repr(np.ma.array([0.]))
'MaskedArray([ 0.])'
&gt;&gt;&gt; np.array_repr(np.array([], np.int32))
'array([], dtype=int32)'

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="array_split"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">array_split</span>(<span class="sig-arg">ary</span>,
        <span class="sig-arg">indices_or_sections</span>,
        <span class="sig-arg">axis</span>=<span class="sig-default">0</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Split an array into multiple sub-arrays of equal or near-equal size.

Please refer to the ``split`` documentation.  The only difference
between these functions is that ``array_split`` allows
`indices_or_sections` to be an integer that does *not* equally
divide the axis.

See Also
--------
split : Split array into multiple sub-arrays of equal size.

Examples
--------
&gt;&gt;&gt; x = np.arange(8.0)
&gt;&gt;&gt; np.array_split(x, 3)
    [array([ 0.,  1.,  2.]), array([ 3.,  4.,  5.]), array([ 6.,  7.])]

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="array_str"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">array_str</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">max_line_width</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">precision</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">suppress_small</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return a string representation of an array.

Parameters
----------
a : ndarray
    Input array.
max_line_width : int, optional
    Inserts newlines if text is longer than `max_line_width`.
precision : int, optional
    If `a` is float, `precision` sets floating point precision.
suppress_small : boolean, optional
    Represent very small numbers as zero.

See Also
--------
array2string, array_repr

Examples
--------
&gt;&gt;&gt; np.array_str(np.arange(3))
&gt;&gt;&gt; '[0 1 2]'

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="asanyarray"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">asanyarray</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">dtype</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">order</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Convert the input to a ndarray, but pass ndarray subclasses through.

Parameters
----------
a : array_like
    Input data, in any form that can be converted to an array.  This
    includes scalars, lists, lists of tuples, tuples, tuples of tuples,
    tuples of lists and ndarrays.
dtype : data-type, optional
    By default, the data-type is inferred from the input data.
order : {'C', 'F'}, optional
    Whether to use row-major ('C') or column-major ('F') memory
    representation.  Defaults to 'C'.

Returns
-------
out : ndarray or an ndarray subclass
    Array interpretation of `a`.  If `a` is an ndarray or a subclass
    of ndarray, it is returned as-is and no copy is performed.

See Also
--------
asarray : Similar function which always returns ndarrays.
ascontiguousarray : Convert input to a contiguous array.
asfarray : Convert input to a floating point ndarray.
asfortranarray : Convert input to an ndarray with column-major
                 memory order.
asarray_chkfinite : Similar function which checks input for NaNs and Infs.
fromiter : Create an array from an iterator.
fromfunction : Construct an array by executing a function on grid
               positions.

Examples
--------
Convert a list into an array:

&gt;&gt;&gt; a = [1, 2]
&gt;&gt;&gt; np.asanyarray(a)
array([1, 2])

Instances of `ndarray` subclasses are passed through as-is:

&gt;&gt;&gt; a = np.matrix([1, 2])
&gt;&gt;&gt; np.asanyarray(a) is a
True

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="asarray"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">asarray</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">dtype</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">order</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Convert the input to an array.

Parameters
----------
a : array_like
    Input data, in any form that can be converted to an array.  This
    includes lists, lists of tuples, tuples, tuples of tuples, tuples
    of lists and ndarrays.
dtype : data-type, optional
    By default, the data-type is inferred from the input data.
order : {'C', 'F'}, optional
    Whether to use row-major ('C') or column-major ('FORTRAN') memory
    representation.  Defaults to 'C'.

Returns
-------
out : ndarray
    Array interpretation of `a`.  No copy is performed if the input
    is already an ndarray.  If `a` is a subclass of ndarray, a base
    class ndarray is returned.

See Also
--------
asanyarray : Similar function which passes through subclasses.
ascontiguousarray : Convert input to a contiguous array.
asfarray : Convert input to a floating point ndarray.
asfortranarray : Convert input to an ndarray with column-major
                 memory order.
asarray_chkfinite : Similar function which checks input for NaNs and Infs.
fromiter : Create an array from an iterator.
fromfunction : Construct an array by executing a function on grid
               positions.

Examples
--------
Convert a list into an array:

&gt;&gt;&gt; a = [1, 2]
&gt;&gt;&gt; np.asarray(a)
array([1, 2])

Existing arrays are not copied:

&gt;&gt;&gt; a = np.array([1, 2])
&gt;&gt;&gt; np.asarray(a) is a
True

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="asarray_chkfinite"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">asarray_chkfinite</span>(<span class="sig-arg">a</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Convert the input to an array, checking for NaNs or Infs.

Parameters
----------
a : array_like
    Input data, in any form that can be converted to an array.  This
    includes lists, lists of tuples, tuples, tuples of tuples, tuples
    of lists and ndarrays.  Success requires no NaNs or Infs.
dtype : data-type, optional
    By default, the data-type is inferred from the input data.
order : {'C', 'F'}, optional
    Whether to use row-major ('C') or column-major ('FORTRAN') memory
    representation.  Defaults to 'C'.

Returns
-------
out : ndarray
    Array interpretation of `a`.  No copy is performed if the input
    is already an ndarray.  If `a` is a subclass of ndarray, a base
    class ndarray is returned.

Raises
------
ValueError
    Raises ValueError if `a` contains NaN (Not a Number) or Inf (Infinity).

See Also
--------
asarray : Create and array.
asanyarray : Similar function which passes through subclasses.
ascontiguousarray : Convert input to a contiguous array.
asfarray : Convert input to a floating point ndarray.
asfortranarray : Convert input to an ndarray with column-major
                 memory order.
fromiter : Create an array from an iterator.
fromfunction : Construct an array by executing a function on grid
               positions.

Examples
--------
Convert a list into an array.  If all elements are finite
``asarray_chkfinite`` is identical to ``asarray``.

&gt;&gt;&gt; a = [1, 2]
&gt;&gt;&gt; np.asarray_chkfinite(a)
array([1, 2])

Raises ValueError if array_like contains Nans or Infs.

&gt;&gt;&gt; a = [1, 2, np.inf]
&gt;&gt;&gt; try:
...     np.asarray_chkfinite(a)
... except ValueError:
...     print 'ValueError'
...
ValueError

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="ascontiguousarray"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">ascontiguousarray</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">dtype</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return a contiguous array in memory (C order).

Parameters
----------
a : array_like
    Input array.
dtype : str or dtype object, optional
    Data-type of returned array.

Returns
-------
out : ndarray
    Contiguous array of same shape and content as `a`, with type `dtype`
    if specified.

See Also
--------
asfortranarray : Convert input to an ndarray with column-major
                 memory order.
require : Return an ndarray that satisfies requirements.
ndarray.flags : Information about the memory layout of the array.

Examples
--------
&gt;&gt;&gt; x = np.arange(6).reshape(2,3)
&gt;&gt;&gt; np.ascontiguousarray(x, dtype=np.float32)
array([[ 0.,  1.,  2.],
       [ 3.,  4.,  5.]], dtype=float32)
&gt;&gt;&gt; x.flags['C_CONTIGUOUS']
True

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="asfarray"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">asfarray</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">dtype</span>=<span class="sig-default">&lt;type 'numpy.float64'&gt;</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return an array converted to a float type.

Parameters
----------
a : array_like
    The input array.
dtype : str or dtype object, optional
    Float type code to coerce input array `a`.  If `dtype` is one of the
    'int' dtypes, it is replaced with float64.

Returns
-------
out : ndarray
    The input `a` as a float ndarray.

Examples
--------
&gt;&gt;&gt; np.asfarray([2, 3])
array([ 2.,  3.])
&gt;&gt;&gt; np.asfarray([2, 3], dtype='float')
array([ 2.,  3.])
&gt;&gt;&gt; np.asfarray([2, 3], dtype='int8')
array([ 2.,  3.])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="asfortranarray"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">asfortranarray</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">dtype</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return an array laid out in Fortran order in memory.

Parameters
----------
a : array_like
    Input array.
dtype : str or dtype object, optional
    By default, the data-type is inferred from the input data.

Returns
-------
out : ndarray
    The input `a` in Fortran, or column-major, order.

See Also
--------
ascontiguousarray : Convert input to a contiguous (C order) array.
asanyarray : Convert input to an ndarray with either row or
    column-major memory order.
require : Return an ndarray that satisfies requirements.
ndarray.flags : Information about the memory layout of the array.

Examples
--------
&gt;&gt;&gt; x = np.arange(6).reshape(2,3)
&gt;&gt;&gt; y = np.asfortranarray(x)
&gt;&gt;&gt; x.flags['F_CONTIGUOUS']
False
&gt;&gt;&gt; y.flags['F_CONTIGUOUS']
True

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="asmatrix"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">asmatrix</span>(<span class="sig-arg">data</span>,
        <span class="sig-arg">dtype</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Interpret the input as a matrix.

Unlike `matrix`, `asmatrix` does not make a copy if the input is already
a matrix or an ndarray.  Equivalent to ``matrix(data, copy=False)``.

Parameters
----------
data : array_like
    Input data.

Returns
-------
mat : matrix
    `data` interpreted as a matrix.

Examples
--------
&gt;&gt;&gt; x = np.array([[1, 2], [3, 4]])

&gt;&gt;&gt; m = np.asmatrix(x)

&gt;&gt;&gt; x[0,0] = 5

&gt;&gt;&gt; m
matrix([[5, 2],
        [3, 4]])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="asscalar"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">asscalar</span>(<span class="sig-arg">a</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Convert an array of size 1 to its scalar equivalent.

Parameters
----------
a : ndarray
    Input array of size 1.

Returns
-------
out : scalar
    Scalar representation of `a`. The input data type is preserved.

Examples
--------
&gt;&gt;&gt; np.asscalar(np.array([24]))
24

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="atleast_1d"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">atleast_1d</span>(<span class="sig-arg">*arys</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Convert inputs to arrays with at least one dimension.

Scalar inputs are converted to 1-dimensional arrays, whilst
higher-dimensional inputs are preserved.

Parameters
----------
array1, array2, ... : array_like
    One or more input arrays.

Returns
-------
ret : ndarray
    An array, or sequence of arrays, each with ``a.ndim &gt;= 1``.
    Copies are made only if necessary.

See Also
--------
atleast_2d, atleast_3d

Examples
--------
&gt;&gt;&gt; np.atleast_1d(1.0)
array([ 1.])

&gt;&gt;&gt; x = np.arange(9.0).reshape(3,3)
&gt;&gt;&gt; np.atleast_1d(x)
array([[ 0.,  1.,  2.],
       [ 3.,  4.,  5.],
       [ 6.,  7.,  8.]])
&gt;&gt;&gt; np.atleast_1d(x) is x
True

&gt;&gt;&gt; np.atleast_1d(1, [3, 4])
[array([1]), array([3, 4])]

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="atleast_2d"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">atleast_2d</span>(<span class="sig-arg">*arys</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

View inputs as arrays with at least two dimensions.

Parameters
----------
array1, array2, ... : array_like
    One or more array-like sequences.  Non-array inputs are converted
    to arrays.  Arrays that already have two or more dimensions are
    preserved.

Returns
-------
res, res2, ... : ndarray
    An array, or tuple of arrays, each with ``a.ndim &gt;= 2``.
    Copies are avoided where possible, and views with two or more
    dimensions are returned.

See Also
--------
atleast_1d, atleast_3d

Examples
--------
&gt;&gt;&gt; np.atleast_2d(3.0)
array([[ 3.]])

&gt;&gt;&gt; x = np.arange(3.0)
&gt;&gt;&gt; np.atleast_2d(x)
array([[ 0.,  1.,  2.]])
&gt;&gt;&gt; np.atleast_2d(x).base is x
True

&gt;&gt;&gt; np.atleast_2d(1, [1, 2], [[1, 2]])
[array([[1]]), array([[1, 2]]), array([[1, 2]])]

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="atleast_3d"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">atleast_3d</span>(<span class="sig-arg">*arys</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

View inputs as arrays with at least three dimensions.

Parameters
----------
array1, array2, ... : array_like
    One or more array-like sequences.  Non-array inputs are converted
    to arrays. Arrays that already have three or more dimensions are
    preserved.

Returns
-------
res1, res2, ... : ndarray
    An array, or tuple of arrays, each with ``a.ndim &gt;= 3``.
    Copies are avoided where possible, and views with three or more
    dimensions are returned.  For example, a 1-D array of shape ``N``
    becomes a view of shape ``(1, N, 1)``.  A 2-D array of shape ``(M, N)``
    becomes a view of shape ``(M, N, 1)``.

See Also
--------
atleast_1d, atleast_2d

Examples
--------
&gt;&gt;&gt; np.atleast_3d(3.0)
array([[[ 3.]]])

&gt;&gt;&gt; x = np.arange(3.0)
&gt;&gt;&gt; np.atleast_3d(x).shape
(1, 3, 1)

&gt;&gt;&gt; x = np.arange(12.0).reshape(4,3)
&gt;&gt;&gt; np.atleast_3d(x).shape
(4, 3, 1)
&gt;&gt;&gt; np.atleast_3d(x).base is x
True

&gt;&gt;&gt; for arr in np.atleast_3d([1, 2], [[1, 2]], [[[1, 2]]]):
...     print arr, arr.shape
...
[[[1]
  [2]]] (1, 2, 1)
[[[1]
  [2]]] (1, 2, 1)
[[[1 2]]] (1, 1, 2)

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="average"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">average</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">axis</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">weights</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">returned</span>=<span class="sig-default">False</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return the weighted average of array over the specified axis.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Data to be averaged.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="rst-classifier">int, optional</span></dt>
<dd>Axis along which to average <code class="link">a</code>. If <code class="link">None</code>, averaging is done over the
entire array irrespective of its shape.</dd>
<dt>weights <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like, optional</span></dt>
<dd>The importance that each datum has in the computation of the average.
The weights array can either be 1-D (in which case its length must be
the size of <code class="link">a</code> along the given axis) or of the same shape as <code class="link">a</code>.
If <code class="link">weights=None</code>, then all data in <code class="link">a</code> are assumed to have a
weight equal to one.</dd>
<dt>returned <span class="classifier-delimiter">:</span> <span class="rst-classifier">bool, optional</span></dt>
<dd>Default is <code class="link">False</code>. If <code class="link">True</code>, the tuple (<code class="link">average</code>, <code class="link">sum_of_weights</code>)
is returned, otherwise only the average is returned.  Note that
if <code class="link">weights=None</code>, <code class="link">sum_of_weights</code> is equivalent to the number of
elements over which the average is taken.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>average, [sum_of_weights] <span class="classifier-delimiter">:</span> <span class="rst-classifier">{array_type, double}</span></dt>
<dd>Return the average along the specified axis. When returned is <code class="link">True</code>,
return a tuple with the average as the first element and the sum
of the weights as the second element. The return type is <code class="link">Float</code>
if <code class="link">a</code> is of integer type, otherwise it is of the same type as <code class="link">a</code>.
<code class="link">sum_of_weights</code> is of the same type as <code class="link">average</code>.</dd>
</dl>
</div>
<div class="rst-section" id="rst-raises">
<h1 class="heading">Raises</h1>
<dl class="rst-docutils">
<dt>ZeroDivisionError</dt>
<dd>When all weights along axis are zero. See <code class="link">numpy.ma.average</code> for a
version robust to this type of error.</dd>
<dt>TypeError</dt>
<dd>When the length of 1D <code class="link">weights</code> is not the same as the shape of <code class="link">a</code>
along axis.</dd>
</dl>
</div>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<p>ma.average : average for masked arrays</p>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>data = range(1,5)
<span class="py-prompt">&gt;&gt;&gt; </span>data
<span class="py-output">[1, 2, 3, 4]</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.average(data)
<span class="py-output">2.5</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.average(range(1,11), weights=range(10,0,-1))
<span class="py-output">4.0</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="bartlett"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">bartlett</span>(<span class="sig-arg">M</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return the Bartlett window.

The Bartlett window is very similar to a triangular window, except
that the end points are at zero.  It is often used in signal
processing for tapering a signal, without generating too much
ripple in the frequency domain.

Parameters
----------
M : int
    Number of points in the output window. If zero or less, an
    empty array is returned.

Returns
-------
out : array
    The triangular window, normalized to one (the value one
    appears only if the number of samples is odd), with the first
    and last samples equal to zero.

See Also
--------
blackman, hamming, hanning, kaiser

Notes
-----
The Bartlett window is defined as

.. math:: w(n) = \frac{2}{M-1} \left(
          \frac{M-1}{2} - \left|n - \frac{M-1}{2}\right|
          \right)

Most references to the Bartlett window come from the signal
processing literature, where it is used as one of many windowing
functions for smoothing values.  Note that convolution with this
window produces linear interpolation.  It is also known as an
apodization (which means&quot;removing the foot&quot;, i.e. smoothing
discontinuities at the beginning and end of the sampled signal) or
tapering function. The fourier transform of the Bartlett is the product
of two sinc functions.
Note the excellent discussion in Kanasewich.

References
----------
.. [1] M.S. Bartlett, &quot;Periodogram Analysis and Continuous Spectra&quot;,
       Biometrika 37, 1-16, 1950.
.. [2] E.R. Kanasewich, &quot;Time Sequence Analysis in Geophysics&quot;,
       The University of Alberta Press, 1975, pp. 109-110.
.. [3] A.V. Oppenheim and R.W. Schafer, &quot;Discrete-Time Signal
       Processing&quot;, Prentice-Hall, 1999, pp. 468-471.
.. [4] Wikipedia, &quot;Window function&quot;,
       http://en.wikipedia.org/wiki/Window_function
.. [5] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,
       &quot;Numerical Recipes&quot;, Cambridge University Press, 1986, page 429.


Examples
--------
&gt;&gt;&gt; np.bartlett(12)
array([ 0.        ,  0.18181818,  0.36363636,  0.54545455,  0.72727273,
        0.90909091,  0.90909091,  0.72727273,  0.54545455,  0.36363636,
        0.18181818,  0.        ])

Plot the window and its frequency response (requires SciPy and matplotlib):

&gt;&gt;&gt; from numpy import clip, log10, array, bartlett
&gt;&gt;&gt; from numpy.fft import fft
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; window = bartlett(51)
&gt;&gt;&gt; plt.plot(window)
&gt;&gt;&gt; plt.title(&quot;Bartlett window&quot;)
&gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;)
&gt;&gt;&gt; plt.xlabel(&quot;Sample&quot;)
&gt;&gt;&gt; plt.show()

&gt;&gt;&gt; A = fft(window, 2048) / 25.5
&gt;&gt;&gt; mag = abs(fftshift(A))
&gt;&gt;&gt; freq = linspace(-0.5,0.5,len(A))
&gt;&gt;&gt; response = 20*log10(mag)
&gt;&gt;&gt; response = clip(response,-100,100)
&gt;&gt;&gt; plt.plot(freq, response)
&gt;&gt;&gt; plt.title(&quot;Frequency response of Bartlett window&quot;)
&gt;&gt;&gt; plt.ylabel(&quot;Magnitude [dB]&quot;)
&gt;&gt;&gt; plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;)
&gt;&gt;&gt; plt.axis('tight'); plt.show()

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="base_repr"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">base_repr</span>(<span class="sig-arg">number</span>,
        <span class="sig-arg">base</span>=<span class="sig-default">2</span>,
        <span class="sig-arg">padding</span>=<span class="sig-default">0</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return a string representation of a number in the given base system.

Parameters
----------
number : scalar
    The value to convert. Only positive values are handled.
base : int
    Convert `number` to the `base` number system. The valid range is 2-36,
    the default value is 2.
padding : int, optional
    Number of zeros padded on the left.

Returns
-------
out : str
    String representation of `number` in `base` system.

See Also
--------
binary_repr : Faster version of `base_repr` for base 2 that also handles
    negative numbers.

Examples
--------
&gt;&gt;&gt; np.base_repr(3, 5)
'3'
&gt;&gt;&gt; np.base_repr(6, 5)
'11'
&gt;&gt;&gt; np.base_repr(7, base=5, padding=3)
'00012'

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="binary_repr"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">binary_repr</span>(<span class="sig-arg">num</span>,
        <span class="sig-arg">width</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return the binary representation of the input number as a string.

For negative numbers, if width is not given, a minus sign is added to the
front. If width is given, the two's complement of the number is
returned, with respect to that width.

In a two's-complement system negative numbers are represented by the two's
complement of the absolute value. This is the most common method of
representing signed integers on computers [1]_. A N-bit two's-complement
system can represent every integer in the range
:math:`-2^{N-1}` to :math:`+2^{N-1}-1`.

Parameters
----------
num : int
    Only an integer decimal number can be used.
width : int, optional
    The length of the returned string if `num` is positive, the length of
    the two's complement if `num` is negative.

Returns
-------
bin : str
    Binary representation of `num` or two's complement of `num`.

See Also
--------
base_repr: Return a string representation of a number in the given base
           system.

Notes
-----
`binary_repr` is equivalent to using `base_repr` with base 2, but about 25x
faster.

References
----------
.. [1] Wikipedia, &quot;Two's complement&quot;,
    http://en.wikipedia.org/wiki/Two's_complement

Examples
--------
&gt;&gt;&gt; np.binary_repr(3)
'11'
&gt;&gt;&gt; np.binary_repr(-3)
'-11'
&gt;&gt;&gt; np.binary_repr(3, width=4)
'0011'

The two's complement is returned when the input number is negative and
width is specified:

&gt;&gt;&gt; np.binary_repr(-3, width=4)
'1101'

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="bincount"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">bincount</span>(<span class="sig-arg">x</span>,
        <span class="sig-arg">weights</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">
Return the number of occurrences of each value in array of nonnegative
integers.

The output, b[i], represents the number of times that i is found in `x`.
If `weights` is specified, every occurrence of i at a position p
contributes `weights` [p] instead of 1.

Parameters
----------
x : array_like, 1 dimension, nonnegative integers
    Input array.
weights : array_like, same shape as `x`, optional
    Weights.

See Also
--------
histogram, digitize, unique

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="blackman"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">blackman</span>(<span class="sig-arg">M</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return the Blackman window.

The Blackman window is a taper formed by using the the first
three terms of a summation of cosines. It was designed to have close
to the minimal leakage possible.
It is close to optimal, only slightly worse than a Kaiser window.

Parameters
----------
M : int
    Number of points in the output window. If zero or less, an
    empty array is returned.

Returns
-------
out : array
    The window, normalized to one (the value one
    appears only if the number of samples is odd).

See Also
--------
bartlett, hamming, hanning, kaiser

Notes
-----
The Blackman window is defined as

.. math::  w(n) = 0.42 - 0.5 \cos(2\pi n/M) + 0.08 \cos(4\pi n/M)


Most references to the Blackman window come from the signal processing
literature, where it is used as one of many windowing functions for
smoothing values.  It is also known as an apodization (which means
&quot;removing the foot&quot;, i.e. smoothing discontinuities at the beginning
and end of the sampled signal) or tapering function. It is known as a
&quot;near optimal&quot; tapering function, almost as good (by some measures)
as the kaiser window.

References
----------
.. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power
       spectra, Dover Publications, New York.
.. [2] Wikipedia, &quot;Window function&quot;,
       http://en.wikipedia.org/wiki/Window_function
.. [3] Oppenheim, A.V., and R.W. Schafer. Discrete-Time Signal Processing.
       Upper Saddle River, NJ: Prentice-Hall, 1999, pp. 468-471.

Examples
--------
&gt;&gt;&gt; from numpy import blackman
&gt;&gt;&gt; blackman(12)
array([ -1.38777878e-17,   3.26064346e-02,   1.59903635e-01,
         4.14397981e-01,   7.36045180e-01,   9.67046769e-01,
         9.67046769e-01,   7.36045180e-01,   4.14397981e-01,
         1.59903635e-01,   3.26064346e-02,  -1.38777878e-17])


Plot the window and the frequency response:

&gt;&gt;&gt; from numpy import clip, log10, array, bartlett
&gt;&gt;&gt; from scipy.fftpack import fft, fftshift
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; window = blackman(51)
&gt;&gt;&gt; plt.plot(window)
&gt;&gt;&gt; plt.title(&quot;Blackman window&quot;)
&gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;)
&gt;&gt;&gt; plt.xlabel(&quot;Sample&quot;)
&gt;&gt;&gt; plt.show()

&gt;&gt;&gt; A = fft(window, 2048) / 25.5
&gt;&gt;&gt; mag = abs(fftshift(A))
&gt;&gt;&gt; freq = linspace(-0.5,0.5,len(A))
&gt;&gt;&gt; response = 20*log10(mag)
&gt;&gt;&gt; response = clip(response,-100,100)
&gt;&gt;&gt; plt.plot(freq, response)
&gt;&gt;&gt; plt.title(&quot;Frequency response of Bartlett window&quot;)
&gt;&gt;&gt; plt.ylabel(&quot;Magnitude [dB]&quot;)
&gt;&gt;&gt; plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;)
&gt;&gt;&gt; plt.axis('tight'); plt.show()

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="bmat"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">bmat</span>(<span class="sig-arg">obj</span>,
        <span class="sig-arg">ldict</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">gdict</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Build a matrix object from a string, nested sequence, or array.

Parameters
----------
obj : string, sequence or array
    Input data.  Variables names in the current scope may
    be referenced, even if `obj` is a string.

Returns
-------
out : matrix
    Returns a matrix object, which is a specialized 2-D array.

See Also
--------
matrix

Examples
--------
&gt;&gt;&gt; A = np.mat('1 1; 1 1')
&gt;&gt;&gt; B = np.mat('2 2; 2 2')
&gt;&gt;&gt; C = np.mat('3 4; 5 6')
&gt;&gt;&gt; D = np.mat('7 8; 9 0')

All the following expressions construct the same block matrix:

&gt;&gt;&gt; np.bmat([[A, B], [C, D]])
matrix([[1, 1, 2, 2],
        [1, 1, 2, 2],
        [3, 4, 7, 8],
        [5, 6, 9, 0]])
&gt;&gt;&gt; np.bmat(np.r_[np.c_[A, B], np.c_[C, D]])
matrix([[1, 1, 2, 2],
        [1, 1, 2, 2],
        [3, 4, 7, 8],
        [5, 6, 9, 0]])
&gt;&gt;&gt; np.bmat('A,B; C,D')
matrix([[1, 1, 2, 2],
        [1, 1, 2, 2],
        [3, 4, 7, 8],
        [5, 6, 9, 0]])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="broadcast_arrays"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">broadcast_arrays</span>(<span class="sig-arg">*args</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Broadcast any number of arrays against each other.

Parameters
----------
`*args` : arrays
    The arrays to broadcast.

Returns
-------
broadcasted : list of arrays
    These arrays are views on the original arrays. They are typically not
    contiguous. Furthermore, more than one element of a broadcasted array
    may refer to a single memory location. If you need to write to the
    arrays, make copies first.

Examples
--------
&gt;&gt;&gt; x = np.array([[1,2,3]])
&gt;&gt;&gt; y = np.array([[1],[2],[3]])
&gt;&gt;&gt; np.broadcast_arrays(x, y)
[array([[1, 2, 3],
       [1, 2, 3],
       [1, 2, 3]]), array([[1, 1, 1],
       [2, 2, 2],
       [3, 3, 3]])]

Here is a useful idiom for getting contiguous copies instead of
non-contiguous views.

&gt;&gt;&gt; map(np.array, np.broadcast_arrays(x, y))
[array([[1, 2, 3],
       [1, 2, 3],
       [1, 2, 3]]), array([[1, 1, 1],
       [2, 2, 2],
       [3, 3, 3]])]

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="byte_bounds"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">byte_bounds</span>(<span class="sig-arg">a</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Returns pointers to the end-points of an array.

Parameters
----------
a : ndarray
    Input array. It must conform to the Python-side of the array interface.

Returns
-------
(low, high) : tuple of 2 integers
    The first integer is the first byte of the array, the second integer is
    just past the last byte of the array.  If `a` is not contiguous it
    would not use every byte between the (`low`, `high`) values.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="can_cast"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">can_cast</span>(<span class="sig-arg">from</span>=<span class="sig-default">d1</span>,
        <span class="sig-arg">to</span>=<span class="sig-default">d2</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">
Returns True if cast between data types can occur without losing precision.

Parameters
----------
from: data type code
    Data type code to cast from.
to: data type code
    Data type code to cast to.

Returns
-------
out : bool
    True if cast can occur without losing precision.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="choose"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">choose</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">choices</span>,
        <span class="sig-arg">out</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">mode</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string">raise</code><code class="variable-quote">'</code></span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Use an index array to construct a new array from a set of choices.</p>
<p>Given an array of integers and a set of n choice arrays, this function
will create a new array that merges each of the choice arrays.  Where a
value in <code class="link">a</code> is i, then the new array will have the value that
choices[i] contains in the same place.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="rst-classifier">int array</span></dt>
<dd>This array must contain integers in [0, n-1], where n is the number
of choices.</dd>
<dt>choices <span class="classifier-delimiter">:</span> <span class="rst-classifier">sequence of arrays</span></dt>
<dd>Choice arrays. The index array and all of the choices should be
broadcastable to the same shape.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="rst-classifier">array, optional</span></dt>
<dd>If provided, the result will be inserted into this array. It should
be of the appropriate shape and dtype</dd>
<dt>mode <span class="classifier-delimiter">:</span> <span class="rst-classifier">{'raise', 'wrap', 'clip'}, optional</span></dt>
<dd><p class="rst-first">Specifies how out-of-bounds indices will behave:</p>
<blockquote class="rst-last">
<ul class="rst-simple">
<li>'raise' : raise an error</li>
<li>'wrap' : wrap around</li>
<li>'clip' : clip to the range</li>
</ul>
</blockquote>
</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>merged_array <span class="classifier-delimiter">:</span> <span class="rst-classifier">array</span></dt>
<dd>The merged results.</dd>
</dl>
</div>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<p>ndarray.choose : equivalent method</p>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>choices = [[0, 1, 2, 3], [10, 11, 12, 13],
<span class="py-more">... </span>  [20, 21, 22, 23], [30, 31, 32, 33]]
<span class="py-prompt">&gt;&gt;&gt; </span>np.choose([2, 3, 1, 0], choices)
<span class="py-output">array([20, 31, 12,  3])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.choose([2, 4, 1, 0], choices, mode=<span class="py-string">'clip'</span>)
<span class="py-output">array([20, 31, 12,  3])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.choose([2, 4, 1, 0], choices, mode=<span class="py-string">'wrap'</span>)
<span class="py-output">array([20,  1, 12,  3])</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="clip"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">clip</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">a_min</span>,
        <span class="sig-arg">a_max</span>,
        <span class="sig-arg">out</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Clip (limit) the values in an array.</p>
<p>Given an interval, values outside the interval are clipped to
the interval edges.  For example, if an interval of <tt class="rst-docutils literal"><span class="pre">[0,</span> <span class="pre">1]</span></tt>
is specified, values smaller than 0 become 0, and values larger
than 1 become 1.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Array containing elements to clip.</dd>
<dt>a_min <span class="classifier-delimiter">:</span> <span class="rst-classifier">scalar or array_like</span></dt>
<dd>Minimum value.</dd>
<dt>a_max <span class="classifier-delimiter">:</span> <span class="rst-classifier">scalar or array_like</span></dt>
<dd>Maximum value.  If <code class="link">a_min</code> or <code class="link">a_max</code> are array_like, then they will
be broadcasted to the shape of <code class="link">a</code>.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray, optional</span></dt>
<dd>The results will be placed in this array. It may be the input
array for in-place clipping.  <code class="link">out</code> must be of the right shape
to hold the output.  Its type is preserved.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>clipped_array <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray</span></dt>
<dd>An array with the elements of <code class="link">a</code>, but where values
&lt; <code class="link">a_min</code> are replaced with <code class="link">a_min</code>, and those &gt; <code class="link">a_max</code>
with <code class="link">a_max</code>.</dd>
</dl>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>a = np.arange(10)
<span class="py-prompt">&gt;&gt;&gt; </span>np.clip(a, 1, 8)
<span class="py-output">array([1, 1, 2, 3, 4, 5, 6, 7, 8, 8])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>a
<span class="py-output">array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.clip(a, 3, 6, out=a)
<span class="py-output">array([3, 3, 3, 3, 4, 5, 6, 6, 6, 6])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>a
<span class="py-output">array([3, 3, 3, 3, 4, 5, 6, 6, 6, 6])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.clip(a, [3,4,1,1,1,4,4,4,4,4], 8)
<span class="py-output">array([3, 4, 2, 3, 4, 5, 6, 7, 8, 8])</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="column_stack"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">column_stack</span>(<span class="sig-arg">tup</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Stack 1-D arrays as columns into a 2-D array.

Take a sequence of 1-D arrays and stack them as columns
to make a single 2-D array. 2-D arrays are stacked as-is,
just like with `hstack`.  1-D arrays are turned into 2-D columns
first.

Parameters
----------
tup : sequence of 1-D or 2-D arrays.
    Arrays to stack. All of them must have the same first dimension.

Returns
-------
stacked : 2-D array
    The array formed by stacking the given arrays.

See Also
--------
hstack, vstack, concatenate

Notes
-----
This function is equivalent to ``np.vstack(tup).T``.

Examples
--------
&gt;&gt;&gt; a = np.array((1,2,3))
&gt;&gt;&gt; b = np.array((2,3,4))
&gt;&gt;&gt; np.column_stack((a,b))
array([[1, 2],
       [2, 3],
       [3, 4]])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="common_type"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">common_type</span>(<span class="sig-arg">*arrays</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return the inexact scalar type which is most common in a list of arrays.

The return type will always be an inexact scalar type, even if all the
arrays are integer arrays

Parameters
----------
array1, array2, ... : ndarray
    Input arrays.

Returns
-------
out : data type code
    Data type code.

See Also
--------
dtype

Examples
--------
&gt;&gt;&gt; np.common_type(np.arange(4), np.array([45,6]), np.array([45.0, 6.0]))
&lt;type 'numpy.float64'&gt;

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="compress"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">compress</span>(<span class="sig-arg">condition</span>,
        <span class="sig-arg">a</span>,
        <span class="sig-arg">axis</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">out</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return selected slices of an array along given axis.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>condition <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Boolean 1-D array selecting which entries to return. If len(condition)
is less than the size of <code class="link">a</code> along the given axis, then output is
truncated to the length of the condition array.</dd>
<dt>a <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Array from which to extract a part.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="rst-classifier">int, optional</span></dt>
<dd>Axis along which to take slices. If None (default), work on the
flattened array.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray, optional</span></dt>
<dd>Output array.  Its type is preserved and it must be of the right
shape to hold the output.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>compressed_array <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray</span></dt>
<dd>A copy of <code class="link">a</code> without the slices along axis for which <code class="link">condition</code>
is false.</dd>
</dl>
</div>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<p>ndarray.compress: Equivalent method.</p>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>a = np.array([[1, 2], [3, 4]])
<span class="py-prompt">&gt;&gt;&gt; </span>np.compress([0, 1], a, axis=0)
<span class="py-output">array([[3, 4]])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.compress([1], a, axis=1)
<span class="py-output">array([[1],</span>
<span class="py-output">       [3]])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.compress([0,1,1], a)
<span class="py-output">array([2, 3])</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="concatenate"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">concatenate</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">
concatenate((a1, a2, ...), axis=0)

Join a sequence of arrays together.

Parameters
----------
a1, a2, ... : sequence of ndarrays
    The arrays must have the same shape, except in the dimension
    corresponding to `axis` (the first, by default).
axis : int, optional
    The axis along which the arrays will be joined.  Default is 0.

Returns
-------
res : ndarray
    The concatenated array.

See Also
--------
array_split : Split an array into multiple sub-arrays of equal or
              near-equal size.
split : Split array into a list of multiple sub-arrays of equal size.
hsplit : Split array into multiple sub-arrays horizontally (column wise)
vsplit : Split array into multiple sub-arrays vertically (row wise)
dsplit : Split array into multiple sub-arrays along the 3rd axis (depth).
hstack : Stack arrays in sequence horizontally (column wise)
vstack : Stack arrays in sequence vertically (row wise)
dstack : Stack arrays in sequence depth wise (along third dimension)

Examples
--------
&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])
&gt;&gt;&gt; b = np.array([[5, 6]])
&gt;&gt;&gt; np.concatenate((a, b), axis=0)
array([[1, 2],
       [3, 4],
       [5, 6]])
&gt;&gt;&gt; np.concatenate((a, b.T), axis=1)
array([[1, 2, 5],
       [3, 4, 6]])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="convolve"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">convolve</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">v</span>,
        <span class="sig-arg">mode</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string">full</code><code class="variable-quote">'</code></span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Returns the discrete, linear convolution of two one-dimensional sequences.

The convolution operator is often seen in signal processing, where it
models the effect of a linear time-invariant system on a signal [1]_.  In
probability theory, the sum of two independent random variables is
distributed according to the convolution of their individual
distributions.

Parameters
----------
a : (N,) array_like
    First one-dimensional input array.
v : (M,) array_like
    Second one-dimensional input array.
mode : {'full', 'valid', 'same'}, optional
    'full':
      By default, mode is 'full'.  This returns the convolution
      at each point of overlap, with an output shape of (N+M-1,). At
      the end-points of the convolution, the signals do not overlap
      completely, and boundary effects may be seen.

    'same':
      Mode `same` returns output of length ``max(M, N)``.  Boundary
      effects are still visible.

    'valid':
      Mode `valid` returns output of length
      ``max(M, N) - min(M, N) + 1``.  The convolution product is only given
      for points where the signals overlap completely.  Values outside
      the signal boundary have no effect.

Returns
-------
out : ndarray
    Discrete, linear convolution of `a` and `v`.

See Also
--------
scipy.signal.fftconv : Convolve two arrays using the Fast Fourier
                       Transform.
scipy.linalg.toeplitz : Used to construct the convolution operator.

Notes
-----
The discrete convolution operation is defined as

.. math:: (f * g)[n] = \sum_{m = -\infty}^{\infty} f[m] f[n - m]

It can be shown that a convolution :math:`x(t) * y(t)` in time/space
is equivalent to the multiplication :math:`X(f) Y(f)` in the Fourier
domain, after appropriate padding (padding is necessary to prevent
circular convolution).  Since multiplication is more efficient (faster)
than convolution, the function `scipy.signal.fftconvolve` exploits the
FFT to calculate the convolution of large data-sets.

References
----------
.. [1] Wikipedia, &quot;Convolution&quot;, http://en.wikipedia.org/wiki/Convolution.

Examples
--------
Note how the convolution operator flips the second array
before &quot;sliding&quot; the two across one another:

&gt;&gt;&gt; np.convolve([1, 2, 3], [0, 1, 0.5])
array([ 0. ,  1. ,  2.5,  4. ,  1.5])

Only return the middle values of the convolution.
Contains boundary effects, where zeros are taken
into account:

&gt;&gt;&gt; np.convolve([1,2,3],[0,1,0.5], 'same')
array([ 1. ,  2.5,  4. ])

The two arrays are of the same length, so there
is only one position where they completely overlap:

&gt;&gt;&gt; np.convolve([1,2,3],[0,1,0.5], 'valid')
array([ 2.5])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="copy"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">copy</span>(<span class="sig-arg">a</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return an array copy of the given object.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Input data.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>arr <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray</span></dt>
<dd>Array interpretation of <code class="link">a</code>.</dd>
</dl>
</div>
<div class="rst-section" id="rst-notes">
<h1 class="heading">Notes</h1>
<p>This is equivalent to</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.array(a, <span class="py-builtin">copy</span>=True)</pre>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<p>Create an array x, with a reference y and a copy z:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>x = np.array([1, 2, 3])
<span class="py-prompt">&gt;&gt;&gt; </span>y = x
<span class="py-prompt">&gt;&gt;&gt; </span>z = np.copy(x)</pre>
<p>Note that, when we modify x, y changes, but not z:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>x[0] = 10
<span class="py-prompt">&gt;&gt;&gt; </span>x[0] == y[0]
<span class="py-output">True</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>x[0] == z[0]
<span class="py-output">False</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="corrcoef"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">corrcoef</span>(<span class="sig-arg">x</span>,
        <span class="sig-arg">y</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">rowvar</span>=<span class="sig-default">1</span>,
        <span class="sig-arg">bias</span>=<span class="sig-default">0</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return correlation coefficients.

Please refer to the documentation for `cov` for more detail.  The
relationship between the correlation coefficient matrix, P, and the
covariance matrix, C, is

.. math:: P_{ij} = \frac{ C_{ij} } { \sqrt{ C_{ii} * C_{jj} } }

The values of P are between -1 and 1.

See Also
--------
cov : Covariance matrix

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="correlate"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">correlate</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">v</span>,
        <span class="sig-arg">mode</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string">valid</code><code class="variable-quote">'</code></span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Discrete, linear correlation of two 1-dimensional sequences.

This function is equivalent to

&gt;&gt;&gt; np.convolve(a, v[::-1], mode=mode)

where ``v[::-1]`` is the reverse of `v`.

Parameters
----------
a, v : array_like
    Input sequences.
mode : {'valid', 'same', 'full'}, optional
    Refer to the `convolve` docstring.  Note that the default
    is `valid`, unlike `convolve`, which uses `full`.

See Also
--------
convolve : Discrete, linear convolution of two
           one-dimensional sequences.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="cov"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">cov</span>(<span class="sig-arg">m</span>,
        <span class="sig-arg">y</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">rowvar</span>=<span class="sig-default">1</span>,
        <span class="sig-arg">bias</span>=<span class="sig-default">0</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Estimate a covariance matrix, given data.

Covariance indicates the level to which two variables vary together.
If we examine N-dimensional samples, :math:`X = [x_1, x_2, ... x_N]^T`,
then the covariance matrix element :math:`C_{ij}` is the covariance of
:math:`x_i` and :math:`x_j`. The element :math:`C_{ii}` is the variance
of :math:`x_i`.

Parameters
----------
m : array_like
    A 1-D or 2-D array containing multiple variables and observations.
    Each row of `m` represents a variable, and each column a single
    observation of all those variables. Also see `rowvar` below.
y : array_like, optional
    An additional set of variables and observations. `y` has the same
    form as that of `m`.
rowvar : int, optional
    If `rowvar` is non-zero (default), then each row represents a
    variable, with observations in the columns. Otherwise, the relationship
    is transposed: each column represents a variable, while the rows
    contain observations.
bias : int, optional
    Default normalization is by ``(N-1)``, where ``N`` is the number of
    observations given (unbiased estimate). If `bias` is 1, then
    normalization is by ``N``.

Returns
-------
out : ndarray
    The covariance matrix of the variables.

See Also
--------
corrcoef : Normalized covariance matrix

Examples
--------
Consider two variables, :math:`x_0` and :math:`x_1`, which
correlate perfectly, but in opposite directions:

&gt;&gt;&gt; x = np.array([[0, 2], [1, 1], [2, 0]]).T
&gt;&gt;&gt; x
array([[0, 1, 2],
       [2, 1, 0]])

Note how :math:`x_0` increases while :math:`x_1` decreases. The covariance
matrix shows this clearly:

&gt;&gt;&gt; np.cov(x)
array([[ 1., -1.],
       [-1.,  1.]])

Note that element :math:`C_{0,1}`, which shows the correlation between
:math:`x_0` and :math:`x_1`, is negative.

Further, note how `x` and `y` are combined:

&gt;&gt;&gt; x = [-2.1, -1,  4.3]
&gt;&gt;&gt; y = [3,  1.1,  0.12]
&gt;&gt;&gt; X = np.vstack((x,y))
&gt;&gt;&gt; print np.cov(X)
[[ 11.71        -4.286     ]
 [ -4.286        2.14413333]]
&gt;&gt;&gt; print np.cov(x, y)
[[ 11.71        -4.286     ]
 [ -4.286        2.14413333]]
&gt;&gt;&gt; print np.cov(x)
11.71

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="cross"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">cross</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">b</span>,
        <span class="sig-arg">axisa</span>=<span class="sig-default">-1</span>,
        <span class="sig-arg">axisb</span>=<span class="sig-default">-1</span>,
        <span class="sig-arg">axisc</span>=<span class="sig-default">-1</span>,
        <span class="sig-arg">axis</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return the cross product of two (arrays of) vectors.

The cross product of `a` and `b` in :math:`R^3` is a vector perpendicular
to both `a` and `b`.  If `a` and `b` are arrays of vectors, the vectors
are defined by the last axis of `a` and `b` by default, and these axes
can have dimensions 2 or 3.  Where the dimension of either `a` or `b` is
2, the third component of the input vector is assumed to be zero and the
cross product calculated accordingly.  In cases where both input vectors
have dimension 2, the z-component of the cross product is returned.

Parameters
----------
a : array_like
    Components of the first vector(s).
b : array_like
    Components of the second vector(s).
axisa : int, optional
    Axis of `a` that defines the vector(s).  By default, the last axis.
axisb : int, optional
    Axis of `b` that defines the vector(s).  By default, the last axis.
axisc : int, optional
    Axis of `c` containing the cross product vector(s).  By default, the
    last axis.
axis : int, optional
    If defined, the axis of `a`, `b` and `c` that defines the vector(s)
    and cross product(s).  Overrides `axisa`, `axisb` and `axisc`.

Returns
-------
c : ndarray
    Vector cross product(s).

Raises
------
ValueError
    When the dimension of the vector(s) in `a` and/or `b` does not
    equal 2 or 3.

See Also
--------
inner : Inner product
outer : Outer product.
ix_ : Construct index arrays.

Examples
--------
Vector cross-product.

&gt;&gt;&gt; x = [1, 2, 3]
&gt;&gt;&gt; y = [4, 5, 6]
&gt;&gt;&gt; np.cross(x, y)
array([-3,  6, -3])

One vector with dimension 2.

&gt;&gt;&gt; x = [1, 2]
&gt;&gt;&gt; y = [4, 5, 6]
&gt;&gt;&gt; np.cross(x, y)
array([12, -6, -3])

Equivalently:

&gt;&gt;&gt; x = [1, 2, 0]
&gt;&gt;&gt; y = [4, 5, 6]
&gt;&gt;&gt; np.cross(x, y)
array([12, -6, -3])

Both vectors with dimension 2.

&gt;&gt;&gt; x = [1,2]
&gt;&gt;&gt; y = [4,5]
&gt;&gt;&gt; np.cross(x, y)
-3

Multiple vector cross-products. Note that the direction of the cross
product vector is defined by the `right-hand rule`.

&gt;&gt;&gt; x = np.array([[1,2,3], [4,5,6]])
&gt;&gt;&gt; y = np.array([[4,5,6], [1,2,3]])
&gt;&gt;&gt; np.cross(x, y)
array([[-3,  6, -3],
       [ 3, -6,  3]])

The orientation of `c` can be changed using the `axisc` keyword.

&gt;&gt;&gt; np.cross(x, y, axisc=0)
array([[-3,  3],
       [ 6, -6],
       [-3,  3]])

Change the vector definition of `x` and `y` using `axisa` and `axisb`.

&gt;&gt;&gt; x = np.array([[1,2,3], [4,5,6], [7, 8, 9]])
&gt;&gt;&gt; y = np.array([[7, 8, 9], [4,5,6], [1,2,3]])
&gt;&gt;&gt; np.cross(x, y)
array([[ -6,  12,  -6],
       [  0,   0,   0],
       [  6, -12,   6]])
&gt;&gt;&gt; np.cross(x, y, axisa=0, axisb=0)
array([[-24,  48, -24],
       [-30,  60, -30],
       [-36,  72, -36]])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="cumprod"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">cumprod</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">axis</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">dtype</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">out</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return the cumulative product of elements along a given axis.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Input array.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="rst-classifier">int, optional</span></dt>
<dd>Axis along which the cumulative product is computed.  By default the
input is flattened.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="rst-classifier">dtype, optional</span></dt>
<dd>Type of the returned array, as well as of the accumulator in which
the elements are multiplied.  If dtype is not specified, it defaults
to the dtype of <code class="link">a</code>, unless <code class="link">a</code> has an integer dtype with a precision
less than that of the default platform integer.  In that case, the
default platform integer is used instead.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray, optional</span></dt>
<dd>Alternative output array in which to place the result. It must
have the same shape and buffer length as the expected output
but the type of the resulting values will be cast if necessary.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>cumprod <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray</span></dt>
<dd>A new array holding the result is returned unless <code class="link">out</code> is
specified, in which case a reference to out is returned.</dd>
</dl>
</div>
<div class="rst-section" id="rst-notes">
<h1 class="heading">Notes</h1>
<p>Arithmetic is modular when using integer types, and no error is
raised on overflow.</p>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>a = np.array([1,2,3])
<span class="py-prompt">&gt;&gt;&gt; </span>np.cumprod(a) <span class="py-comment"># intermediate results 1, 1*2</span>
<span class="py-more">... </span>              <span class="py-comment"># total product 1*2*3 = 6</span>
<span class="py-output">array([1, 2, 6])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>a = np.array([[1, 2, 3], [4, 5, 6]])
<span class="py-prompt">&gt;&gt;&gt; </span>np.cumprod(a, dtype=float) <span class="py-comment"># specify type of output</span>
<span class="py-output">array([   1.,    2.,    6.,   24.,  120.,  720.])</span></pre>
<p>The cumulative product for each column (i.e., over the rows of)
<code class="link">a</code>:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.cumprod(a, axis=0)
<span class="py-output">array([[ 1,  2,  3],</span>
<span class="py-output">       [ 4, 10, 18]])</span></pre>
<p>The cumulative product for each row (i.e. over the columns of)
<code class="link">a</code>:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.cumprod(a,axis=1)
<span class="py-output">array([[  1,   2,   6],</span>
<span class="py-output">       [  4,  20, 120]])</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="cumproduct"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">cumproduct</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">axis</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">dtype</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">out</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return the cumulative product over the given axis.</p>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<p>cumprod : equivalent function; see for details.</p>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="cumsum"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">cumsum</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">axis</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">dtype</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">out</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return the cumulative sum of the elements along a given axis.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Input array or object that can be converted to an array.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="rst-classifier">int, optional</span></dt>
<dd>Axis along which the cumulative sum is computed. The default
(<code class="link">axis</code> = <code class="link">None</code>) is to compute the cumsum over the flattened
array. <code class="link">axis</code> may be negative, in which case it counts from the
last to the first axis.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="rst-classifier">dtype, optional</span></dt>
<dd>Type of the returned array and of the accumulator in which the
elements are summed.  If <code class="link">dtype</code> is not specified, it defaults
to the dtype of <code class="link">a</code>, unless <code class="link">a</code> has an integer dtype with a
precision less than that of the default platform integer.  In
that case, the default platform integer is used.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray, optional</span></dt>
<dd>Alternative output array in which to place the result. It must
have the same shape and buffer length as the expected output
but the type will be cast if necessary.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>cumsum <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray.</span></dt>
<dd>A new array holding the result is returned unless <code class="link">out</code> is
specified, in which case a reference to <code class="link">out</code> is returned.</dd>
</dl>
</div>
<div class="rst-section" id="rst-notes">
<h1 class="heading">Notes</h1>
<p>Arithmetic is modular when using integer types, and no error is
raised on overflow.</p>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>a = np.array([[1,2,3],[4,5,6]])
<span class="py-prompt">&gt;&gt;&gt; </span>np.cumsum(a)
<span class="py-output">array([ 1,  3,  6, 10, 15, 21])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.cumsum(a,dtype=float)     <span class="py-comment"># specifies type of output value(s)</span>
<span class="py-output">array([  1.,   3.,   6.,  10.,  15.,  21.])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.cumsum(a,axis=0)      <span class="py-comment"># sum over rows for each of the 3 columns</span>
<span class="py-output">array([[1, 2, 3],</span>
<span class="py-output">       [5, 7, 9]])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.cumsum(a,axis=1)      <span class="py-comment"># sum over columns for each of the 2 rows</span>
<span class="py-output">array([[ 1,  3,  6],</span>
<span class="py-output">       [ 4,  9, 15]])</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="delete"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">delete</span>(<span class="sig-arg">arr</span>,
        <span class="sig-arg">obj</span>,
        <span class="sig-arg">axis</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return a new array with sub-arrays along an axis deleted.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>arr <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Input array.</dd>
<dt>obj <span class="classifier-delimiter">:</span> <span class="rst-classifier">slice, int or array of ints</span></dt>
<dd>Indicate which sub-arrays to remove.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="rst-classifier">int, optional</span></dt>
<dd>The axis along which to delete the subarray defined by <code class="link">obj</code>.
If <code class="link">axis</code> is None, <code class="link">obj</code> is applied to the flattened array.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray</span></dt>
<dd>A copy of <code class="link">arr</code> with the elements specified by <code class="link">obj</code> removed. Note
that <code class="link">delete</code> does not occur in-place. If <code class="link">axis</code> is None, <code class="link">out</code> is
a flattened array.</dd>
</dl>
</div>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<p>insert : Insert elements into an array.
append : Append elements at the end of an array.</p>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>arr = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])
<span class="py-prompt">&gt;&gt;&gt; </span>arr
<span class="py-output">array([[ 1,  2,  3,  4],</span>
<span class="py-output">       [ 5,  6,  7,  8],</span>
<span class="py-output">       [ 9, 10, 11, 12]])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.delete(arr, 1, 0)
<span class="py-output">array([[ 1,  2,  3,  4],</span>
<span class="py-output">       [ 9, 10, 11, 12]])</span></pre>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.delete(arr, np.s_[::2], 1)
<span class="py-output">array([[ 2,  4],</span>
<span class="py-output">       [ 6,  8],</span>
<span class="py-output">       [10, 12]])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.delete(arr, [1,3,5], None)
<span class="py-output">array([ 1,  3,  5,  7,  8,  9, 10, 11, 12])</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="deprecate"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">deprecate</span>(<span class="sig-arg">func</span>,
        <span class="sig-arg">oldname</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">newname</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Deprecate old functions. Issues a DeprecationWarning, adds warning to 
  oldname's docstring, rebinds oldname.__name__ and returns new function 
  object.</p>
  <p>Example: oldfunc = deprecate(newfunc, 'oldfunc', 'newfunc')</p>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="deprecate_with_doc"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">deprecate_with_doc</span>(<span class="sig-arg">somestr</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">
Decorator to deprecate functions and provide detailed documentation
with 'somestr' that is added to the functions docstring.

Example:
depmsg = 'function scipy.foo has been merged into numpy.foobar'
@deprecate_with_doc(depmsg)
def foo():
    pass

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="diag"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">diag</span>(<span class="sig-arg">v</span>,
        <span class="sig-arg">k</span>=<span class="sig-default">0</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Extract a diagonal or construct a diagonal array.

Parameters
----------
v : array_like
    If `v` is a 2-D array, return a copy of its `k`-th diagonal.
    If `v` is a 1-D array, return a 2-D array with `v` on the `k`-th
    diagonal.
k : int, optional
    Diagonal in question. The default is 0.

Returns
-------
out : ndarray
    The extracted diagonal or constructed diagonal array.

See Also
--------
diagonal : Return specified diagonals.
diagflat : Create a 2-D array with the flattened input as a diagonal.
trace : Sum along diagonals.

Examples
--------
&gt;&gt;&gt; x = np.arange(9).reshape((3,3))
&gt;&gt;&gt; x
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])

&gt;&gt;&gt; np.diag(x)
array([0, 4, 8])

&gt;&gt;&gt; np.diag(np.diag(x))
array([[0, 0, 0],
       [0, 4, 0],
       [0, 0, 8]])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="diagflat"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">diagflat</span>(<span class="sig-arg">v</span>,
        <span class="sig-arg">k</span>=<span class="sig-default">0</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Create a two-dimensional array with the flattened input as a diagonal.

Parameters
----------
v : array_like
    Input data, which is flattened and set as the `k`-th
    diagonal of the output.
k : int, optional
    Diagonal to set.  The default is 0.

Returns
-------
out : ndarray
    The 2-D output array.

See Also
--------
diag : Matlab workalike for 1-D and 2-D arrays.
diagonal : Return specified diagonals.
trace : Sum along diagonals.

Examples
--------
&gt;&gt;&gt; np.diagflat([[1,2], [3,4]])
array([[1, 0, 0, 0],
       [0, 2, 0, 0],
       [0, 0, 3, 0],
       [0, 0, 0, 4]])

&gt;&gt;&gt; np.diagflat([1,2], 1)
array([[0, 1, 0],
       [0, 0, 2],
       [0, 0, 0]])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="diagonal"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">diagonal</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">offset</span>=<span class="sig-default">0</span>,
        <span class="sig-arg">axis1</span>=<span class="sig-default">0</span>,
        <span class="sig-arg">axis2</span>=<span class="sig-default">1</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return specified diagonals.</p>
<p>If <code class="link">a</code> is 2-D, returns the diagonal of <code class="link">a</code> with the given offset,
i.e., the collection of elements of the form <code class="link">a[i,i+offset]</code>.
If <code class="link">a</code> has more than two dimensions, then the axes specified
by <code class="link">axis1</code> and <code class="link">axis2</code> are used to determine the 2-D subarray
whose diagonal is returned. The shape of the resulting array
can be determined by removing <code class="link">axis1</code> and <code class="link">axis2</code> and appending
an index to the right equal to the size of the resulting diagonals.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Array from which the diagonals are taken.</dd>
<dt>offset <span class="classifier-delimiter">:</span> <span class="rst-classifier">int, optional</span></dt>
<dd>Offset of the diagonal from the main diagonal. Can be both positive
and negative. Defaults to main diagonal (0).</dd>
<dt>axis1 <span class="classifier-delimiter">:</span> <span class="rst-classifier">int, optional</span></dt>
<dd>Axis to be used as the first axis of the 2-D subarrays from which
the diagonals should be taken. Defaults to first axis (0).</dd>
<dt>axis2 <span class="classifier-delimiter">:</span> <span class="rst-classifier">int, optional</span></dt>
<dd>Axis to be used as the second axis of the 2-D subarrays from which
the diagonals should be taken. Defaults to second axis (1).</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>array_of_diagonals <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray</span></dt>
<dd>If <code class="link">a</code> is 2-D, a 1-D array containing the diagonal is
returned.  If <code class="link">a</code> has larger dimensions, then an array of
diagonals is returned.</dd>
</dl>
</div>
<div class="rst-section" id="rst-raises">
<h1 class="heading">Raises</h1>
<dl class="rst-docutils">
<dt>ValueError</dt>
<dd>If the dimension of <code class="link">a</code> is less than 2.</dd>
</dl>
</div>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<p>diag : Matlab workalike for 1-D and 2-D arrays.
diagflat : Create diagonal arrays.
trace : Sum along diagonals.</p>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>a = np.arange(4).reshape(2,2)
<span class="py-prompt">&gt;&gt;&gt; </span>a
<span class="py-output">array([[0, 1],</span>
<span class="py-output">       [2, 3]])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>a.diagonal()
<span class="py-output">array([0, 3])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>a.diagonal(1)
<span class="py-output">array([1])</span></pre>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>a = np.arange(8).reshape(2,2,2)
<span class="py-prompt">&gt;&gt;&gt; </span>a
<span class="py-output">array([[[0, 1],</span>
<span class="py-output">        [2, 3]],</span>
<span class="py-output">       [[4, 5],</span>
<span class="py-output">        [6, 7]]])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>a.diagonal(0,-2,-1)
<span class="py-output">array([[0, 3],</span>
<span class="py-output">       [4, 7]])</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="diff"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">diff</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">n</span>=<span class="sig-default">1</span>,
        <span class="sig-arg">axis</span>=<span class="sig-default">-1</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Calculate the nth order discrete difference along given axis.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Input array</dd>
<dt>n <span class="classifier-delimiter">:</span> <span class="rst-classifier">int, optional</span></dt>
<dd>The number of times values are differenced.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="rst-classifier">int, optional</span></dt>
<dd>The axis along which the difference is taken.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray</span></dt>
<dd>The <code class="link">n</code> order differences.  The shape of the output is the same as <code class="link">a</code>
except along <code class="link">axis</code> where the dimension is <code class="link">n</code> less.</dd>
</dl>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>x = np.array([0,1,3,9,5,10])
<span class="py-prompt">&gt;&gt;&gt; </span>np.diff(x)
<span class="py-output">array([ 1,  2,  6, -4,  5])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.diff(x,n=2)
<span class="py-output">array([  1,   4, -10,   9])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>x = np.array([[1,3,6,10],[0,5,6,8]])
<span class="py-prompt">&gt;&gt;&gt; </span>np.diff(x)
<span class="py-output">array([[2, 3, 4],</span>
<span class="py-output">[5, 1, 2]])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.diff(x,axis=0)
<span class="py-output">array([[-1,  2,  0, -2]])</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="digitize"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">digitize</span>(<span class="sig-arg">x</span>,
        <span class="sig-arg">bins</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">
Return the indices of the bins to which each value in input array belongs.

Each index returned is such that `bins[i-1]` &lt;= `x` &lt; `bins[i]` if `bins`
is monotonically increasing, or `bins[i-1]` &gt; `x` &gt;= `bins[i]` if `bins`
is monotonically decreasing. Beyond the bounds of `bins`, 0 or len(`bins`)
is returned as appropriate.

Parameters
----------
x : array_like
    Input array to be binned.
bins : array_like
    Array of bins.

Returns
-------
out : ndarray
    Output array of indices of same shape as `x`.

Examples
--------
&gt;&gt;&gt; x = np.array([0.2, 6.4, 3.0, 1.6])
&gt;&gt;&gt; bins = np.array([0.0, 1.0, 2.5, 4.0, 10.0])
&gt;&gt;&gt; d = np.digitize(x,bins)
&gt;&gt;&gt; d
array([1, 4, 3, 2])
&gt;&gt;&gt; for n in range(len(x)):
...   print bins[d[n]-1], &quot;&lt;=&quot;, x[n], &quot;&lt;&quot;, bins[d[n]]
...
0.0 &lt;= 0.2 &lt; 1.0
4.0 &lt;= 6.4 &lt; 10.0
2.5 &lt;= 3.0 &lt; 4.0
1.0 &lt;= 1.6 &lt; 2.5

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="disp"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">disp</span>(<span class="sig-arg">mesg</span>,
        <span class="sig-arg">device</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">linefeed</span>=<span class="sig-default">True</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Display a message on a device</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>mesg <span class="classifier-delimiter">:</span> <span class="rst-classifier">string</span></dt>
<dd>Message to display.</dd>
<dt>device <span class="classifier-delimiter">:</span> <span class="rst-classifier">device object with 'write' method</span></dt>
<dd>Device to write message.  If None, defaults to <tt class="rst-docutils literal"><span class="pre">sys.stdout</span></tt> which is
very similar to <tt class="rst-docutils literal"><span class="pre">print</span></tt>.</dd>
<dt>linefeed <span class="classifier-delimiter">:</span> <span class="rst-classifier">bool, optional</span></dt>
<dd>Option whether to print a line feed or not.  Defaults to True.</dd>
</dl>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="dot"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">dot</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">b</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">
Dot product of two arrays.

For 2-D arrays it is equivalent to matrix multiplication, and for 1-D
arrays to inner product of vectors (without complex conjugation). For
N dimensions it is a sum product over the last axis of `a` and
the second-to-last of `b`::

    dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])

Parameters
----------
a : array_like
    First argument.
b : array_like
    Second argument.

Returns
-------
output : ndarray
    Returns the dot product of `a` and `b`.  If `a` and `b` are both
    scalars or both 1-D arrays then a scalar is returned; otherwise
    an array is returned.

Raises
------
ValueError
    If the last dimension of `a` is not the same size as
    the second-to-last dimension of `b`.

See Also
--------
vdot : Complex-conjugating dot product.
tensordot : Sum products over arbitrary axes.

Examples
--------
&gt;&gt;&gt; np.dot(3, 4)
12

Neither argument is complex-conjugated:

&gt;&gt;&gt; np.dot([2j, 3j], [2j, 3j])
(-13+0j)

For 2-D arrays it's the matrix product:

&gt;&gt;&gt; a = [[1, 0], [0, 1]]
&gt;&gt;&gt; b = [[4, 1], [2, 2]]
&gt;&gt;&gt; np.dot(a, b)
array([[4, 1],
       [2, 2]])

&gt;&gt;&gt; a = np.arange(3*4*5*6).reshape((3,4,5,6))
&gt;&gt;&gt; b = np.arange(3*4*5*6)[::-1].reshape((5,4,6,3))
&gt;&gt;&gt; np.dot(a, b)[2,3,2,1,2,2]
499128
&gt;&gt;&gt; sum(a[2,3,2,:] * b[1,2,:,2])
499128

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="dsplit"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">dsplit</span>(<span class="sig-arg">ary</span>,
        <span class="sig-arg">indices_or_sections</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Split array into multiple sub-arrays along the 3rd axis (depth).

Please refer to the ``split`` documentation.  ``dsplit`` is equivalent
to ``split`` with `axis=2`, the array is always split along the third
axis provided the array dimension is greater than or equal to 3.

See Also
--------
split : Split an array into multiple sub-arrays of equal size.

Examples
--------
&gt;&gt;&gt; x = np.arange(16.0).reshape(2, 2, 4)
&gt;&gt;&gt; x
array([[[  0.,   1.,   2.,   3.],
        [  4.,   5.,   6.,   7.]],
       [[  8.,   9.,  10.,  11.],
        [ 12.,  13.,  14.,  15.]]])
&gt;&gt;&gt; np.dsplit(x, 2)
[array([[[  0.,   1.],
        [  4.,   5.]],
       [[  8.,   9.],
        [ 12.,  13.]]]),
 array([[[  2.,   3.],
        [  6.,   7.]],
       [[ 10.,  11.],
        [ 14.,  15.]]])]
&gt;&gt;&gt; np.dsplit(x, np.array([3, 6]))
[array([[[  0.,   1.,   2.],
        [  4.,   5.,   6.]],
       [[  8.,   9.,  10.],
        [ 12.,  13.,  14.]]]),
 array([[[  3.],
        [  7.]],
       [[ 11.],
        [ 15.]]]),
 array([], dtype=float64)]

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="dstack"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">dstack</span>(<span class="sig-arg">tup</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Stack arrays in sequence depth wise (along third axis).

Takes a sequence of arrays and stack them along the third axis
to make a single array. Rebuilds arrays divided by ``dsplit``.
This is a simple way to stack 2D arrays (images) into a single
3D array for processing.

Parameters
----------
tup : sequence of arrays
    Arrays to stack. All of them must have the same shape along all
    but the third axis.

Returns
-------
stacked : ndarray
    The array formed by stacking the given arrays.

See Also
--------
vstack : Stack along first axis.
hstack : Stack along second axis.
concatenate : Join arrays.
dsplit : Split array along third axis.

Notes
-----
Equivalent to ``np.concatenate(tup, axis=2)``

Examples
--------
&gt;&gt;&gt; a = np.array((1,2,3))
&gt;&gt;&gt; b = np.array((2,3,4))
&gt;&gt;&gt; np.dstack((a,b))
array([[[1, 2],
        [2, 3],
        [3, 4]]])

&gt;&gt;&gt; a = np.array([[1],[2],[3]])
&gt;&gt;&gt; b = np.array([[2],[3],[4]])
&gt;&gt;&gt; np.dstack((a,b))
array([[[1, 2]],
       [[2, 3]],
       [[3, 4]]])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="ediff1d"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">ediff1d</span>(<span class="sig-arg">ary</span>,
        <span class="sig-arg">to_end</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">to_begin</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

The differences between consecutive elements of an array.

Parameters
----------
ary : array
    This array will be flattened before the difference is taken.
to_end : number, optional
    If provided, this number will be tacked onto the end of the returned
    differences.
to_begin : number, optional
    If provided, this number will be taked onto the beginning of the
    returned differences.

Returns
-------
ed : array
    The differences. Loosely, this will be (ary[1:] - ary[:-1]).

Notes
-----
When applied to masked arrays, this function drops the mask information
if the `to_begin` and/or `to_end` parameters are used

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="empty"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">empty</span>(<span class="sig-arg">shape</span>,
        <span class="sig-arg">dtype</span>=<span class="sig-default">float</span>,
        <span class="sig-arg">order</span>=<span class="sig-default">'C'</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">
Return a new array of given shape and type, without initialising entries.

Parameters
----------
shape : {tuple of int, int}
    Shape of the empty array
dtype : data-type, optional
    Desired output data-type.
order : {'C', 'F'}, optional
    Whether to store multi-dimensional data in C (row-major) or
    Fortran (column-major) order in memory.

See Also
--------
empty_like, zeros

Notes
-----
`empty`, unlike `zeros`, does not set the array values to zero,
and may therefore be marginally faster.  On the other hand, it requires
the user to manually set all the values in the array, and should be
used with caution.

Examples
--------
&gt;&gt;&gt; np.empty([2, 2])
array([[ -9.74499359e+001,   6.69583040e-309],  #random data
       [  2.13182611e-314,   3.06959433e-309]])

&gt;&gt;&gt; np.empty([2, 2], dtype=int)
array([[-1073741821, -1067949133],  #random data
       [  496041986,    19249760]])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="empty_like"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">empty_like</span>(<span class="sig-arg">a</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Create a new array with the same shape and type as another.

Parameters
----------
a : ndarray
    Returned array will have same shape and type as `a`.

See Also
--------
zeros_like, ones_like, zeros, ones, empty

Notes
-----
This function does *not* initialize the returned array; to do that use
`zeros_like` or `ones_like` instead.

Examples
--------
&gt;&gt;&gt; a = np.array([[1,2,3],[4,5,6]])
&gt;&gt;&gt; np.empty_like(a)
&gt;&gt;&gt; np.empty_like(a)
array([[-1073741821, -1067702173,       65538],    #random data
       [      25670,    23454291,       71800]])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="expand_dims"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">expand_dims</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">axis</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Expand the shape of an array.

Insert a new axis, corresponding to a given position in the array shape.

Parameters
----------
a : array_like
    Input array.
axis : int
    Position (amongst axes) where new axis is to be inserted.

Returns
-------
res : ndarray
    Output array. The number of dimensions is one greater than that of
    the input array.

See Also
--------
doc.indexing, atleast_1d, atleast_2d, atleast_3d

Examples
--------
&gt;&gt;&gt; x = np.array([1,2])
&gt;&gt;&gt; x.shape
(2,)

The following is equivalent to ``x[np.newaxis,:]`` or ``x[np.newaxis]``:

&gt;&gt;&gt; y = np.expand_dims(x, axis=0)
&gt;&gt;&gt; y
array([[1, 2]])
&gt;&gt;&gt; y.shape
(1, 2)

&gt;&gt;&gt; y = np.expand_dims(x, axis=1)  # Equivalent to x[:,newaxis]
&gt;&gt;&gt; y
array([[1],
       [2]])
&gt;&gt;&gt; y.shape
(2, 1)

Note that some examples may use ``None`` instead of ``np.newaxis``.  These
are the same objects:

&gt;&gt;&gt; np.newaxis is None
True

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="extract"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">extract</span>(<span class="sig-arg">condition</span>,
        <span class="sig-arg">arr</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return the elements of an array that satisfy some condition.</p>
<p>This is equivalent to <tt class="rst-docutils literal"><span class="pre">np.compress(ravel(condition),</span> <span class="pre">ravel(arr))</span></tt>.  If
<code class="link">condition</code> is boolean <tt class="rst-docutils literal"><span class="pre">np.extract</span></tt> is equivalent to <tt class="rst-docutils literal"><span class="pre">arr[condition]</span></tt>.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>condition <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>An array whose nonzero or True entries indicate the elements of <code class="link">arr</code>
to extract.</dd>
<dt>arr <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Input array of the same size as <code class="link">condition</code>.</dd>
</dl>
</div>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<p>take, put, putmask</p>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>arr = np.array([[1,2,3,4],[5,6,7,8],[9,10,11,12]])
<span class="py-prompt">&gt;&gt;&gt; </span>arr
<span class="py-output">array([[ 1,  2,  3,  4],</span>
<span class="py-output">       [ 5,  6,  7,  8],</span>
<span class="py-output">       [ 9, 10, 11, 12]])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>condition = np.mod(arr, 3)==0
<span class="py-prompt">&gt;&gt;&gt; </span>condition
<span class="py-output">array([[False, False,  True, False],</span>
<span class="py-output">       [False,  True, False, False],</span>
<span class="py-output">       [ True, False, False,  True]], dtype=bool)</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.extract(condition, arr)
<span class="py-output">array([ 3,  6,  9, 12])</span></pre>
<p>If <code class="link">condition</code> is boolean:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>arr[condition]
<span class="py-output">array([ 3,  6,  9, 12])</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="eye"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">eye</span>(<span class="sig-arg">N</span>,
        <span class="sig-arg">M</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">k</span>=<span class="sig-default">0</span>,
        <span class="sig-arg">dtype</span>=<span class="sig-default">&lt;type 'float'&gt;</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return a 2-D array with ones on the diagonal and zeros elsewhere.

Parameters
----------
N : int
  Number of rows in the output.
M : int, optional
  Number of columns in the output. If None, defaults to `N`.
k : int, optional
  Index of the diagonal: 0 refers to the main diagonal, a positive value
  refers to an upper diagonal, and a negative value to a lower diagonal.
dtype : dtype, optional
  Data-type of the returned array.

Returns
-------
I : ndarray (N,M)
  An array where all elements are equal to zero, except for the `k`-th
  diagonal, whose values are equal to one.

See Also
--------
diag : Return a diagonal 2-D array using a 1-D array specified by the user.

Examples
--------
&gt;&gt;&gt; np.eye(2, dtype=int)
array([[1, 0],
       [0, 1]])
&gt;&gt;&gt; np.eye(3, k=1)
array([[ 0.,  1.,  0.],
       [ 0.,  0.,  1.],
       [ 0.,  0.,  0.]])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="find_common_type"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">find_common_type</span>(<span class="sig-arg">array_types</span>,
        <span class="sig-arg">scalar_types</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Determine common type following standard coercion rules

Parameters
----------
array_types : sequence
    A list of dtype convertible objects representing arrays
scalar_types : sequence
    A list of dtype convertible objects representing scalars

Returns
-------
datatype : dtype
    The common data-type which is the maximum of the array_types
    ignoring the scalar_types unless the maximum of the scalar_types
    is of a different kind.

    If the kinds is not understood, then None is returned.

See Also
--------
dtype

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="fix"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">fix</span>(<span class="sig-arg">x</span>,
        <span class="sig-arg">y</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Round to nearest integer towards zero.

Round an array of floats element-wise to nearest integer towards zero.
The rounded values are returned as floats.

Parameters
----------
x : array_like
    An array of floats to be rounded
y : ndarray, optional
    Output array

Returns
-------
out : ndarray of floats
    The array of rounded numbers

See Also
--------
trunc, floor, ceil
around : Round to given number of decimals

Examples
--------
&gt;&gt;&gt; np.fix(3.14)
3.0
&gt;&gt;&gt; np.fix(3)
3.0
&gt;&gt;&gt; np.fix([2.1, 2.9, -2.1, -2.9])
array([ 2.,  2., -2., -2.])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="flatnonzero"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">flatnonzero</span>(<span class="sig-arg">a</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return indices that are non-zero in the flattened version of a.

This is equivalent to a.ravel().nonzero()[0].

Parameters
----------
a : ndarray
    Input array.

Returns
-------
res : ndarray
    Output array, containing the indices of the elements of `a.ravel()`
    that are non-zero.

See Also
--------
nonzero : Return the indices of the non-zero elements of the input array.
ravel : Return a 1-D array containing the elements of the input array.

Examples
--------
&gt;&gt;&gt; x = np.arange(-2, 3)
&gt;&gt;&gt; x
array([-2, -1,  0,  1,  2])
&gt;&gt;&gt; np.flatnonzero(x)
array([0, 1, 3, 4])

Use the indices of the non-zero elements as an index array to extract
these elements:

&gt;&gt;&gt; x.ravel()[np.flatnonzero(x)]
array([-2, -1,  1,  2])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="fliplr"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">fliplr</span>(<span class="sig-arg">m</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Flip array in the left/right direction.

Flip the entries in each row in the left/right direction.
Columns are preserved, but appear in a different order than before.

Parameters
----------
m : array_like
    Input array.

Returns
-------
f : ndarray
    A view of `m` with the columns reversed.  Since a view
    is returned, this operation is :math:`\mathcal O(1)`.

See Also
--------
flipud : Flip array in the up/down direction.
rot90 : Rotate array counterclockwise.

Notes
-----
Equivalent to A[:,::-1]. Does not require the array to be
two-dimensional.

Examples
--------
&gt;&gt;&gt; A = np.diag([1.,2.,3.])
&gt;&gt;&gt; A
array([[ 1.,  0.,  0.],
       [ 0.,  2.,  0.],
       [ 0.,  0.,  3.]])
&gt;&gt;&gt; np.fliplr(A)
array([[ 0.,  0.,  1.],
       [ 0.,  2.,  0.],
       [ 3.,  0.,  0.]])

&gt;&gt;&gt; A = np.random.randn(2,3,5)
&gt;&gt;&gt; np.all(numpy.fliplr(A)==A[:,::-1,...])
True

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="flipud"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">flipud</span>(<span class="sig-arg">m</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Flip array in the up/down direction.

Flip the entries in each column in the up/down direction.
Rows are preserved, but appear in a different order than before.

Parameters
----------
m : array_like
    Input array.

Returns
-------
out : array_like
    A view of `m` with the rows reversed.  Since a view is
    returned, this operation is :math:`\mathcal O(1)`.

See Also
--------
fliplr : Flip array in the left/right direction.
rot90 : Rotate array counterclockwise.

Notes
-----
Equivalent to ``A[::-1,...]``.
Does not require the array to be two-dimensional.

Examples
--------
&gt;&gt;&gt; A = np.diag([1.0, 2, 3])
&gt;&gt;&gt; A
array([[ 1.,  0.,  0.],
       [ 0.,  2.,  0.],
       [ 0.,  0.,  3.]])
&gt;&gt;&gt; np.flipud(A)
array([[ 0.,  0.,  3.],
       [ 0.,  2.,  0.],
       [ 1.,  0.,  0.]])

&gt;&gt;&gt; A = np.random.randn(2,3,5)
&gt;&gt;&gt; np.all(np.flipud(A)==A[::-1,...])
True

&gt;&gt;&gt; np.flipud([1,2])
array([2, 1])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="frombuffer"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">frombuffer</span>(<span class="sig-arg">buffer</span>,
        <span class="sig-arg">dtype</span>=<span class="sig-default">float</span>,
        <span class="sig-arg">count</span>=<span class="sig-default">-1</span>,
        <span class="sig-arg">offset</span>=<span class="sig-default">0</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">
Interpret a buffer as a 1-dimensional array.

Parameters
----------
buffer
    An object that exposes the buffer interface.
dtype : data-type, optional
    Data type of the returned array.
count : int, optional
    Number of items to read. ``-1`` means all data in the buffer.
offset : int, optional
    Start reading the buffer from this offset.

Notes
-----
If the buffer has data that is not in machine byte-order, this
should be specified as part of the data-type, e.g.::

  &gt;&gt;&gt; dt = np.dtype(int)
  &gt;&gt;&gt; dt = dt.newbyteorder('&gt;')
  &gt;&gt;&gt; np.frombuffer(buf, dtype=dt)

The data of the resulting array will not be byteswapped,
but will be interpreted correctly.

Examples
--------
&gt;&gt;&gt; s = 'hello world'
&gt;&gt;&gt; np.frombuffer(s, dtype='S1', count=5, offset=6)
array(['w', 'o', 'r', 'l', 'd'],
      dtype='|S1')

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="fromfile"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">fromfile</span>(<span class="sig-arg">file</span>,
        <span class="sig-arg">dtype</span>=<span class="sig-default">float</span>,
        <span class="sig-arg">count</span>=<span class="sig-default">-1</span>,
        <span class="sig-arg">sep</span>=<span class="sig-default">''</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">
Construct an array from data in a text or binary file.

A highly efficient way of reading binary data with a known data-type,
as well as parsing simply formatted text files.  Data written using the
`tofile` method can be read using this function.

Parameters
----------
file : file or string
    Open file object or filename.
dtype : data-type
    Data type of the returned array.
    For binary files, it is used to determine the size and byte-order
    of the items in the file.
count : int
    Number of items to read. ``-1`` means all items (i.e., the complete
    file).
sep : string
    Separator between items if file is a text file.
    Empty (&quot;&quot;) separator means the file should be treated as binary.
    Spaces (&quot; &quot;) in the separator match zero or more whitespace characters.
    A separator consisting only of spaces must match at least one
    whitespace.

See also
--------
load, save
ndarray.tofile
loadtxt : More flexible way of loading data from a text file.

Notes
-----
Do not rely on the combination of `tofile` and `fromfile` for
data storage, as the binary files generated are are not platform
independent.  In particular, no byte-order or data-type information is
saved.  Data can be stored in the platform independent ``.npy`` format
using `save` and `load` instead.

Examples
--------
Construct an ndarray:

&gt;&gt;&gt; dt = np.dtype([('time', [('min', int), ('sec', int)]),
...                ('temp', float)])
&gt;&gt;&gt; x = np.zeros((1,), dtype=dt)
&gt;&gt;&gt; x['time']['min'] = 10; x['temp'] = 98.25
&gt;&gt;&gt; x
array([((10, 0), 98.25)],
      dtype=[('time', [('min', '&lt;i4'), ('sec', '&lt;i4')]), ('temp', '&lt;f8')])

Save the raw data to disk:

&gt;&gt;&gt; import os
&gt;&gt;&gt; fname = os.tmpnam()
&gt;&gt;&gt; x.tofile(fname)

Read the raw data from disk:

&gt;&gt;&gt; np.fromfile(fname, dtype=dt)
array([((10, 0), 98.25)],
      dtype=[('time', [('min', '&lt;i4'), ('sec', '&lt;i4')]), ('temp', '&lt;f8')])

The recommended way to store and load data:

&gt;&gt;&gt; np.save(fname, x)
&gt;&gt;&gt; np.load(fname + '.npy')
array([((10, 0), 98.25)],
      dtype=[('time', [('min', '&lt;i4'), ('sec', '&lt;i4')]), ('temp', '&lt;f8')])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="fromfunction"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">fromfunction</span>(<span class="sig-arg">function</span>,
        <span class="sig-arg">shape</span>,
        <span class="sig-arg">**kwargs</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Construct an array by executing a function over each coordinate.

The resulting array therefore has a value ``fn(x, y, z)`` at
coordinate ``(x, y, z)``.

Parameters
----------
fn : callable
    The function is called with N parameters, each of which
    represents the coordinates of the array varying along a
    specific axis.  For example, if `shape` were ``(2, 2)``, then
    the parameters would be two arrays, ``[[0, 0], [1, 1]]`` and
    ``[[0, 1], [0, 1]]``.  `fn` must be capable of operating on
    arrays, and should return a scalar value.
shape : (N,) tuple of ints
    Shape of the output array, which also determines the shape of
    the coordinate arrays passed to `fn`.
dtype : data-type, optional
    Data-type of the coordinate arrays passed to `fn`.  By default,
    `dtype` is float.

See Also
--------
indices, meshgrid

Notes
-----
Keywords other than `shape` and `dtype` are passed to the function.

Examples
--------
&gt;&gt;&gt; np.fromfunction(lambda i, j: i == j, (3, 3), dtype=int)
array([[ True, False, False],
       [False,  True, False],
       [False, False,  True]], dtype=bool)

&gt;&gt;&gt; np.fromfunction(lambda i, j: i + j, (3, 3), dtype=int)
array([[0, 1, 2],
       [1, 2, 3],
       [2, 3, 4]])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="fromiter"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">fromiter</span>(<span class="sig-arg">iterable</span>,
        <span class="sig-arg">dtype</span>,
        <span class="sig-arg">count</span>=<span class="sig-default">-1</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">
Create a new 1-dimensional array from an iterable object.

Parameters
----------
iterable : iterable object
    An iterable object providing data for the array.
dtype : data-type
    The data type of the returned array.
count : int, optional
    The number of items to read from iterable. The default is -1,
    which means all data is read.

Returns
-------
out : ndarray
    The output array.

Notes
-----
Specify ``count`` to improve performance.  It allows
``fromiter`` to pre-allocate the output array, instead of
resizing it on demand.

Examples
--------
&gt;&gt;&gt; iterable = (x*x for x in range(5))
&gt;&gt;&gt; np.fromiter(iterable, np.float)
array([  0.,   1.,   4.,   9.,  16.])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="frompyfunc"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">frompyfunc</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>frompyfunc(func, nin, nout) take an arbitrary python function that 
  takes nin objects as input and returns nout objects and return a 
  universal function (ufunc). This ufunc always returns PyObject arrays</p>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="fromregex"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">fromregex</span>(<span class="sig-arg">file</span>,
        <span class="sig-arg">regexp</span>,
        <span class="sig-arg">dtype</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Construct an array from a text file, using regular-expressions parsing.

Array is constructed from all matches of the regular expression
in the file. Groups in the regular expression are converted to fields.

Parameters
----------
file : str or file
    File name or file object to read.
regexp : str or regexp
    Regular expression used to parse the file.
    Groups in the regular expression correspond to fields in the dtype.
dtype : dtype or dtype list
    Dtype for the structured array

Examples
--------
&gt;&gt;&gt; f = open('test.dat', 'w')
&gt;&gt;&gt; f.write(&quot;1312 foo\n1534  bar\n444   qux&quot;)
&gt;&gt;&gt; f.close()
&gt;&gt;&gt; np.fromregex('test.dat', r&quot;(\d+)\s+(...)&quot;,
...              [('num', np.int64), ('key', 'S3')])
array([(1312L, 'foo'), (1534L, 'bar'), (444L, 'qux')],
      dtype=[('num', '&lt;i8'), ('key', '|S3')])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="fromstring"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">fromstring</span>(<span class="sig-arg">string</span>,
        <span class="sig-arg">dtype</span>=<span class="sig-default">float</span>,
        <span class="sig-arg">count</span>=<span class="sig-default">-1</span>,
        <span class="sig-arg">sep</span>=<span class="sig-default">''</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">
Return a new 1d array initialized from raw binary or text data in
string.

Parameters
----------
string : str
    A string containing the data.
dtype : dtype, optional
    The data type of the array. For binary input data, the data must be
    in exactly this format.
count : int, optional
    Read this number of `dtype` elements from the data. If this is
    negative, then the size will be determined from the length of the
    data.
sep : str, optional
    If provided and not empty, then the data will be interpreted as
    ASCII text with decimal numbers. This argument is interpreted as the
    string separating numbers in the data. Extra whitespace between
    elements is also ignored.

Returns
-------
arr : array
    The constructed array.

Raises
------
ValueError
    If the string is not the correct size to satisfy the requested
    `dtype` and `count`.

Examples
--------
&gt;&gt;&gt; np.fromstring('\x01\x02', dtype=np.uint8)
array([1, 2], dtype=uint8)
&gt;&gt;&gt; np.fromstring('1 2', dtype=int, sep=' ')
array([1, 2])
&gt;&gt;&gt; np.fromstring('1, 2', dtype=int, sep=',')
array([1, 2])
&gt;&gt;&gt; np.fromstring('\x01\x02\x03\x04\x05', dtype=np.uint8, count=3)
array([1, 2, 3], dtype=uint8)

Invalid inputs:

&gt;&gt;&gt; np.fromstring('\x01\x02\x03\x04\x05', dtype=np.int32)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
ValueError: string size must be a multiple of element size
&gt;&gt;&gt; np.fromstring('\x01\x02', dtype=np.uint8, count=3)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
ValueError: string is smaller than requested size

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="fv"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">fv</span>(<span class="sig-arg">rate</span>,
        <span class="sig-arg">nper</span>,
        <span class="sig-arg">pmt</span>,
        <span class="sig-arg">pv</span>,
        <span class="sig-arg">when</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string">end</code><code class="variable-quote">'</code></span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Compute the future value.

Parameters
----------
rate : scalar or array_like of shape(M, )
    Rate of interest as decimal (not per cent) per period
nper : scalar or array_like of shape(M, )
    Number of compounding periods
pmt : scalar or array_like of shape(M, )
    Payment
pv : scalar or array_like of shape(M, )
    Present value
when : {{'begin', 1}, {'end', 0}}, {string, int}, optional
    When payments are due ('begin' (1) or 'end' (0)).
    Defaults to {'end', 0}.

Returns
-------
out : ndarray
    Future values.  If all input is scalar, returns a scalar float.  If
    any input is array_like, returns future values for each input element.
    If multiple inputs are array_like, they all must have the same shape.

Notes
-----
The future value is computed by solving the equation::

 fv +
 pv*(1+rate)**nper +
 pmt*(1 + rate*when)/rate*((1 + rate)**nper - 1) == 0

or, when ``rate == 0``::

 fv + pv + pmt * nper == 0

Examples
--------
What is the future value after 10 years of saving $100 now, with
an additional monthly savings of $100.  Assume the interest rate is
5% (annually) compounded monthly?

&gt;&gt;&gt; np.fv(0.05/12, 10*12, -100, -100)
15692.928894335748

By convention, the negative sign represents cash flow out (i.e. money not
available today).  Thus, saving $100 a month at 5% annual interest leads
to $15,692.93 available to spend in 10 years.

If any input is array_like, returns an array of equal shape.  Let's
compare different interest rates from the example above.

&gt;&gt;&gt; a = np.array((0.05, 0.06, 0.07))/12
&gt;&gt;&gt; np.fv(a, 10*12, -100, -100)
array([ 15692.92889434,  16569.87435405,  17509.44688102])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="genfromtxt"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">genfromtxt</span>(<span class="sig-arg">fname</span>,
        <span class="sig-arg">dtype</span>=<span class="sig-default">&lt;type 'float'&gt;</span>,
        <span class="sig-arg">comments</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string">#</code><code class="variable-quote">'</code></span>,
        <span class="sig-arg">delimiter</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">skiprows</span>=<span class="sig-default">0</span>,
        <span class="sig-arg">converters</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">missing</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string"></code><code class="variable-quote">'</code></span>,
        <span class="sig-arg">missing_values</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">usecols</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">names</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">excludelist</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">deletechars</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">case_sensitive</span>=<span class="sig-default">True</span>,
        <span class="sig-arg">unpack</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">usemask</span>=<span class="sig-default">False</span>,
        <span class="sig-arg">loose</span>=<span class="sig-default">True</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Load data from a text file.

Each line past the first `skiprows` ones is split at the `delimiter`
character, and characters following the `comments` character are discarded.



Parameters
----------
fname : file or string
    File or filename to read.  If the filename extension is `.gz` or `.bz2`,
    the file is first decompressed.
dtype : data-type
    Data type of the resulting array.  If this is a flexible data-type,
    the resulting array will be 1-dimensional, and each row will be
    interpreted as an element of the array. In this case, the number
    of columns used must match the number of fields in the data-type,
    and the names of each field will be set by the corresponding name
    of the dtype.
    If None, the dtypes will be determined by the contents of each
    column, individually.
comments : {string}, optional
    The character used to indicate the start of a comment.
    All the characters occurring on a line after a comment are discarded
delimiter : {string}, optional
    The string used to separate values.  By default, any consecutive
    whitespace act as delimiter.
skiprows : {int}, optional
    Numbers of lines to skip at the beginning of the file.
converters : {None, dictionary}, optional
    A dictionary mapping column number to a function that will convert
    values in the column to a number. Converters can also be used to
    provide a default value for missing data:
    ``converters = {3: lambda s: float(s or 0)}``.
missing : {string}, optional
    A string representing a missing value, irrespective of the column where
    it appears (e.g., `'missing'` or `'unused'`).
missing_values : {None, dictionary}, optional
    A dictionary mapping a column number to a string indicating whether the
    corresponding field should be masked.
usecols : {None, sequence}, optional
    Which columns to read, with 0 being the first.  For example,
    ``usecols = (1,4,5)`` will extract the 2nd, 5th and 6th columns.
names : {None, True, string, sequence}, optional
    If `names` is True, the field names are read from the first valid line
    after the first `skiprows` lines.
    If `names` is a sequence or a single-string of comma-separated names,
    the names will be used to define the field names in a flexible dtype.
    If `names` is None, the names of the dtype fields will be used, if any.
excludelist : {sequence}, optional
    A list of names to exclude. This list is appended to the default list
    ['return','file','print']. Excluded names are appended an underscore:
    for example, `file` would become `file_`.
deletechars : {string}, optional
    A string combining invalid characters that must be deleted from the names.
case_sensitive : {True, False, 'upper', 'lower'}, optional
    If True, field names are case_sensitive.
    If False or 'upper', field names are converted to upper case.
    If 'lower', field names are converted to lower case.
unpack : {bool}, optional
    If True, the returned array is transposed, so that arguments may be
    unpacked using ``x, y, z = loadtxt(...)``
usemask : {bool}, optional
    If True, returns a masked array.
    If False, return a regular standard array.

Returns
-------
out : MaskedArray
    Data read from the text file.

Notes
--------
* When spaces are used as delimiters, or when no delimiter has been given
  as input, there should not be any missing data between two fields.
* When the variable are named (either by a flexible dtype or with `names`,
  there must not be any header in the file (else a :exc:ValueError exception
  is raised).

Warnings
--------
* Individual values are not stripped of spaces by default.
  When using a custom converter, make sure the function does remove spaces.

See Also
--------
numpy.loadtxt : equivalent function when no data is missing.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="get_array_wrap"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">get_array_wrap</span>(<span class="sig-arg">*args</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Find the wrapper for the array with the highest priority.</p>
  <p>In case of ties, leftmost wins. If no wrapper is found, return 
  None</p>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="get_include"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">get_include</span>()</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return the directory that contains the numpy \*.h header files.

Extension modules that need to compile against numpy should use this
function to locate the appropriate include directory.

Notes
-----
When using ``distutils``, for example in ``setup.py``.
::

    import numpy as np
    ...
    Extension('extension_name', ...
            include_dirs=[np.get_include()])
    ...

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="get_numarray_include"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">get_numarray_include</span>(<span class="sig-arg">type</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return the directory that contains the numarray \*.h header files.

Extension modules that need to compile against numarray should use this
function to locate the appropriate include directory.

Notes
-----
When using ``distutils``, for example in ``setup.py``.
::

    import numpy as np
    ...
    Extension('extension_name', ...
            include_dirs=[np.get_numarray_include()])
    ...

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="get_numpy_include"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">get_numpy_include</span>(<span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">
get_numpy_include is DEPRECATED!! -- use get_include instead


Return the directory that contains the numpy \*.h header files.

Extension modules that need to compile against numpy should use this
function to locate the appropriate include directory.

Notes
-----
When using ``distutils``, for example in ``setup.py``.
::

    import numpy as np
    ...
    Extension('extension_name', ...
            include_dirs=[np.get_include()])
    ...

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="get_printoptions"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">get_printoptions</span>()</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return the current print options.</p>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>print_opts <span class="classifier-delimiter">:</span> <span class="rst-classifier">dict</span></dt>
<dd><p class="rst-first">Dictionary of current print options with keys</p>
<blockquote class="rst-last">
<ul class="rst-simple">
<li>precision : int</li>
<li>threshold : int</li>
<li>edgeitems : int</li>
<li>linewidth : int</li>
<li>suppress : bool</li>
<li>nanstr : string</li>
<li>infstr : string</li>
</ul>
</blockquote>
</dd>
</dl>
</div>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<p>set_printoptions : parameter descriptions</p>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="getbuffer"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">getbuffer</span>(<span class="sig-arg">obj</span>,
        <span class="sig-arg">offset</span>=<span class="sig-default">...</span>,
        <span class="sig-arg">size</span>=<span class="sig-default">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Create a buffer object from the given object referencing a slice of 
  length size starting at offset.  Default is the entire buffer. A 
  read-write buffer is attempted followed by a read-only buffer.</p>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="geterr"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">geterr</span>()</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Get the current way of handling floating-point errors.</p>
  <p>Returns a dictionary with entries &quot;divide&quot;, 
  &quot;over&quot;, &quot;under&quot;, and &quot;invalid&quot;, whose 
  values are from the strings &quot;ignore&quot;, &quot;print&quot;, 
  &quot;log&quot;, &quot;warn&quot;, &quot;raise&quot;, and 
  &quot;call&quot;.</p>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="geterrobj"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">geterrobj</span>()</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">
Used internally by `geterr`.

Returns
-------
errobj : list
    Internal numpy buffer size, error mask, error callback function.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="gradient"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">gradient</span>(<span class="sig-arg">f</span>,
        <span class="sig-arg">*varargs</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return the gradient of an N-dimensional array.</p>
<p>The gradient is computed using central differences in the interior
and first differences at the boundaries. The returned gradient hence has
the same shape as the input array.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>f <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>An N-dimensional array containing samples of a scalar function.</dd>
<dt><code class="link">*varargs</code> <span class="classifier-delimiter">:</span> <span class="rst-classifier">scalars</span></dt>
<dd>0, 1, or N scalars specifying the sample distances in each direction,
that is: <code class="link">dx</code>, <code class="link">dy</code>, <code class="link">dz</code>, ... The default distance is 1.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>g <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray</span></dt>
<dd>N arrays of the same shape as <code class="link">f</code> giving the derivative of <code class="link">f</code> with
respect to each dimension.</dd>
</dl>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.gradient(np.array([[1,1],[3,4]]))
<span class="py-output">[array([[ 2.,  3.],</span>
<span class="py-output">       [ 2.,  3.]]),</span>
<span class="py-output"> array([[ 0.,  0.],</span>
<span class="py-output">       [ 1.,  1.]])]</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="hamming"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">hamming</span>(<span class="sig-arg">M</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return the Hamming window.

The Hamming window is a taper formed by using a weighted cosine.

Parameters
----------
M : int
    Number of points in the output window. If zero or less, an
    empty array is returned.

Returns
-------
out : ndarray
    The window, normalized to one (the value one
    appears only if the number of samples is odd).

See Also
--------
bartlett, blackman, hanning, kaiser

Notes
-----
The Hamming window is defined as

.. math::  w(n) = 0.54 + 0.46cos\left(\frac{2\pi{n}}{M-1}\right)
           \qquad 0 \leq n \leq M-1

The Hamming was named for R. W. Hamming, an associate of J. W. Tukey and
is described in Blackman and Tukey. It was recommended for smoothing the
truncated autocovariance function in the time domain.
Most references to the Hamming window come from the signal processing
literature, where it is used as one of many windowing functions for
smoothing values.  It is also known as an apodization (which means
&quot;removing the foot&quot;, i.e. smoothing discontinuities at the beginning
and end of the sampled signal) or tapering function.

References
----------
.. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power
       spectra, Dover Publications, New York.
.. [2] E.R. Kanasewich, &quot;Time Sequence Analysis in Geophysics&quot;, The
       University of Alberta Press, 1975, pp. 109-110.
.. [3] Wikipedia, &quot;Window function&quot;,
       http://en.wikipedia.org/wiki/Window_function
.. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,
       &quot;Numerical Recipes&quot;, Cambridge University Press, 1986, page 425.

Examples
--------
&gt;&gt;&gt; from numpy import hamming
&gt;&gt;&gt; hamming(12)
array([ 0.08      ,  0.15302337,  0.34890909,  0.60546483,  0.84123594,
        0.98136677,  0.98136677,  0.84123594,  0.60546483,  0.34890909,
        0.15302337,  0.08      ])

Plot the window and the frequency response:

&gt;&gt;&gt; from numpy import clip, log10, array, hamming
&gt;&gt;&gt; from scipy.fftpack import fft, fftshift
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; window = hamming(51)
&gt;&gt;&gt; plt.plot(window)
&gt;&gt;&gt; plt.title(&quot;Hamming window&quot;)
&gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;)
&gt;&gt;&gt; plt.xlabel(&quot;Sample&quot;)
&gt;&gt;&gt; plt.show()

&gt;&gt;&gt; A = fft(window, 2048) / 25.5
&gt;&gt;&gt; mag = abs(fftshift(A))
&gt;&gt;&gt; freq = linspace(-0.5,0.5,len(A))
&gt;&gt;&gt; response = 20*log10(mag)
&gt;&gt;&gt; response = clip(response,-100,100)
&gt;&gt;&gt; plt.plot(freq, response)
&gt;&gt;&gt; plt.title(&quot;Frequency response of Hamming window&quot;)
&gt;&gt;&gt; plt.ylabel(&quot;Magnitude [dB]&quot;)
&gt;&gt;&gt; plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;)
&gt;&gt;&gt; plt.axis('tight'); plt.show()

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="hanning"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">hanning</span>(<span class="sig-arg">M</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return the Hanning window.

The Hanning window is a taper formed by using a weighted cosine.

Parameters
----------
M : int
    Number of points in the output window. If zero or less, an
    empty array is returned.

Returns
-------
out : ndarray, shape(M,)
    The window, normalized to one (the value one
    appears only if `M` is odd).

See Also
--------
bartlett, blackman, hamming, kaiser

Notes
-----
The Hanning window is defined as

.. math::  w(n) = 0.5 - 0.5cos\left(\frac{2\pi{n}}{M-1}\right)
           \qquad 0 \leq n \leq M-1

The Hanning was named for Julius van Hann, an Austrian meterologist. It is
also known as the Cosine Bell. Some authors prefer that it be called a
Hann window, to help avoid confusion with the very similar Hamming window.

Most references to the Hanning window come from the signal processing
literature, where it is used as one of many windowing functions for
smoothing values.  It is also known as an apodization (which means
&quot;removing the foot&quot;, i.e. smoothing discontinuities at the beginning
and end of the sampled signal) or tapering function.

References
----------
.. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power
       spectra, Dover Publications, New York.
.. [2] E.R. Kanasewich, &quot;Time Sequence Analysis in Geophysics&quot;,
       The University of Alberta Press, 1975, pp. 106-108.
.. [3] Wikipedia, &quot;Window function&quot;,
       http://en.wikipedia.org/wiki/Window_function
.. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,
       &quot;Numerical Recipes&quot;, Cambridge University Press, 1986, page 425.

Examples
--------
&gt;&gt;&gt; from numpy import hanning
&gt;&gt;&gt; hanning(12)
array([ 0.        ,  0.07937323,  0.29229249,  0.57115742,  0.82743037,
        0.97974649,  0.97974649,  0.82743037,  0.57115742,  0.29229249,
        0.07937323,  0.        ])

Plot the window and its frequency response:

&gt;&gt;&gt; from numpy.fft import fft, fftshift
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; window = np.hanning(51)
&gt;&gt;&gt; plt.subplot(121)
&gt;&gt;&gt; plt.plot(window)
&gt;&gt;&gt; plt.title(&quot;Hann window&quot;)
&gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;)
&gt;&gt;&gt; plt.xlabel(&quot;Sample&quot;)

&gt;&gt;&gt; A = fft(window, 2048) / 25.5
&gt;&gt;&gt; mag = abs(fftshift(A))
&gt;&gt;&gt; freq = np.linspace(-0.5,0.5,len(A))
&gt;&gt;&gt; response = 20*np.log10(mag)
&gt;&gt;&gt; response = np.clip(response,-100,100)
&gt;&gt;&gt; plt.subplot(122)
&gt;&gt;&gt; plt.plot(freq, response)
&gt;&gt;&gt; plt.title(&quot;Frequency response of the Hann window&quot;)
&gt;&gt;&gt; plt.ylabel(&quot;Magnitude [dB]&quot;)
&gt;&gt;&gt; plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;)
&gt;&gt;&gt; plt.axis('tight'); plt.show()

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="histogram"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">histogram</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">bins</span>=<span class="sig-default">10</span>,
        <span class="sig-arg">range</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">normed</span>=<span class="sig-default">False</span>,
        <span class="sig-arg">weights</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">new</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Compute the histogram of a set of data.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Input data.</dd>
<dt>bins <span class="classifier-delimiter">:</span> <span class="rst-classifier">int or sequence of scalars, optional</span></dt>
<dd>If <code class="link">bins</code> is an int, it defines the number of equal-width
bins in the given range (10, by default). If <code class="link">bins</code> is a sequence,
it defines the bin edges, including the rightmost edge, allowing
for non-uniform bin widths.</dd>
<dt>range <span class="classifier-delimiter">:</span> <span class="rst-classifier">(float, float), optional</span></dt>
<dd>The lower and upper range of the bins.  If not provided, range
is simply <tt class="rst-docutils literal"><span class="pre">(a.min(),</span> <span class="pre">a.max())</span></tt>.  Values outside the range are
ignored. Note that with <code class="link">new</code> set to False, values below
the range are ignored, while those above the range are tallied
in the rightmost bin.</dd>
<dt>normed <span class="classifier-delimiter">:</span> <span class="rst-classifier">bool, optional</span></dt>
<dd>If False, the result will contain the number of samples
in each bin.  If True, the result is the value of the
probability <em>density</em> function at the bin, normalized such that
the <em>integral</em> over the range is 1. Note that the sum of the
histogram values will often not be equal to 1; it is not a
probability <em>mass</em> function.</dd>
<dt>weights <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like, optional</span></dt>
<dd>An array of weights, of the same shape as <code class="link">a</code>.  Each value in <code class="link">a</code>
only contributes its associated weight towards the bin count
(instead of 1).  If <code class="link">normed</code> is True, the weights are normalized,
so that the integral of the density over the range remains 1.
The <code class="link">weights</code> keyword is only available with <code class="link">new</code> set to True.</dd>
<dt>new <span class="classifier-delimiter">:</span> <span class="rst-classifier">{None, True, False}, optional</span></dt>
<dd><dl class="rst-first rst-docutils">
<dt>Whether to use the new semantics for histogram:</dt>
<dd><ul class="rst-first rst-last rst-simple">
<li>None : the new behaviour is used, no warning is printed.</li>
<li>True : the new behaviour is used and a warning is raised about
the future removal of the <code class="link">new</code> keyword.</li>
<li>False : the old behaviour is used and a DeprecationWarning
is raised.</li>
</ul>
</dd>
</dl>
<p class="rst-last">As of NumPy 1.3, this keyword should not be used explicitly since it
will disappear in NumPy 1.4.</p>
</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>hist <span class="classifier-delimiter">:</span> <span class="rst-classifier">array</span></dt>
<dd>The values of the histogram. See <code class="link">normed</code> and <code class="link">weights</code> for a
description of the possible semantics.</dd>
<dt>bin_edges <span class="classifier-delimiter">:</span> <span class="rst-classifier">array of dtype float</span></dt>
<dd>Return the bin edges <tt class="rst-docutils literal"><span class="pre">(length(hist)+1)</span></tt>.
With <tt class="rst-docutils literal"><span class="pre">new=False</span></tt>, return the left bin edges (<tt class="rst-docutils literal"><span class="pre">length(hist)</span></tt>).</dd>
</dl>
</div>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<p>histogramdd</p>
</div>
<div class="rst-section" id="rst-notes">
<h1 class="heading">Notes</h1>
<p>All but the last (righthand-most) bin is half-open.  In other words, if
<code class="link">bins</code> is:</p>
<pre class="rst-literal-block">
[1, 2, 3, 4]
</pre>
<p>then the first bin is <tt class="rst-docutils literal"><span class="pre">[1,</span> <span class="pre">2)</span></tt> (including 1, but excluding 2) and the
second <tt class="rst-docutils literal"><span class="pre">[2,</span> <span class="pre">3)</span></tt>.  The last bin, however, is <tt class="rst-docutils literal"><span class="pre">[3,</span> <span class="pre">4]</span></tt>, which <em>includes</em>
4.</p>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.histogram([1,2,1], bins=[0,1,2,3])
<span class="py-output">(array([0, 2, 1]), array([0, 1, 2, 3]))</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="histogram2d"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">histogram2d</span>(<span class="sig-arg">x</span>,
        <span class="sig-arg">y</span>,
        <span class="sig-arg">bins</span>=<span class="sig-default">10</span>,
        <span class="sig-arg">range</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">normed</span>=<span class="sig-default">False</span>,
        <span class="sig-arg">weights</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Compute the bidimensional histogram of two data samples.

Parameters
----------
x : array_like, shape(N,)
  A sequence of values to be histogrammed along the first dimension.
y : array_like, shape(M,)
  A sequence of values to be histogrammed along the second dimension.
bins : int or [int, int] or array-like or [array, array], optional
  The bin specification:

    * the number of bins for the two dimensions (nx=ny=bins),
    * the number of bins in each dimension (nx, ny = bins),
    * the bin edges for the two dimensions (x_edges=y_edges=bins),
    * the bin edges in each dimension (x_edges, y_edges = bins).

range : array_like, shape(2,2), optional
  The leftmost and rightmost edges of the bins along each dimension
  (if not specified explicitly in the `bins` parameters):
  [[xmin, xmax], [ymin, ymax]]. All values outside of this range will be
  considered outliers and not tallied in the histogram.
normed : boolean, optional
  If False, returns the number of samples in each bin. If True, returns
  the bin density, ie, the bin count divided by the bin area.
weights : array-like, shape(N,), optional
  An array of values `w_i` weighing each sample `(x_i, y_i)`. Weights are
  normalized to 1 if normed is True. If normed is False, the values of the
  returned histogram are equal to the sum of the weights belonging to the
  samples falling into each bin.

Returns
-------
H : ndarray, shape(nx, ny)
  The bidimensional histogram of samples x and y. Values in x are
  histogrammed along the first dimension and values in y are histogrammed
  along the second dimension.
xedges : ndarray, shape(nx,)
  The bin edges along the first dimension.
yedges : ndarray, shape(ny,)
  The bin edges along the second dimension.

See Also
--------
histogram: 1D histogram
histogramdd: Multidimensional histogram

Notes
-----
When normed is True, then the returned histogram is the sample density,
defined such that:

  .. math::
    \sum_{i=0}^{nx-1} \sum_{j=0}^{ny-1} H_{i,j} \Delta x_i \Delta y_j = 1

where :math:`H` is the histogram array and :math:`\Delta x_i \Delta y_i`
the area of bin :math:`{i,j}`.

Please note that the histogram does not follow the cartesian convention
where `x` values are on the abcissa and `y` values on the ordinate axis.
Rather, `x` is histogrammed along the first dimension of the array
(vertical), and `y` along the second dimension of the array (horizontal).
This ensures compatibility with `histogrammdd`.

Examples
--------
&gt;&gt;&gt; x,y = np.random.randn(2,100)
&gt;&gt;&gt; H, xedges, yedges = np.histogram2d(x, y, bins = (5, 8))
&gt;&gt;&gt; H.shape, xedges.shape, yedges.shape
((5,8), (6,), (9,))

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="histogramdd"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">histogramdd</span>(<span class="sig-arg">sample</span>,
        <span class="sig-arg">bins</span>=<span class="sig-default">10</span>,
        <span class="sig-arg">range</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">normed</span>=<span class="sig-default">False</span>,
        <span class="sig-arg">weights</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Compute the multidimensional histogram of some data.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>sample <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Data to histogram passed as a sequence of D arrays of length N, or
as an (N,D) array.</dd>
<dt>bins <span class="classifier-delimiter">:</span> <span class="rst-classifier">sequence or int, optional</span></dt>
<dd><p class="rst-first">The bin specification:</p>
<ul class="rst-last rst-simple">
<li>A sequence of arrays describing the bin edges along each dimension.</li>
<li>The number of bins for each dimension (nx, ny, ... =bins)</li>
<li>The number of bins for all dimensions (nx=ny=...=bins).</li>
</ul>
</dd>
<dt>range <span class="classifier-delimiter">:</span> <span class="rst-classifier">sequence, optional</span></dt>
<dd>A sequence of lower and upper bin edges to be used if the edges are
not given explicitely in <code class="link">bins</code>. Defaults to the minimum and maximum
values along each dimension.</dd>
<dt>normed <span class="classifier-delimiter">:</span> <span class="rst-classifier">boolean, optional</span></dt>
<dd>If False, returns the number of samples in each bin. If True, returns
the bin density, ie, the bin count divided by the bin hypervolume.</dd>
<dt>weights <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like (N,), optional</span></dt>
<dd>An array of values <code class="link">w_i</code> weighing each sample <code class="link">(x_i, y_i, z_i, ...)</code>.
Weights are normalized to 1 if normed is True. If normed is False, the
values of the returned histogram are equal to the sum of the weights
belonging to the samples falling into each bin.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>H <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray</span></dt>
<dd>The multidimensional histogram of sample x. See normed and weights for
the different possible semantics.</dd>
<dt>edges <span class="classifier-delimiter">:</span> <span class="rst-classifier">list</span></dt>
<dd>A list of D arrays describing the bin edges for each dimension.</dd>
</dl>
</div>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<p>histogram: 1D histogram
histogram2d: 2D histogram</p>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>r = np.random.randn(100,3)
<span class="py-prompt">&gt;&gt;&gt; </span>H, edges = np.histogramdd(r, bins = (5, 8, 4))
<span class="py-prompt">&gt;&gt;&gt; </span>H.shape, edges[0].size, edges[1].size, edges[2].size
<span class="py-output">((5,8,4), 6, 9, 5)</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="hsplit"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">hsplit</span>(<span class="sig-arg">ary</span>,
        <span class="sig-arg">indices_or_sections</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Split an array into multiple sub-arrays horizontally (column-wise).

Please refer to the ``split`` documentation.  ``hsplit`` is equivalent
to ``split`` with `axis=1`, the array is always split along the second
axis regardless of the array dimension.

See Also
--------
split : Split an array into multiple sub-arrays of equal size.

Examples
--------
&gt;&gt;&gt; x = np.arange(16.0).reshape(4, 4)
&gt;&gt;&gt; x
array([[  0.,   1.,   2.,   3.],
       [  4.,   5.,   6.,   7.],
       [  8.,   9.,  10.,  11.],
       [ 12.,  13.,  14.,  15.]])
&gt;&gt;&gt; np.hsplit(x, 2)
[array([[  0.,   1.],
       [  4.,   5.],
       [  8.,   9.],
       [ 12.,  13.]]),
 array([[  2.,   3.],
       [  6.,   7.],
       [ 10.,  11.],
       [ 14.,  15.]])]
&gt;&gt;&gt; np.hsplit(x, np.array([3, 6]))
[array([[  0.,   1.,   2.],
       [  4.,   5.,   6.],
       [  8.,   9.,  10.],
       [ 12.,  13.,  14.]]),
 array([[  3.],
       [  7.],
       [ 11.],
       [ 15.]]),
 array([], dtype=float64)]

With a higher dimensional array the split is still along the second axis.

&gt;&gt;&gt; x = np.arange(8.0).reshape(2, 2, 2)
&gt;&gt;&gt; x
array([[[ 0.,  1.],
        [ 2.,  3.]],
       [[ 4.,  5.],
        [ 6.,  7.]]])
&gt;&gt;&gt; np.hsplit(x, 2)
[array([[[ 0.,  1.]],
       [[ 4.,  5.]]]),
 array([[[ 2.,  3.]],
       [[ 6.,  7.]]])]

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="hstack"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">hstack</span>(<span class="sig-arg">tup</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Stack arrays in sequence horizontally (column wise).

Take a sequence of arrays and stack them horizontally to make
a single array. Rebuild arrays divided by ``hsplit``.

Parameters
----------
tup : sequence of ndarrays
    All arrays must have the same shape along all but the second axis.

Returns
-------
stacked : ndarray
    The array formed by stacking the given arrays.

See Also
--------
vstack : Stack arrays in sequence vertically (row wise).
dstack : Stack arrays in sequence depth wise (along third axis).
concatenate : Join a sequence of arrays together.
hsplit : Split array along second axis.

Notes
-----
Equivalent to ``np.concatenate(tup, axis=1)``

Examples
--------
&gt;&gt;&gt; a = np.array((1,2,3))
&gt;&gt;&gt; b = np.array((2,3,4))
&gt;&gt;&gt; np.hstack((a,b))
array([1, 2, 3, 2, 3, 4])
&gt;&gt;&gt; a = np.array([[1],[2],[3]])
&gt;&gt;&gt; b = np.array([[2],[3],[4]])
&gt;&gt;&gt; np.hstack((a,b))
array([[1, 2],
       [2, 3],
       [3, 4]])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="i0"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">i0</span>(<span class="sig-arg">x</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Modified Bessel function of the first kind, order 0.

Usually denoted :math:`I_0`.

Parameters
----------
x : array_like, dtype float or complex
    Argument of the Bessel function.

Returns
-------
out : ndarray, shape z.shape, dtype z.dtype
    The modified Bessel function evaluated at the elements of `x`.

See Also
--------
scipy.special.iv, scipy.special.ive

References
----------
.. [1] M. Abramowitz and I.A. Stegun, &quot;Handbook of Mathematical Functions&quot;,
       10th printing, 1964, pp. 374. http://www.math.sfu.ca/~cbm/aands/
.. [2] Wikipedia, &quot;Bessel function&quot;,
       http://en.wikipedia.org/wiki/Bessel_function

Examples
--------
&gt;&gt;&gt; np.i0([0.])
array(1.0)
&gt;&gt;&gt; np.i0([0., 1. + 2j])
array([ 1.00000000+0.j        ,  0.18785373+0.64616944j])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="identity"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">identity</span>(<span class="sig-arg">n</span>,
        <span class="sig-arg">dtype</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return the identity array.

The identity array is a square array with ones on
the main diagonal.

Parameters
----------
n : int
    Number of rows (and columns) in `n` x `n` output.
dtype : data-type, optional
    Data-type of the output.  Defaults to ``float``.

Returns
-------
out : ndarray
    `n` x `n` array with its main diagonal set to one,
    and all other elements 0.

Examples
--------
&gt;&gt;&gt; np.identity(3)
array([[ 1.,  0.,  0.],
       [ 0.,  1.,  0.],
       [ 0.,  0.,  1.]])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="imag"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">imag</span>(<span class="sig-arg">val</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return the imaginary part of array.

Parameters
----------
val : array_like
    Input array.

Returns
-------
out : ndarray, real or int
    Real part of each element, same shape as `val`.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="indices"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">indices</span>(<span class="sig-arg">dimensions</span>,
        <span class="sig-arg">dtype</span>=<span class="sig-default">&lt;type 'int'&gt;</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return an array representing the indices of a grid.

Compute an array where the subarrays contain index values 0,1,...
varying only along the corresponding axis.

Parameters
----------
dimensions : sequence of ints
    The shape of the grid.
dtype : optional
    Data_type of the result.

Returns
-------
grid : ndarray
    The array of grid indices,
    ``grid.shape = (len(dimensions),) + tuple(dimensions)``.

See Also
--------
mgrid, meshgrid

Notes
-----
The output shape is obtained by prepending the number of dimensions
in front of the tuple of dimensions, i.e. if `dimensions` is a tuple
``(r0, ..., rN-1)`` of length ``N``, the output shape is
``(N,r0,...,rN-1)``.

The subarrays ``grid[k]`` contains the N-D array of indices along the
``k-th`` axis. Explicitly::

    grid[k,i0,i1,...,iN-1] = ik

Examples
--------
&gt;&gt;&gt; grid = np.indices((2,3))
&gt;&gt;&gt; grid.shape
(2,2,3)
&gt;&gt;&gt; grid[0]        # row indices
array([[0, 0, 0],
       [1, 1, 1]])
&gt;&gt;&gt; grid[1]        # column indices
array([[0, 1, 2],
       [0, 1, 2]])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="info"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">info</span>(<span class="sig-arg">object</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">maxwidth</span>=<span class="sig-default">76</span>,
        <span class="sig-arg">output</span>=<span class="sig-default">&lt;epydoc.docintrospecter._DevNull instance at 0x9c5774c&gt;</span>,
        <span class="sig-arg">toplevel</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string">numpy</code><code class="variable-quote">'</code></span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Get help information for a function, class, or module.

Parameters
----------
object : optional
    Input object to get information about.
maxwidth : int, optional
    Printing width.
output : file like object open for writing, optional
    Write into file like object.
toplevel : string, optional
    Start search at this level.

Examples
--------
&gt;&gt;&gt; np.info(np.polyval) # doctest: +SKIP

   polyval(p, x)

     Evaluate the polymnomial p at x.

     ...

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="inner"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">inner</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">b</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">
Inner product of two arrays.

Ordinary inner product of vectors for 1-D arrays (without complex
conjugation), in higher dimensions a sum product over the last axes.

Parameters
----------
a, b : array_like
    If `a` and `b` are nonscalar, their last dimensions of must match.

Returns
-------
out : ndarray
    `out.shape = a.shape[:-1] + b.shape[:-1]`

Raises
------
ValueError
    If the last dimension of `a` and `b` has different size.

See Also
--------
tensordot : Sum products over arbitrary axes.
dot : Generalised matrix product, using second last dimension of `b`.

Notes
-----
For vectors (1-D arrays) it computes the ordinary inner-product::

    np.inner(a, b) = sum(a[:]*b[:])

More generally, if `ndim(a) = r &gt; 0` and `ndim(b) = s &gt; 0`::

    np.inner(a, b) = np.tensordot(a, b, axes=(-1,-1))

or explicitly::

    np.inner(a, b)[i0,...,ir-1,j0,...,js-1]
         = sum(a[i0,...,ir-1,:]*b[j0,...,js-1,:])

In addition `a` or `b` may be scalars, in which case::

   np.inner(a,b) = a*b

Examples
--------
Ordinary inner product for vectors:

&gt;&gt;&gt; a = np.array([1,2,3])
&gt;&gt;&gt; b = np.array([0,1,0])
&gt;&gt;&gt; np.inner(a, b)
2

A multidimensional example:

&gt;&gt;&gt; a = np.arange(24).reshape((2,3,4))
&gt;&gt;&gt; b = np.arange(4)
&gt;&gt;&gt; np.inner(a, b)
array([[ 14,  38,  62],
       [ 86, 110, 134]])

An example where `b` is a scalar:

&gt;&gt;&gt; np.inner(np.eye(2), 7)
array([[ 7.,  0.],
       [ 0.,  7.]])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="insert"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">insert</span>(<span class="sig-arg">arr</span>,
        <span class="sig-arg">obj</span>,
        <span class="sig-arg">values</span>,
        <span class="sig-arg">axis</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Insert values along the given axis before the given indices.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>arr <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Input array.</dd>
<dt>obj <span class="classifier-delimiter">:</span> <span class="rst-classifier">int, slice, or array of ints</span></dt>
<dd>Insert <code class="link">values</code> before <code class="link">obj</code> indices.</dd>
<dt>values <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Values to insert into <code class="link">arr</code>. If the type of <code class="link">values</code> is different
from that of <code class="link">arr</code>, <code class="link">values</code> is converted to the type of <code class="link">arr</code>.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="rst-classifier">int, optional</span></dt>
<dd>Axis along which to insert <code class="link">values</code>.  If <code class="link">axis</code> is None then <code class="link">arr</code>
is flattened first.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray</span></dt>
<dd>A copy of <code class="link">arr</code> with <code class="link">values</code> inserted.  Note that <code class="link">insert</code>
does not occur in-place: a new array is returned. If
<code class="link">axis</code> is None, <code class="link">out</code> is a flattened array.</dd>
</dl>
</div>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<p>append : Append elements at the end of an array.
delete : Delete elements from an array.</p>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>a = np.array([[1, 1], [2, 2], [3, 3]])
<span class="py-prompt">&gt;&gt;&gt; </span>a
<span class="py-output">array([[1, 1],</span>
<span class="py-output">       [2, 2],</span>
<span class="py-output">       [3, 3]])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.insert(a, 1, 5)
<span class="py-output">array([1, 5, 1, 2, 2, 3, 3])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.insert(a, 1, 5, axis=1)
<span class="py-output">array([[1, 5, 1],</span>
<span class="py-output">       [2, 5, 2],</span>
<span class="py-output">       [3, 5, 3]])</span></pre>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>b = a.flatten()
<span class="py-prompt">&gt;&gt;&gt; </span>b
<span class="py-output">array([1, 1, 2, 2, 3, 3])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.insert(b, [2, 2], [5, 6])
<span class="py-output">array([1, 1, 5, 6, 2, 2, 3, 3])</span></pre>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.insert(b, slice(2, 4), [5, 6])
<span class="py-output">array([1, 1, 5, 2, 6, 2, 3, 3])</span></pre>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.insert(b, [2, 2], [7.13, False])
<span class="py-output">array([1, 1, 7, 0, 2, 2, 3, 3])</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="interp"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">interp</span>(<span class="sig-arg">x</span>,
        <span class="sig-arg">xp</span>,
        <span class="sig-arg">fp</span>,
        <span class="sig-arg">left</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">right</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>One-dimensional linear interpolation.</p>
<p>Returns the one-dimensional piecewise linear interpolant to a function
with given values at discrete data-points.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>x <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>The x-coordinates of the interpolated values.</dd>
<dt>xp <span class="classifier-delimiter">:</span> <span class="rst-classifier">1-D sequence of floats</span></dt>
<dd>The x-coordinates of the data points, must be increasing.</dd>
<dt>fp <span class="classifier-delimiter">:</span> <span class="rst-classifier">1-D sequence of floats</span></dt>
<dd>The y-coordinates of the data points, same length as <code class="link">xp</code>.</dd>
<dt>left <span class="classifier-delimiter">:</span> <span class="rst-classifier">float, optional</span></dt>
<dd>Value to return for <code class="link">x &lt; xp[0]</code>, default is <code class="link">fp[0]</code>.</dd>
<dt>right <span class="classifier-delimiter">:</span> <span class="rst-classifier">float, optional</span></dt>
<dd>Value to return for <code class="link">x &gt; xp[-1]</code>, defaults is <code class="link">fp[-1]</code>.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="rst-classifier">{float, ndarray}</span></dt>
<dd>The interpolated values, same shape as <code class="link">x</code>.</dd>
</dl>
</div>
<div class="rst-section" id="rst-raises">
<h1 class="heading">Raises</h1>
<dl class="rst-docutils">
<dt>ValueError</dt>
<dd>If <code class="link">xp</code> and <code class="link">fp</code> have different length</dd>
</dl>
</div>
<div class="rst-section" id="rst-notes">
<h1 class="heading">Notes</h1>
<p>Does not check that the x-coordinate sequence <code class="link">xp</code> is increasing.
If <code class="link">xp</code> is not increasing, the results are nonsense.
A simple check for increasingness is:</p>
<pre class="rst-literal-block">
np.all(np.diff(xp) &gt; 0)
</pre>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>xp = [1, 2, 3]
<span class="py-prompt">&gt;&gt;&gt; </span>fp = [3, 2, 0]
<span class="py-prompt">&gt;&gt;&gt; </span>np.interp(2.5, xp, fp)
<span class="py-output">1.0</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.interp([0, 1, 1.5, 2.72, 3.14], xp, fp)
<span class="py-output">array([ 3. ,  3. ,  2.5,  0.56,  0. ])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>UNDEF = -99.0
<span class="py-prompt">&gt;&gt;&gt; </span>np.interp(3.14, xp, fp, right=UNDEF)
<span class="py-output">-99.0</span></pre>
<p>Plot an interpolant to the sine function:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>x = np.linspace(0, 2*np.pi, 10)
<span class="py-prompt">&gt;&gt;&gt; </span>y = np.sin(x)
<span class="py-prompt">&gt;&gt;&gt; </span>xvals = np.linspace(0, 2*np.pi, 50)
<span class="py-prompt">&gt;&gt;&gt; </span>yinterp = np.interp(xvals, x, y)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">import</span> matplotlib.pyplot <span class="py-keyword">as</span> plt
<span class="py-prompt">&gt;&gt;&gt; </span>plt.plot(x, y, <span class="py-string">'o'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>plt.plot(xvals, yinterp, <span class="py-string">'-x'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>plt.show()</pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="intersect1d"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">intersect1d</span>(<span class="sig-arg">ar1</span>,
        <span class="sig-arg">ar2</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Intersection returning repeated or unique elements common to both arrays.

Parameters
----------
ar1,ar2 : array_like
    Input arrays.

Returns
-------
out : ndarray, shape(N,)
    Sorted 1D array of common elements with repeating elements.

See Also
--------
intersect1d_nu : Returns only unique common elements.
numpy.lib.arraysetops : Module with a number of other functions for
                        performing set operations on arrays.

Examples
--------
&gt;&gt;&gt; np.intersect1d([1,3,3],[3,1,1])
array([1, 1, 3, 3])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="intersect1d_nu"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">intersect1d_nu</span>(<span class="sig-arg">ar1</span>,
        <span class="sig-arg">ar2</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Intersection returning unique elements common to both arrays.

Parameters
----------
ar1,ar2 : array_like
    Input arrays.

Returns
-------
out : ndarray, shape(N,)
    Sorted 1D array of common and unique elements.

See Also
--------
intersect1d : Returns repeated or unique common elements.
numpy.lib.arraysetops : Module with a number of other functions for
                        performing set operations on arrays.

Examples
--------
&gt;&gt;&gt; np.intersect1d_nu([1,3,3],[3,1,1])
array([1, 3])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="ipmt"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">ipmt</span>(<span class="sig-arg">rate</span>,
        <span class="sig-arg">per</span>,
        <span class="sig-arg">nper</span>,
        <span class="sig-arg">pv</span>,
        <span class="sig-arg">fv</span>=<span class="sig-default">0.0</span>,
        <span class="sig-arg">when</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string">end</code><code class="variable-quote">'</code></span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Not implemented. Compute the payment portion for loan interest.

Parameters
----------
rate : scalar or array_like of shape(M, )
    Rate of interest as decimal (not per cent) per period
per : scalar or array_like of shape(M, )
    Interest paid against the loan changes during the life or the loan.
    The `per` is the payment period to calculate the interest amount.
nper : scalar or array_like of shape(M, )
    Number of compounding periods
pv : scalar or array_like of shape(M, )
    Present value
fv : scalar or array_like of shape(M, ), optional
    Future value
when : {{'begin', 1}, {'end', 0}}, {string, int}, optional
    When payments are due ('begin' (1) or 'end' (0)).
    Defaults to {'end', 0}.

Returns
-------
out : ndarray
    Interest portion of payment.  If all input is scalar, returns a scalar
    float.  If any input is array_like, returns interest payment for each
    input element. If multiple inputs are array_like, they all must have
    the same shape.

See Also
--------
ppmt, pmt, pv

Notes
-----
The total payment is made up of payment against principal plus interest.

``pmt = ppmt + ipmt``

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="irr"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">irr</span>(<span class="sig-arg">values</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return the Internal Rate of Return (IRR).

This is the rate of return that gives a net present value of 0.0.

Parameters
----------
values : array_like, shape(N,)
    Input cash flows per time period.  At least the first value would be
    negative to represent the investment in the project.

Returns
-------
out : float
    Internal Rate of Return for periodic input values.

Examples
--------
&gt;&gt;&gt; np.irr([-100, 39, 59, 55, 20])
0.2809484211599611

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="iscomplex"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">iscomplex</span>(<span class="sig-arg">x</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Returns a bool array, where True if input element is complex.

What is tested is whether the input has a non-zero imaginary part, not if
the input type is complex.

Parameters
----------
x : array_like
    Input array.

Returns
-------
out : ndarray, bool
    Output array.

See Also
--------
isreal: Returns a bool array, where True if input element is real.
iscomplexobj: Return True if x is a complex type or an array of complex
              numbers.

Examples
--------
&gt;&gt;&gt; np.iscomplex([1+1j, 1+0j, 4.5, 3, 2, 2j])
array([ True, False, False, False, False,  True], dtype=bool)

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="iscomplexobj"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">iscomplexobj</span>(<span class="sig-arg">x</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return True if x is a complex type or an array of complex numbers.

The type of the input is checked, not the value. So even if the input
has an imaginary part equal to zero, `iscomplexobj` evaluates to True
if the data type is complex.

Parameters
----------
x : any
    The input can be of any type and shape.

Returns
-------
y : bool
    The return value, True if `x` is of a complex type.

See Also
--------
isrealobj, iscomplex

Examples
--------
&gt;&gt;&gt; np.iscomplexobj(1)
False
&gt;&gt;&gt; np.iscomplexobj(1+0j)
True
np.iscomplexobj([3, 1+0j, True])
True

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="isfortran"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">isfortran</span>(<span class="sig-arg">a</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Returns True if array is arranged in Fortran-order in memory
and dimension &gt; 1.

Parameters
----------
a : ndarray
    Input array.


Examples
--------

np.array allows to specify whether the array is written in C-contiguous
order (last index varies the fastest), or FORTRAN-contiguous order in
memory (first index varies the fastest).

&gt;&gt;&gt; a = np.array([[1, 2, 3], [4, 5, 6]], order='C')
&gt;&gt;&gt; a
array([[1, 2, 3],
       [4, 5, 6]])
&gt;&gt;&gt; np.isfortran(a)
False

&gt;&gt;&gt; b = np.array([[1, 2, 3], [4, 5, 6]], order='FORTRAN')
&gt;&gt;&gt; b
array([[1, 2, 3],
       [4, 5, 6]])
&gt;&gt;&gt; np.isfortran(b)
True


The transpose of a C-ordered array is a FORTRAN-ordered array.

&gt;&gt;&gt; a = np.array([[1, 2, 3], [4, 5, 6]], order='C')
&gt;&gt;&gt; a
array([[1, 2, 3],
       [4, 5, 6]])
&gt;&gt;&gt; np.isfortran(a)
False
&gt;&gt;&gt; b = a.T
&gt;&gt;&gt; b
array([[1, 4],
       [2, 5],
       [3, 6]])
&gt;&gt;&gt; np.isfortran(b)
True

1-D arrays always evaluate as False.

&gt;&gt;&gt; np.isfortran(np.array([1, 2], order='FORTRAN'))
False

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="isneginf"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">isneginf</span>(<span class="sig-arg">x</span>,
        <span class="sig-arg">y</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Test element-wise for negative infinity, return result as bool array.

Parameters
----------
x : array_like
    The input array.
y : array_like, optional
    A boolean array with the same shape and type as `x` to store the
    result.

Returns
-------
y : ndarray
    A boolean array with the same dimensions as the input.
    If second argument is not supplied then a numpy boolean array is
    returned with values True where the corresponding element of the
    input is negative infinity and values False where the element of
    the input is not negative infinity.

    If a second argument is supplied the result is stored there. If the
    type of that array is a numeric type the result is represented as
    zeros and ones, if the type is boolean then as False and True. The
    return value `y` is then a reference to that array.

See Also
--------
isinf, isposinf, isnan, isfinite

Notes
-----
Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754).

Errors result if the second argument is also supplied when x is a scalar
input, or if first and second arguments have different shapes.

Examples
--------
&gt;&gt;&gt; np.isneginf(np.NINF)
array(True, dtype=bool)
&gt;&gt;&gt; np.isneginf(np.inf)
array(False, dtype=bool)
&gt;&gt;&gt; np.isneginf(np.PINF)
array(False, dtype=bool)
&gt;&gt;&gt; np.isneginf([-np.inf, 0., np.inf])
array([ True, False, False], dtype=bool)

&gt;&gt;&gt; x = np.array([-np.inf, 0., np.inf])
&gt;&gt;&gt; y = np.array([2, 2, 2])
&gt;&gt;&gt; np.isneginf(x, y)
array([1, 0, 0])
&gt;&gt;&gt; y
array([1, 0, 0])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="isposinf"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">isposinf</span>(<span class="sig-arg">x</span>,
        <span class="sig-arg">y</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Test element-wise for positive infinity, return result as bool array.

Parameters
----------
x : array_like
    The input array.
y : array_like, optional
    A boolean array with the same shape as `x` to store the result.

Returns
-------
y : ndarray
    A boolean array with the same dimensions as the input.
    If second argument is not supplied then a boolean array is returned
    with values True where the corresponding element of the input is
    positive infinity and values False where the element of the input is
    not positive infinity.

    If a second argument is supplied the result is stored there. If the
    type of that array is a numeric type the result is represented as zeros
    and ones, if the type is boolean then as False and True.
    The return value `y` is then a reference to that array.

See Also
--------
isinf, isneginf, isfinite, isnan

Notes
-----
Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754).

Errors result if the second argument is also supplied when `x` is a
scalar input, or if first and second arguments have different shapes.

Examples
--------
&gt;&gt;&gt; np.isposinf(np.PINF)
array(True, dtype=bool)
&gt;&gt;&gt; np.isposinf(np.inf)
array(True, dtype=bool)
&gt;&gt;&gt; np.isposinf(np.NINF)
array(False, dtype=bool)
&gt;&gt;&gt; np.isposinf([-np.inf, 0., np.inf])
array([False, False,  True], dtype=bool)

&gt;&gt;&gt; x = np.array([-np.inf, 0., np.inf])
&gt;&gt;&gt; y = np.array([2, 2, 2])
&gt;&gt;&gt; np.isposinf(x, y)
array([1, 0, 0])
&gt;&gt;&gt; y
array([1, 0, 0])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="isreal"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">isreal</span>(<span class="sig-arg">x</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Returns a bool array, where True if input element is real.

If the input value has a complex type but with complex part zero, the
return value is True.

Parameters
----------
x : array_like
    Input array.

Returns
-------
out : ndarray, bool
    Boolean array of same shape as `x`.

See Also
--------
iscomplex: Return a bool array, where True if input element is complex
           (non-zero imaginary part).
isrealobj: Return True if x is not a complex type.

Examples
--------
&gt;&gt;&gt; np.isreal([1+1j, 1+0j, 4.5, 3, 2, 2j])
&gt;&gt;&gt; array([False,  True,  True,  True,  True, False], dtype=bool)

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="isrealobj"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">isrealobj</span>(<span class="sig-arg">x</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return True if x is a not complex type or an array of complex numbers.

The type of the input is checked, not the value. So even if the input
has an imaginary part equal to zero, `isrealobj` evaluates to False
if the data type is complex.

Parameters
----------
x : any
    The input can be of any type and shape.

Returns
-------
y : bool
    The return value, False if `x` is of a complex type.

See Also
--------
iscomplexobj, isreal

Examples
--------
&gt;&gt;&gt; np.isrealobj(1)
True
&gt;&gt;&gt; np.isrealobj(1+0j)
False
&gt;&gt;&gt; np.isrealobj([3, 1+0j, True])
False

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="isscalar"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">isscalar</span>(<span class="sig-arg">num</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Returns True if the type of `num` is a scalar type.

Parameters
----------
num : any
    Input argument, can be of any type and shape.

Returns
-------
val : bool
    True if `num` is a scalar type, False if it is not.

Examples
--------
&gt;&gt;&gt; np.isscalar(3.1)
True
&gt;&gt;&gt; np.isscalar([3.1])
False
&gt;&gt;&gt; np.isscalar(False)
True

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="issubdtype"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">issubdtype</span>(<span class="sig-arg">arg1</span>,
        <span class="sig-arg">arg2</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Returns True if first argument is a typecode lower/equal in type hierarchy.

Parameters
----------
arg1 : dtype_like
    dtype or string representing a typecode.
arg2 : dtype_like
    dtype or string representing a typecode.


See Also
--------
numpy.core.numerictypes : Overview of numpy type hierarchy.

Examples
--------
&gt;&gt;&gt; np.issubdtype('S1', str)
True
&gt;&gt;&gt; np.issubdtype(np.float64, np.float32)
False

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="ix_"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">ix_</span>(<span class="sig-arg">*args</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Construct an open mesh from multiple sequences.</p>
  <p>This function takes n 1-d sequences and returns n outputs with n 
  dimensions each such that the shape is 1 in all but one dimension and the
  dimension with the non-unit shape value cycles through all n 
  dimensions.</p>
  <p>Using ix_() one can quickly construct index arrays that will index the
  cross product.</p>
  <p>a[ix_([1,3,7],[2,5,8])]  returns the array</p>
  <p>a[1,2]  a[1,5]  a[1,8] a[3,2]  a[3,5]  a[3,8] a[7,2]  a[7,5]  
  a[7,8]</p>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="kaiser"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">kaiser</span>(<span class="sig-arg">M</span>,
        <span class="sig-arg">beta</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return the Kaiser window.

The Kaiser window is a taper formed by using a Bessel function.

Parameters
----------
M : int
    Number of points in the output window. If zero or less, an
    empty array is returned.
beta : float
    Shape parameter for window.

Returns
-------
out : array
    The window, normalized to one (the value one
    appears only if the number of samples is odd).

See Also
--------
bartlett, blackman, hamming, hanning

Notes
-----
The Kaiser window is defined as

.. math::  w(n) = I_0\left( \beta \sqrt{1-\frac{4n^2}{(M-1)^2}}
           \right)/I_0(\beta)

with

.. math:: \quad -\frac{M-1}{2} \leq n \leq \frac{M-1}{2},

where :math:`I_0` is the modified zeroth-order Bessel function.

The Kaiser was named for Jim Kaiser, who discovered a simple approximation
to the DPSS window based on Bessel functions.
The Kaiser window is a very good approximation to the Digital Prolate
Spheroidal Sequence, or Slepian window, which is the transform which
maximizes the energy in the main lobe of the window relative to total
energy.

The Kaiser can approximate many other windows by varying the beta
parameter.

====  =======================
beta  Window shape
====  =======================
0     Rectangular
5     Similar to a Hamming
6     Similar to a Hanning
8.6   Similar to a Blackman
====  =======================

A beta value of 14 is probably a good starting point. Note that as beta
gets large, the window narrows, and so the number of samples needs to be
large enough to sample the increasingly narrow spike, otherwise nans will
get returned.


Most references to the Kaiser window come from the signal processing
literature, where it is used as one of many windowing functions for
smoothing values.  It is also known as an apodization (which means
&quot;removing the foot&quot;, i.e. smoothing discontinuities at the beginning
and end of the sampled signal) or tapering function.

References
----------
.. [1] J. F. Kaiser, &quot;Digital Filters&quot; - Ch 7 in &quot;Systems analysis by
       digital computer&quot;, Editors: F.F. Kuo and J.F. Kaiser, p 218-285.
       John Wiley and Sons, New York, (1966).
.. [2] E.R. Kanasewich, &quot;Time Sequence Analysis in Geophysics&quot;, The
       University of Alberta Press, 1975, pp. 177-178.
.. [3] Wikipedia, &quot;Window function&quot;,
       http://en.wikipedia.org/wiki/Window_function

Examples
--------
&gt;&gt;&gt; from numpy import kaiser
&gt;&gt;&gt; kaiser(12, 14)
array([  7.72686684e-06,   3.46009194e-03,   4.65200189e-02,
         2.29737120e-01,   5.99885316e-01,   9.45674898e-01,
         9.45674898e-01,   5.99885316e-01,   2.29737120e-01,
         4.65200189e-02,   3.46009194e-03,   7.72686684e-06])


Plot the window and the frequency response:

&gt;&gt;&gt; from numpy import clip, log10, array, kaiser
&gt;&gt;&gt; from scipy.fftpack import fft, fftshift
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; window = kaiser(51, 14)
&gt;&gt;&gt; plt.plot(window)
&gt;&gt;&gt; plt.title(&quot;Kaiser window&quot;)
&gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;)
&gt;&gt;&gt; plt.xlabel(&quot;Sample&quot;)
&gt;&gt;&gt; plt.show()

&gt;&gt;&gt; A = fft(window, 2048) / 25.5
&gt;&gt;&gt; mag = abs(fftshift(A))
&gt;&gt;&gt; freq = linspace(-0.5,0.5,len(A))
&gt;&gt;&gt; response = 20*log10(mag)
&gt;&gt;&gt; response = clip(response,-100,100)
&gt;&gt;&gt; plt.plot(freq, response)
&gt;&gt;&gt; plt.title(&quot;Frequency response of Kaiser window&quot;)
&gt;&gt;&gt; plt.ylabel(&quot;Magnitude [dB]&quot;)
&gt;&gt;&gt; plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;)
&gt;&gt;&gt; plt.axis('tight'); plt.show()

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="kron"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">kron</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">b</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Kronecker product of two arrays.

Computes the Kronecker product, a composite array made of blocks of the
second array scaled by the first.

Parameters
----------
a, b : array_like

Returns
-------
out : ndarray

See Also
--------

outer : The outer product

Notes
-----

The function assumes that the number of dimenensions of `a` and `b`
are the same, if necessary prepending the smallest with ones.
If `a.shape = (r0,r1,..,rN)` and `b.shape = (s0,s1,...,sN)`,
the Kronecker product has shape `(r0*s0, r1*s1, ..., rN*SN)`.
The elements are products of elements from `a` and `b`, organized
explicitly by::

    kron(a,b)[k0,k1,...,kN] = a[i0,i1,...,iN] * b[j0,j1,...,jN]

where::

    kt = it * st + jt,  t = 0,...,N

In the common 2-D case (N=1), the block structure can be visualized::

    [[ a[0,0]*b,   a[0,1]*b,  ... , a[0,-1]*b  ],
     [  ...                              ...   ],
     [ a[-1,0]*b,  a[-1,1]*b, ... , a[-1,-1]*b ]]


Examples
--------
&gt;&gt;&gt; np.kron([1,10,100], [5,6,7])
array([  5,   6,   7,  50,  60,  70, 500, 600, 700])
&gt;&gt;&gt; np.kron([5,6,7], [1,10,100])
array([  5,  50, 500,   6,  60, 600,   7,  70, 700])

&gt;&gt;&gt; np.kron(np.eye(2), np.ones((2,2)))
array([[ 1.,  1.,  0.,  0.],
       [ 1.,  1.,  0.,  0.],
       [ 0.,  0.,  1.,  1.],
       [ 0.,  0.,  1.,  1.]])

&gt;&gt;&gt; a = np.arange(100).reshape((2,5,2,5))
&gt;&gt;&gt; b = np.arange(24).reshape((2,3,4))
&gt;&gt;&gt; c = np.kron(a,b)
&gt;&gt;&gt; c.shape
(2, 10, 6, 20)
&gt;&gt;&gt; I = (1,3,0,2)
&gt;&gt;&gt; J = (0,2,1)
&gt;&gt;&gt; J1 = (0,) + J             # extend to ndim=4
&gt;&gt;&gt; S1 = (1,) + b.shape
&gt;&gt;&gt; K = tuple(np.array(I) * np.array(S1) + np.array(J1))
&gt;&gt;&gt; C[K] == A[I]*B[J]
True

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="lexsort"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">lexsort</span>(<span class="sig-arg">keys</span>,
        <span class="sig-arg">axis</span>=<span class="sig-default">-1</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">
Perform an indirect sort using a sequence of keys.

Given multiple sorting keys, which can be interpreted as columns in a
spreadsheet, lexsort returns an array of integer indices that describes
the sort order by multiple columns. The last key in the sequence is used
for the primary sort order, the second-to-last key for the secondary sort
order, and so on. The keys argument must be a sequence of objects that
can be converted to arrays of the same shape. If a 2D array is provided
for the keys argument, it's rows are interpreted as the sorting keys and
sorting is according to the last row, second last row etc.

Parameters
----------
keys : (k,N) array or tuple containing k (N,)-shaped sequences
    The `k` different &quot;columns&quot; to be sorted.  The last column (or row if
    `keys` is a 2D array) is the primary sort key.
axis : int, optional
    Axis to be indirectly sorted.  By default, sort over the last axis.

Returns
-------
indices : (N,) ndarray of ints
    Array of indices that sort the keys along the specified axis.

See Also
--------
argsort : Indirect sort.
ndarray.sort : In-place sort.
sort : Return a sorted copy of an array.

Examples
--------
Sort names: first by surname, then by name.

&gt;&gt;&gt; surnames =    ('Hertz',    'Galilei', 'Hertz')
&gt;&gt;&gt; first_names = ('Heinrich', 'Galileo', 'Gustav')
&gt;&gt;&gt; ind = np.lexsort((first_names, surnames))
&gt;&gt;&gt; ind
array([1, 2, 0])

&gt;&gt;&gt; [surnames[i] + &quot;, &quot; + first_names[i] for i in ind]
['Galilei, Galileo', 'Hertz, Gustav', 'Hertz, Heinrich']

Sort two columns of numbers:

&gt;&gt;&gt; a = [1,5,1,4,3,4,4] # First column
&gt;&gt;&gt; b = [9,4,0,4,0,2,1] # Second column
&gt;&gt;&gt; ind = np.lexsort((b,a)) # Sort by a, then by b
&gt;&gt;&gt; print ind
[2 0 4 6 5 3 1]

&gt;&gt;&gt; [(a[i],b[i]) for i in ind]
[(1, 0), (1, 9), (3, 0), (4, 1), (4, 2), (4, 4), (5, 4)]

Note that sorting is first according to the elements of ``a``.
Secondary sorting is according to the elements of ``b``.

A normal ``argsort`` would have yielded:

&gt;&gt;&gt; [(a[i],b[i]) for i in np.argsort(a)]
[(1, 9), (1, 0), (3, 0), (4, 4), (4, 2), (4, 1), (5, 4)]

Structured arrays are sorted lexically by ``argsort``:

&gt;&gt;&gt; x = np.array([(1,9), (5,4), (1,0), (4,4), (3,0), (4,2), (4,1)],
...              dtype=np.dtype([('x', int), ('y', int)]))

&gt;&gt;&gt; np.argsort(x) # or np.argsort(x, order=('x', 'y'))
array([2, 0, 4, 6, 5, 3, 1])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="linspace"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">linspace</span>(<span class="sig-arg">start</span>,
        <span class="sig-arg">stop</span>,
        <span class="sig-arg">num</span>=<span class="sig-default">50</span>,
        <span class="sig-arg">endpoint</span>=<span class="sig-default">True</span>,
        <span class="sig-arg">retstep</span>=<span class="sig-default">False</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return evenly spaced numbers over a specified interval.</p>
<p>Returns <code class="link">num</code> evenly spaced samples, calculated over the
interval [<code class="link">start</code>, <code class="link">stop</code> ].</p>
<p>The endpoint of the interval can optionally be excluded.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>start <span class="classifier-delimiter">:</span> <span class="rst-classifier">scalar</span></dt>
<dd>The starting value of the sequence.</dd>
<dt>stop <span class="classifier-delimiter">:</span> <span class="rst-classifier">scalar</span></dt>
<dd>The end value of the sequence, unless <code class="link">endpoint</code> is set to False.
In that case, the sequence consists of all but the last of <tt class="rst-docutils literal"><span class="pre">num</span> <span class="pre">+</span> <span class="pre">1</span></tt>
evenly spaced samples, so that <code class="link">stop</code> is excluded.  Note that the step
size changes when <code class="link">endpoint</code> is False.</dd>
<dt>num <span class="classifier-delimiter">:</span> <span class="rst-classifier">int, optional</span></dt>
<dd>Number of samples to generate. Default is 50.</dd>
<dt>endpoint <span class="classifier-delimiter">:</span> <span class="rst-classifier">bool, optional</span></dt>
<dd>If True, <code class="link">stop</code> is the last sample. Otherwise, it is not included.
Default is True.</dd>
<dt>retstep <span class="classifier-delimiter">:</span> <span class="rst-classifier">bool, optional</span></dt>
<dd>If True, return (<code class="link">samples</code>, <code class="link">step</code>), where <code class="link">step</code> is the spacing
between samples.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>samples <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray</span></dt>
<dd>There are <code class="link">num</code> equally spaced samples in the closed interval
<tt class="rst-docutils literal"><span class="pre">[start,</span> <span class="pre">stop]</span></tt> or the half-open interval <tt class="rst-docutils literal"><span class="pre">[start,</span> <span class="pre">stop)</span></tt>
(depending on whether <code class="link">endpoint</code> is True or False).</dd>
<dt>step <span class="classifier-delimiter">:</span> <span class="rst-classifier">float (only if <code class="link">retstep</code> is True)</span></dt>
<dd>Size of spacing between samples.</dd>
</dl>
</div>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<dl class="rst-docutils">
<dt>arange <span class="classifier-delimiter">:</span> <span class="rst-classifier">Similiar to <code class="link">linspace</code>, but uses a step size (instead of the</span></dt>
<dd>number of samples).</dd>
</dl>
<p>logspace : Samples uniformly distributed in log space.</p>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.linspace(2.0, 3.0, num=5)
<span class="py-output">    array([ 2.  ,  2.25,  2.5 ,  2.75,  3.  ])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.linspace(2.0, 3.0, num=5, endpoint=False)
<span class="py-output">    array([ 2. ,  2.2,  2.4,  2.6,  2.8])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.linspace(2.0, 3.0, num=5, retstep=True)
<span class="py-output">    (array([ 2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)</span></pre>
<p>Graphical illustration:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">import</span> matplotlib.pyplot <span class="py-keyword">as</span> plt
<span class="py-prompt">&gt;&gt;&gt; </span>N = 8
<span class="py-prompt">&gt;&gt;&gt; </span>y = np.zeros(N)
<span class="py-prompt">&gt;&gt;&gt; </span>x1 = np.linspace(0, 10, N, endpoint=True)
<span class="py-prompt">&gt;&gt;&gt; </span>x2 = np.linspace(0, 10, N, endpoint=False)
<span class="py-prompt">&gt;&gt;&gt; </span>plt.plot(x1, y, <span class="py-string">'o'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>plt.plot(x2, y + 0.5, <span class="py-string">'o'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>plt.ylim([-0.5, 1])
<span class="py-prompt">&gt;&gt;&gt; </span>plt.show()</pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="load"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">load</span>(<span class="sig-arg">file</span>,
        <span class="sig-arg">mmap_mode</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Load a pickled, ``.npy``, or ``.npz`` binary file.

Parameters
----------
file : file-like object or string
    The file to read.  It must support ``seek()`` and ``read()`` methods.
mmap_mode: {None, 'r+', 'r', 'w+', 'c'}, optional
    If not None, then memory-map the file, using the given mode
    (see `numpy.memmap`).  The mode has no effect for pickled or
    zipped files.
    A memory-mapped array is stored on disk, and not directly loaded
    into memory.  However, it can be accessed and sliced like any
    ndarray.  Memory mapping is especially useful for accessing
    small fragments of large files without reading the entire file
    into memory.

Returns
-------
result : array, tuple, dict, etc.
    Data stored in the file.

Raises
------
IOError
    If the input file does not exist or cannot be read.

Notes
-----
- If the file contains pickle data, then whatever is stored in the
  pickle is returned.
- If the file is a ``.npy`` file, then an array is returned.
- If the file is a ``.npz`` file, then a dictionary-like object is
  returned, containing ``{filename: array}`` key-value pairs, one for
  each file in the archive.

Examples
--------
Store data to disk, and load it again:

&gt;&gt;&gt; np.save('/tmp/123', np.array([[1, 2, 3], [4, 5, 6]]))
&gt;&gt;&gt; np.load('/tmp/123.npy')
array([[1, 2, 3],
       [4, 5, 6]])

Mem-map the stored array, and then access the second row
directly from disk:

&gt;&gt;&gt; X = np.load('/tmp/123.npy', mmap_mode='r')
&gt;&gt;&gt; X[1, :]
memmap([4, 5, 6])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="loadtxt"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">loadtxt</span>(<span class="sig-arg">fname</span>,
        <span class="sig-arg">dtype</span>=<span class="sig-default">&lt;type 'float'&gt;</span>,
        <span class="sig-arg">comments</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string">#</code><code class="variable-quote">'</code></span>,
        <span class="sig-arg">delimiter</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">converters</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">skiprows</span>=<span class="sig-default">0</span>,
        <span class="sig-arg">usecols</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">unpack</span>=<span class="sig-default">False</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Load data from a text file.

Each row in the text file must have the same number of values.

Parameters
----------
fname : file or string
    File or filename to read.  If the filename extension is ``.gz`` or
    ``.bz2``, the file is first decompressed.
dtype : data-type
    Data type of the resulting array.  If this is a record data-type,
    the resulting array will be 1-dimensional, and each row will be
    interpreted as an element of the array.   In this case, the number
    of columns used must match the number of fields in the data-type.
comments : string, optional
    The character used to indicate the start of a comment.
delimiter : string, optional
    The string used to separate values.  By default, this is any
    whitespace.
converters : {}
    A dictionary mapping column number to a function that will convert
    that column to a float.  E.g., if column 0 is a date string:
    ``converters = {0: datestr2num}``. Converters can also be used to
    provide a default value for missing data:
    ``converters = {3: lambda s: float(s or 0)}``.
skiprows : int
    Skip the first `skiprows` lines.
usecols : sequence
    Which columns to read, with 0 being the first.  For example,
    ``usecols = (1,4,5)`` will extract the 2nd, 5th and 6th columns.
unpack : bool
    If True, the returned array is transposed, so that arguments may be
    unpacked using ``x, y, z = loadtxt(...)``

Returns
-------
out : ndarray
    Data read from the text file.

See Also
--------
scipy.io.loadmat : reads Matlab(R) data files

Examples
--------
&gt;&gt;&gt; from StringIO import StringIO   # StringIO behaves like a file object
&gt;&gt;&gt; c = StringIO(&quot;0 1\n2 3&quot;)
&gt;&gt;&gt; np.loadtxt(c)
array([[ 0.,  1.],
       [ 2.,  3.]])

&gt;&gt;&gt; d = StringIO(&quot;M 21 72\nF 35 58&quot;)
&gt;&gt;&gt; np.loadtxt(d, dtype={'names': ('gender', 'age', 'weight'),
...                      'formats': ('S1', 'i4', 'f4')})
array([('M', 21, 72.0), ('F', 35, 58.0)],
      dtype=[('gender', '|S1'), ('age', '&lt;i4'), ('weight', '&lt;f4')])

&gt;&gt;&gt; c = StringIO(&quot;1,0,2\n3,0,4&quot;)
&gt;&gt;&gt; x,y = np.loadtxt(c, delimiter=',', usecols=(0,2), unpack=True)
&gt;&gt;&gt; x
array([ 1.,  3.])
&gt;&gt;&gt; y
array([ 2.,  4.])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="log2"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">log2</span>(<span class="sig-arg">x</span>,
        <span class="sig-arg">y</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return the base 2 logarithm.

Parameters
----------
x : array_like
  Input array.
y : array_like
  Optional output array with the same shape as `x`.

Returns
-------
y : ndarray
  The logarithm to the base 2 of `x` elementwise.
  NaNs are returned where `x` is negative.

See Also
--------
log, log1p, log10

Examples
--------
&gt;&gt;&gt; np.log2([-1,2,4])
array([ NaN,   1.,   2.])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="logspace"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">logspace</span>(<span class="sig-arg">start</span>,
        <span class="sig-arg">stop</span>,
        <span class="sig-arg">num</span>=<span class="sig-default">50</span>,
        <span class="sig-arg">endpoint</span>=<span class="sig-default">True</span>,
        <span class="sig-arg">base</span>=<span class="sig-default">10.0</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return numbers spaced evenly on a log scale.</p>
<p>In linear space, the sequence starts at <tt class="rst-docutils literal"><span class="pre">base</span> <span class="pre">**</span> <span class="pre">start</span></tt>
(<code class="link">base</code> to the power of <code class="link">start</code>) and ends with <tt class="rst-docutils literal"><span class="pre">base</span> <span class="pre">**</span> <span class="pre">stop</span></tt>
(see <code class="link">endpoint</code> below).</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>start <span class="classifier-delimiter">:</span> <span class="rst-classifier">float</span></dt>
<dd><tt class="rst-docutils literal"><span class="pre">base</span> <span class="pre">**</span> <span class="pre">start</span></tt> is the starting value of the sequence.</dd>
<dt>stop <span class="classifier-delimiter">:</span> <span class="rst-classifier">float</span></dt>
<dd><tt class="rst-docutils literal"><span class="pre">base</span> <span class="pre">**</span> <span class="pre">stop</span></tt> is the final value of the sequence, unless <code class="link">endpoint</code>
is False.  In that case, <tt class="rst-docutils literal"><span class="pre">num</span> <span class="pre">+</span> <span class="pre">1</span></tt> values are spaced over the
interval in log-space, of which all but the last (a sequence of
length <tt class="rst-docutils literal"><span class="pre">num</span></tt>) are returned.</dd>
<dt>num <span class="classifier-delimiter">:</span> <span class="rst-classifier">integer, optional</span></dt>
<dd>Number of samples to generate.  Default is 50.</dd>
<dt>endpoint <span class="classifier-delimiter">:</span> <span class="rst-classifier">boolean, optional</span></dt>
<dd>If true, <code class="link">stop</code> is the last sample. Otherwise, it is not included.
Default is True.</dd>
<dt>base <span class="classifier-delimiter">:</span> <span class="rst-classifier">float, optional</span></dt>
<dd>The base of the log space. The step size between the elements in
<tt class="rst-docutils literal"><span class="pre">ln(samples)</span> <span class="pre">/</span> <span class="pre">ln(base)</span></tt> (or <tt class="rst-docutils literal"><span class="pre">log_base(samples)</span></tt>) is uniform.
Default is 10.0.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>samples <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray</span></dt>
<dd><code class="link">num</code> samples, equally spaced on a log scale.</dd>
</dl>
</div>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<dl class="rst-docutils">
<dt>arange <span class="classifier-delimiter">:</span> <span class="rst-classifier">Similiar to linspace, with the step size specified instead of the</span></dt>
<dd>number of samples. Note that, when used with a float endpoint, the
endpoint may or may not be included.</dd>
<dt>linspace <span class="classifier-delimiter">:</span> <span class="rst-classifier">Similar to logspace, but with the samples uniformly distributed</span></dt>
<dd>in linear space, instead of log space.</dd>
</dl>
</div>
<div class="rst-section" id="rst-notes">
<h1 class="heading">Notes</h1>
<p>Logspace is equivalent to the code</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>y = linspace(start, stop, num=num, endpoint=endpoint)
<span class="py-prompt">&gt;&gt;&gt; </span>power(base, y)</pre>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.logspace(2.0, 3.0, num=4)
<span class="py-output">    array([  100.        ,   215.443469  ,   464.15888336,  1000.        ])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.logspace(2.0, 3.0, num=4, endpoint=False)
<span class="py-output">    array([ 100.        ,  177.827941  ,  316.22776602,  562.34132519])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.logspace(2.0, 3.0, num=4, base=2.0)
<span class="py-output">    array([ 4.        ,  5.0396842 ,  6.34960421,  8.        ])</span></pre>
<p>Graphical illustration:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">import</span> matplotlib.pyplot <span class="py-keyword">as</span> plt
<span class="py-prompt">&gt;&gt;&gt; </span>N = 10
<span class="py-prompt">&gt;&gt;&gt; </span>x1 = np.logspace(0.1, 1, N, endpoint=True)
<span class="py-prompt">&gt;&gt;&gt; </span>x2 = np.logspace(0.1, 1, N, endpoint=False)
<span class="py-prompt">&gt;&gt;&gt; </span>y = np.zeros(N)
<span class="py-prompt">&gt;&gt;&gt; </span>plt.plot(x1, y, <span class="py-string">'o'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>plt.plot(x2, y + 0.5, <span class="py-string">'o'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>plt.ylim([-0.5, 1])
<span class="py-prompt">&gt;&gt;&gt; </span>plt.show()</pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="lookfor"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">lookfor</span>(<span class="sig-arg">what</span>,
        <span class="sig-arg">module</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">import_modules</span>=<span class="sig-default">True</span>,
        <span class="sig-arg">regenerate</span>=<span class="sig-default">False</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Do a keyword search on docstrings.

A list of of objects that matched the search is displayed,
sorted by relevance.

Parameters
----------
what : str
    String containing words to look for.
module : str, module
    Module whose docstrings to go through.
import_modules : bool
    Whether to import sub-modules in packages.
    Will import only modules in ``__all__``.
regenerate : bool
    Whether to re-generate the docstring cache.

Examples
--------

&gt;&gt;&gt; np.lookfor('binary representation')
Search results for 'binary representation'
------------------------------------------
numpy.binary_repr
    Return the binary representation of the input number as a string.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="mafromtxt"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">mafromtxt</span>(<span class="sig-arg">fname</span>,
        <span class="sig-arg">dtype</span>=<span class="sig-default">&lt;type 'float'&gt;</span>,
        <span class="sig-arg">comments</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string">#</code><code class="variable-quote">'</code></span>,
        <span class="sig-arg">delimiter</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">skiprows</span>=<span class="sig-default">0</span>,
        <span class="sig-arg">converters</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">missing</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string"></code><code class="variable-quote">'</code></span>,
        <span class="sig-arg">missing_values</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">usecols</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">unpack</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">names</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">excludelist</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">deletechars</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">case_sensitive</span>=<span class="sig-default">True</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Load ASCII data stored in fname and returns a MaskedArray.

Complete description of all the optional input parameters is available in
the docstring of the `genfromtxt` function.

See Also
--------
numpy.genfromtxt : generic function.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="mat"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">mat</span>(<span class="sig-arg">data</span>,
        <span class="sig-arg">dtype</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Interpret the input as a matrix.

Unlike `matrix`, `asmatrix` does not make a copy if the input is already
a matrix or an ndarray.  Equivalent to ``matrix(data, copy=False)``.

Parameters
----------
data : array_like
    Input data.

Returns
-------
mat : matrix
    `data` interpreted as a matrix.

Examples
--------
&gt;&gt;&gt; x = np.array([[1, 2], [3, 4]])

&gt;&gt;&gt; m = np.asmatrix(x)

&gt;&gt;&gt; x[0,0] = 5

&gt;&gt;&gt; m
matrix([[5, 2],
        [3, 4]])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="may_share_memory"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">may_share_memory</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">b</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Determine if two arrays can share memory</p>
  <p>The memory-bounds of a and b are computed.  If they overlap then this 
  function returns True.  Otherwise, it returns False.</p>
  <p>A return of True does not necessarily mean that the two arrays share 
  any element.  It just means that they *might*.</p>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="mean"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">mean</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">axis</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">dtype</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">out</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Compute the arithmetic mean along the specified axis.</p>
<p>Returns the average of the array elements.  The average is taken
over the flattened array by default, otherwise over the specified
axis. float64 intermediate and return values are used for integer
inputs.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Array containing numbers whose mean is desired. If <code class="link">a</code> is not an
array, a conversion is attempted.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="rst-classifier">int, optional</span></dt>
<dd>Axis along which the means are computed. The default is to compute
the mean of the flattened array.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="rst-classifier">dtype, optional</span></dt>
<dd>Type to use in computing the mean. For integer inputs, the default
is float64; for floating point, inputs it is the same as the input
dtype.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray, optional</span></dt>
<dd>Alternative output array in which to place the result. It must have
the same shape as the expected output but the type will be cast if
necessary.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>mean <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray, see dtype parameter above</span></dt>
<dd>If <code class="link">out=None</code>, returns a new array containing the mean values,
otherwise a reference to the output array is returned.</dd>
</dl>
</div>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<p>average : Weighted average</p>
</div>
<div class="rst-section" id="rst-notes">
<h1 class="heading">Notes</h1>
<p>The arithmetic mean is the sum of the elements along the axis divided
by the number of elements.</p>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>a = np.array([[1,2],[3,4]])
<span class="py-prompt">&gt;&gt;&gt; </span>np.mean(a)
<span class="py-output">2.5</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.mean(a,0)
<span class="py-output">array([ 2.,  3.])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.mean(a,1)
<span class="py-output">array([ 1.5,  3.5])</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="median"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">median</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">axis</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">out</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">overwrite_input</span>=<span class="sig-default">False</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Compute the median along the specified axis.</p>
<p>Returns the median of the array elements.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Input array or object that can be converted to an array.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="rst-classifier">{None, int}, optional</span></dt>
<dd>Axis along which the medians are computed. The default (axis=None)
is to compute the median along a flattened version of the array.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray, optional</span></dt>
<dd>Alternative output array in which to place the result. It must
have the same shape and buffer length as the expected output,
but the type (of the output) will be cast if necessary.</dd>
<dt>overwrite_input <span class="classifier-delimiter">:</span> <span class="rst-classifier">{False, True}, optional</span></dt>
<dd>If True, then allow use of memory of input array (a) for
calculations. The input array will be modified by the call to
median. This will save memory when you do not need to preserve
the contents of the input array. Treat the input as undefined,
but it will probably be fully or partially sorted. Default is
False. Note that, if <code class="link">overwrite_input</code> is True and the input
is not already an ndarray, an error will be raised.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>median <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray</span></dt>
<dd>A new array holding the result (unless <code class="link">out</code> is specified, in
which case that array is returned instead).  If the input contains
integers, or floats of smaller precision than 64, then the output
data-type is float64.  Otherwise, the output data-type is the same
as that of the input.</dd>
</dl>
</div>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<p>mean</p>
</div>
<div class="rst-section" id="rst-notes">
<h1 class="heading">Notes</h1>
<p>Given a vector V of length N, the median of V is the middle value of
a sorted copy of V, <tt class="rst-docutils literal"><span class="pre">V_sorted</span></tt> - i.e., <tt class="rst-docutils literal"><span class="pre">V_sorted[(N-1)/2]</span></tt>, when N is
odd.  When N is even, it is the average of the two middle values of
<tt class="rst-docutils literal"><span class="pre">V_sorted</span></tt>.</p>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>a = np.array([[10, 7, 4], [3, 2, 1]])
<span class="py-prompt">&gt;&gt;&gt; </span>a
<span class="py-output">array([[10,  7,  4],</span>
<span class="py-output">       [ 3,  2,  1]])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.median(a)
<span class="py-output">3.5</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.median(a, axis=0)
<span class="py-output">array([ 6.5,  4.5,  2.5])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.median(a, axis=1)
<span class="py-output">array([ 7.,  2.])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>m = np.median(a, axis=0)
<span class="py-prompt">&gt;&gt;&gt; </span>out = np.zeros_like(m)
<span class="py-prompt">&gt;&gt;&gt; </span>np.median(a, axis=0, out=m)
<span class="py-output">array([ 6.5,  4.5,  2.5])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>m
<span class="py-output">array([ 6.5,  4.5,  2.5])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>b = a.copy()
<span class="py-prompt">&gt;&gt;&gt; </span>np.median(b, axis=1, overwrite_input=True)
<span class="py-output">array([ 7.,  2.])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>assert <span class="py-keyword">not</span> np.all(a==b)
<span class="py-prompt">&gt;&gt;&gt; </span>b = a.copy()
<span class="py-prompt">&gt;&gt;&gt; </span>np.median(b, axis=None, overwrite_input=True)
<span class="py-output">3.5</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>assert <span class="py-keyword">not</span> np.all(a==b)</pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="meshgrid"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">meshgrid</span>(<span class="sig-arg">x</span>,
        <span class="sig-arg">y</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return coordinate matrices from two coordinate vectors.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>x, y <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray</span></dt>
<dd>Two 1-D arrays representing the x and y coordinates of a grid.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>X, Y <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray</span></dt>
<dd>For vectors <code class="link">x</code>, <code class="link">y</code> with lengths <tt class="rst-docutils literal"><span class="pre">Nx=len(x)</span></tt> and <tt class="rst-docutils literal"><span class="pre">Ny=len(y)</span></tt>,
return <code class="link">X</code>, <code class="link">Y</code> where <code class="link">X</code> and <code class="link">Y</code> are <tt class="rst-docutils literal"><span class="pre">(Ny,</span> <span class="pre">Nx)</span></tt> shaped arrays
with the elements of <code class="link">x</code> and y repeated to fill the matrix along
the first dimension for <code class="link">x</code>, the second for <code class="link">y</code>.</dd>
</dl>
</div>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<dl class="rst-docutils">
<dt>index_tricks.mgrid <span class="classifier-delimiter">:</span> <span class="rst-classifier">Construct a multi-dimensional &quot;meshgrid&quot;</span></dt>
<dd>using indexing notation.</dd>
<dt>index_tricks.ogrid <span class="classifier-delimiter">:</span> <span class="rst-classifier">Construct an open multi-dimensional &quot;meshgrid&quot;</span></dt>
<dd>using indexing notation.</dd>
</dl>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>X, Y = np.meshgrid([1,2,3], [4,5,6,7])
<span class="py-prompt">&gt;&gt;&gt; </span>X
<span class="py-output">array([[1, 2, 3],</span>
<span class="py-output">       [1, 2, 3],</span>
<span class="py-output">       [1, 2, 3],</span>
<span class="py-output">       [1, 2, 3]])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>Y
<span class="py-output">array([[4, 4, 4],</span>
<span class="py-output">       [5, 5, 5],</span>
<span class="py-output">       [6, 6, 6],</span>
<span class="py-output">       [7, 7, 7]])</span></pre>
<p><code class="link">meshgrid</code> is very useful to evaluate functions on a grid.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>x = np.arange(-5, 5, 0.1)
<span class="py-prompt">&gt;&gt;&gt; </span>y = np.arange(-5, 5, 0.1)
<span class="py-prompt">&gt;&gt;&gt; </span>xx, yy = np.meshgrid(x, y)
<span class="py-prompt">&gt;&gt;&gt; </span>z = np.sin(xx**2+yy**2)/(xx**2+yy**2)</pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="mintypecode"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">mintypecode</span>(<span class="sig-arg">typechars</span>,
        <span class="sig-arg">typeset</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string">GDFgdf</code><code class="variable-quote">'</code></span>,
        <span class="sig-arg">default</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string">d</code><code class="variable-quote">'</code></span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return a minimum data type character from typeset that handles all 
  typechars given</p>
  <p>The returned type character must be the smallest size such that an 
  array of the returned type can handle the data from an array of type t 
  for each t in typechars (or if typechars is an array, then its 
  dtype.char).</p>
  <p>If the typechars does not intersect with the typeset, then default is 
  returned.</p>
  <p>If t in typechars is not a string then t=asarray(t).dtype.char is 
  applied.</p>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="mirr"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">mirr</span>(<span class="sig-arg">values</span>,
        <span class="sig-arg">finance_rate</span>,
        <span class="sig-arg">reinvest_rate</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Modified internal rate of return.

Parameters
----------
values : array_like
    Cash flows (must contain at least one positive and one negative value)
    or nan is returned.
finance_rate : scalar
    Interest rate paid on the cash flows
reinvest_rate : scalar
    Interest rate received on the cash flows upon reinvestment

Returns
-------
out : float
    Modified internal rate of return

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="msort"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">msort</span>(<span class="sig-arg">a</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return a copy of an array sorted along the first axis.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Array to be sorted.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>sorted_array <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray</span></dt>
<dd>Array of the same type and shape as <code class="link">a</code>.</dd>
</dl>
</div>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<p>sort</p>
</div>
<div class="rst-section" id="rst-notes">
<h1 class="heading">Notes</h1>
<p><tt class="rst-docutils literal"><span class="pre">np.msort(a)</span></tt> is equivalent to  <tt class="rst-docutils literal"><span class="pre">np.sort(a,</span> <span class="pre">axis=0)</span></tt>.</p>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="nan_to_num"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">nan_to_num</span>(<span class="sig-arg">x</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Replace nan with zero and inf with finite numbers.

Returns an array or scalar replacing Not a Number (NaN) with zero,
(positive) infinity with a very large number and negative infinity
with a very small (or negative) number.

Parameters
----------
x : array_like
    Input data.

Returns
-------
out : ndarray, float
    Array with the same shape as `x` and dtype of the element in `x`  with
    the greatest precision. NaN is replaced by zero, and infinity
    (-infinity) is replaced by the largest (smallest or most negative)
    floating point value that fits in the output dtype. All finite numbers
    are upcast to the output dtype (default float64).

See Also
--------
isinf : Shows which elements are negative or negative infinity.
isneginf : Shows which elements are negative infinity.
isposinf : Shows which elements are positive infinity.
isnan : Shows which elements are Not a Number (NaN).
isfinite : Shows which elements are finite (not NaN, not infinity)

Notes
-----
Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754). This means that Not a Number is not equivalent to infinity.


Examples
--------
&gt;&gt;&gt; x = np.array([np.inf, -np.inf, np.nan, -128, 128])
&gt;&gt;&gt; np.nan_to_num(x)
array([  1.79769313e+308,  -1.79769313e+308,   0.00000000e+000,
        -1.28000000e+002,   1.28000000e+002])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="nanargmax"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">nanargmax</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">axis</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return indices of the maximum values over an axis, ignoring NaNs.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Input data.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="rst-classifier">int, optional</span></dt>
<dd>Axis along which to operate.  By default flattened input is used.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>index_array <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray</span></dt>
<dd>An array of indices or a single index value.</dd>
</dl>
</div>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<p>argmax, nanargmin</p>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>a = np.array([[np.nan, 4], [2, 3]])
<span class="py-prompt">&gt;&gt;&gt; </span>np.argmax(a)
<span class="py-output">0</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.nanargmax(a)
<span class="py-output">1</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.nanargmax(a, axis=0)
<span class="py-output">array([1, 1])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.nanargmax(a, axis=1)
<span class="py-output">array([1, 0])</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="nanargmin"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">nanargmin</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">axis</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return indices of the minimum values along an axis, ignoring NaNs.</p>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<p>nanargmax : corresponding function for maxima; see for details.</p>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="nanmax"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">nanmax</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">axis</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return the maximum of array elements over the given axis ignoring any NaNs.

Parameters
----------
a : array_like
    Array containing numbers whose maximum is desired. If `a` is not
    an array, a conversion is attempted.
axis : int, optional
    Axis along which the maximum is computed.The default is to compute
    the maximum of the flattened array.

Returns
-------
y : ndarray
    An array with the same shape as `a`, with the specified axis removed.
    If `a` is a 0-d array, or if axis is None, a scalar is returned. The
    the same dtype as `a` is returned.

See Also
--------
numpy.amax : Maximum across array including any Not a Numbers.
numpy.nanmin : Minimum across array ignoring any Not a Numbers.
isnan : Shows which elements are Not a Number (NaN).
isfinite: Shows which elements are not: Not a Number, positive and
         negative infinity

Notes
-----
Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754). This means that Not a Number is not equivalent to infinity.
Positive infinity is treated as a very large number and negative infinity
is treated as a very small (i.e. negative) number.

If the input has a integer type, an integer type is returned unless
the input contains NaNs and infinity.

Examples
--------
&gt;&gt;&gt; a = np.array([[1, 2], [3, np.nan]])
&gt;&gt;&gt; np.nanmax(a)
3.0
&gt;&gt;&gt; np.nanmax(a, axis=0)
array([ 3.,  2.])
&gt;&gt;&gt; np.nanmax(a, axis=1)
array([ 2.,  3.])

When positive infinity and negative infinity are present:

&gt;&gt;&gt; np.nanmax([1, 2, np.nan, np.NINF])
2.0
&gt;&gt;&gt; np.nanmax([1, 2, np.nan, np.inf])
inf

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="nanmin"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">nanmin</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">axis</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return the minimum of array elements over the given axis ignoring any NaNs.

Parameters
----------
a : array_like
    Array containing numbers whose sum is desired. If `a` is not
    an array, a conversion is attempted.
axis : int, optional
    Axis along which the minimum is computed.The default is to compute
    the minimum of the flattened array.

Returns
-------
y : {ndarray, scalar}
    An array with the same shape as `a`, with the specified axis removed.
    If `a` is a 0-d array, or if axis is None, a scalar is returned. The
    the same dtype as `a` is returned.


See Also
--------
numpy.amin : Minimum across array including any Not a Numbers.
numpy.nanmax : Maximum across array ignoring any Not a Numbers.
isnan : Shows which elements are Not a Number (NaN).
isfinite: Shows which elements are not: Not a Number, positive and
         negative infinity

Notes
-----
Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754). This means that Not a Number is not equivalent to infinity.
Positive infinity is treated as a very large number and negative infinity
is treated as a very small (i.e. negative) number.

If the input has a integer type, an integer type is returned unless
the input contains NaNs and infinity.


Examples
--------
&gt;&gt;&gt; a = np.array([[1, 2], [3, np.nan]])
&gt;&gt;&gt; np.nanmin(a)
1.0
&gt;&gt;&gt; np.nanmin(a, axis=0)
array([ 1.,  2.])
&gt;&gt;&gt; np.nanmin(a, axis=1)
array([ 1.,  3.])

When positive infinity and negative infinity are present:

&gt;&gt;&gt; np.nanmin([1, 2, np.nan, np.inf])
1.0
&gt;&gt;&gt; np.nanmin([1, 2, np.nan, np.NINF])
-inf

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="nansum"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">nansum</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">axis</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return the sum of array elements over a given axis treating
Not a Numbers (NaNs) as zero.

Parameters
----------
a : array_like
    Array containing numbers whose sum is desired. If `a` is not an
    array, a conversion is attempted.
axis : int, optional
    Axis along which the sum is computed. The default is to compute
    the sum of the flattened array.

Returns
-------
y : ndarray
    An array with the same shape as a, with the specified axis removed.
    If a is a 0-d array, or if axis is None, a scalar is returned with
    the same dtype as `a`.

See Also
--------
numpy.sum : Sum across array including Not a Numbers.
isnan : Shows which elements are Not a Number (NaN).
isfinite: Shows which elements are not: Not a Number, positive and
         negative infinity

Notes
-----
Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754). This means that Not a Number is not equivalent to infinity.
If positive or negative infinity are present the result is positive or
negative infinity. But if both positive and negative infinity are present,
the result is Not A Number (NaN).

Arithmetic is modular when using integer types (all elements of `a` must
be finite i.e. no elements that are NaNs, positive infinity and negative
infinity because NaNs are floating point types), and no error is raised
on overflow.


Examples
--------
&gt;&gt;&gt; np.nansum(1)
1
&gt;&gt;&gt; np.nansum([1])
1
&gt;&gt;&gt; np.nansum([1, np.nan])
1.0
&gt;&gt;&gt; a = np.array([[1, 1], [1, np.nan]])
&gt;&gt;&gt; np.nansum(a)
3.0
&gt;&gt;&gt; np.nansum(a, axis=0)
array([ 2.,  1.])

When positive infinity and negative infinity are present

&gt;&gt;&gt; np.nansum([1, np.nan, np.inf])
inf
&gt;&gt;&gt; np.nansum([1, np.nan, np.NINF])
-inf
&gt;&gt;&gt; np.nansum([1, np.nan, np.inf, np.NINF])
nan

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="ndfromtxt"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">ndfromtxt</span>(<span class="sig-arg">fname</span>,
        <span class="sig-arg">dtype</span>=<span class="sig-default">&lt;type 'float'&gt;</span>,
        <span class="sig-arg">comments</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string">#</code><code class="variable-quote">'</code></span>,
        <span class="sig-arg">delimiter</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">skiprows</span>=<span class="sig-default">0</span>,
        <span class="sig-arg">converters</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">missing</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string"></code><code class="variable-quote">'</code></span>,
        <span class="sig-arg">missing_values</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">usecols</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">unpack</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">names</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">excludelist</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">deletechars</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">case_sensitive</span>=<span class="sig-default">True</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Load ASCII data stored in fname and returns a ndarray.

Complete description of all the optional input parameters is available in
the docstring of the `genfromtxt` function.

See Also
--------
numpy.genfromtxt : generic function.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="ndim"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">ndim</span>(<span class="sig-arg">a</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return the number of dimensions of an array.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Input array.  If it is not already an ndarray, a conversion is
attempted.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>number_of_dimensions <span class="classifier-delimiter">:</span> <span class="rst-classifier">int</span></dt>
<dd>The number of dimensions in <code class="link">a</code>.  Scalars are zero-dimensional.</dd>
</dl>
</div>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<p>ndarray.ndim : equivalent method
shape : dimensions of array
ndarray.shape : dimensions of array</p>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.ndim([[1,2,3],[4,5,6]])
<span class="py-output">2</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.ndim(np.array([[1,2,3],[4,5,6]]))
<span class="py-output">2</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.ndim(1)
<span class="py-output">0</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="nonzero"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">nonzero</span>(<span class="sig-arg">a</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return the indices of the elements that are non-zero.</p>
<p>Returns a tuple of arrays, one for each dimension of <code class="link">a</code>, containing
the indices of the non-zero elements in that dimension. The
corresponding non-zero values can be obtained with:</p>
<pre class="rst-literal-block">
a[nonzero(a)]
</pre>
<p>To group the indices by element, rather than dimension, use:</p>
<pre class="rst-literal-block">
transpose(nonzero(a))
</pre>
<p>The result of this is always a 2-D array, with a row for
each non-zero element.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Input array.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>tuple_of_arrays <span class="classifier-delimiter">:</span> <span class="rst-classifier">tuple</span></dt>
<dd>Indices of elements that are non-zero.</dd>
</dl>
</div>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<dl class="rst-docutils">
<dt>flatnonzero :</dt>
<dd>Return indices that are non-zero in the flattened version of the input
array.</dd>
<dt>ndarray.nonzero :</dt>
<dd>Equivalent ndarray method.</dd>
</dl>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>x = np.eye(3)
<span class="py-prompt">&gt;&gt;&gt; </span>x
<span class="py-output">array([[ 1.,  0.,  0.],</span>
<span class="py-output">       [ 0.,  1.,  0.],</span>
<span class="py-output">       [ 0.,  0.,  1.]])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.nonzero(x)
<span class="py-output">(array([0, 1, 2]), array([0, 1, 2]))</span></pre>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>x[np.nonzero(x)]
<span class="py-output">array([ 1.,  1.,  1.])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.transpose(np.nonzero(x))
<span class="py-output">array([[0, 0],</span>
<span class="py-output">       [1, 1],</span>
<span class="py-output">       [2, 2]])</span></pre>
<p>A common use for <tt class="rst-docutils literal"><span class="pre">nonzero</span></tt> is to find the indices of an array, where
a condition is True.  Given an array <code class="link">a</code>, the condition <code class="link">a</code> &gt; 3 is a
boolean array and since False is interpreted as 0, np.nonzero(a &gt; 3)
yields the indices of the <code class="link">a</code> where the condition is true.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>a = np.array([[1,2,3],[4,5,6],[7,8,9]])
<span class="py-prompt">&gt;&gt;&gt; </span>a &gt; 3
<span class="py-output">array([[False, False, False],</span>
<span class="py-output">       [ True,  True,  True],</span>
<span class="py-output">       [ True,  True,  True]], dtype=bool)</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.nonzero(a &gt; 3)
<span class="py-output">(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))</span></pre>
<p>The <tt class="rst-docutils literal"><span class="pre">nonzero</span></tt> method of the boolean array can also be called.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>(a &gt; 3).nonzero()
<span class="py-output">(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="nper"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">nper</span>(<span class="sig-arg">rate</span>,
        <span class="sig-arg">pmt</span>,
        <span class="sig-arg">pv</span>,
        <span class="sig-arg">fv</span>=<span class="sig-default">0</span>,
        <span class="sig-arg">when</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string">end</code><code class="variable-quote">'</code></span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Compute the number of periods.

Parameters
----------
rate : array_like
    Rate of interest (per period)
pmt : array_like
    Payment
pv : array_like
    Present value
fv : array_like, optional
    Future value
when : {{'begin', 1}, {'end', 0}}, {string, int}, optional
    When payments are due ('begin' (1) or 'end' (0))

Notes
-----
The number of periods ``nper`` is computed by solving the equation::

  fv + pv*(1+rate)**nper + pmt*(1+rate*when)/rate * ((1+rate)**nper - 1) == 0

or, when ``rate == 0``::

  fv + pv + pmt * nper == 0

Examples
--------
If you only had $150 to spend as payment, how long would it take to pay-off
a loan of $8,000 at 7% annual interest?

&gt;&gt;&gt; np.nper(0.07/12, -150, 8000)
64.073348770661852

So, over 64 months would be required to pay off the loan.

The same analysis could be done with several different interest rates
and/or payments and/or total amounts to produce an entire table.

&gt;&gt;&gt; np.nper(*(np.ogrid[0.06/12:0.071/12:0.01/12, -200:-99:100, 6000:7001:1000]))
array([[[ 32.58497782,  38.57048452],
        [ 71.51317802,  86.37179563]],
       [[ 33.07413144,  39.26244268],
        [ 74.06368256,  90.22989997]]])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="npv"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">npv</span>(<span class="sig-arg">rate</span>,
        <span class="sig-arg">values</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Returns the NPV (Net Present Value) of a cash flow series.

Parameters
----------
rate : scalar
    The discount rate.
values : array_like, shape(M, )
    The values of the time series of cash flows.  Must be the same
    increment as the `rate`.

Returns
-------
out : float
    The NPV of the input cash flow series `values` at the discount `rate`.

Notes
-----
Returns the result of:

.. math :: \sum_{t=1}^M{\frac{values_t}{(1+rate)^{t}}}

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="ones"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">ones</span>(<span class="sig-arg">shape</span>,
        <span class="sig-arg">dtype</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">order</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string">C</code><code class="variable-quote">'</code></span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return a new array of given shape and type, filled with ones.

Please refer to the documentation for `zeros`.

See Also
--------
zeros

Examples
--------
&gt;&gt;&gt; np.ones(5)
array([ 1.,  1.,  1.,  1.,  1.])

&gt;&gt;&gt; np.ones((5,), dtype=np.int)
array([1, 1, 1, 1, 1])

&gt;&gt;&gt; np.ones((2, 1))
array([[ 1.],
       [ 1.]])

&gt;&gt;&gt; s = (2,2)
&gt;&gt;&gt; np.ones(s)
array([[ 1.,  1.],
       [ 1.,  1.]])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="outer"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">outer</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">b</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Returns the outer product of two vectors.

Given two vectors, ``[a0, a1, ..., aM]`` and ``[b0, b1, ..., bN]``,
the outer product becomes::

  [[a0*b0  a0*b1 ... a0*bN ]
   [a1*b0    .
   [ ...          .
   [aM*b0            aM*bN ]]

Parameters
----------
a : array_like, shaped (M,)
    First input vector.  If either of the input vectors are not
    1-dimensional, they are flattened.
b : array_like, shaped (N,)
    Second input vector.

Returns
-------
out : ndarray, shaped (M, N)
    ``out[i, j] = a[i] * b[j]``

Notes
-----
The outer product of vectors is a special case of the Kronecker product.

Examples
--------
&gt;&gt;&gt; x = np.array(['a', 'b', 'c'], dtype=object)

&gt;&gt;&gt; np.outer(x, [1, 2, 3])
array([[a, aa, aaa],
       [b, bb, bbb],
       [c, cc, ccc]], dtype=object)

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="packbits"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">packbits</span>(<span class="sig-arg">myarray</span>,
        <span class="sig-arg">axis</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">
Packs the elements of a binary-valued array into bits in a uint8 array.

The result is padded to full bytes by inserting zero bits at the end.

Parameters
----------
myarray : array_like
    An integer type array whose elements should be packed to bits.
axis : int, optional
    The dimension over which bit-packing is done.
    ``None`` implies packing the flattened array.

Returns
-------
packed : ndarray
    Array of type uint8 whose elements represent bits corresponding to the
    logical (0 or nonzero) value of the input elements. The shape of
    `packed` has the same number of dimensions as the input (unless `axis`
    is None, in which case the output is 1-D).

See Also
--------
unpackbits: Unpacks elements of a uint8 array into a binary-valued output
            array.

Examples
--------
&gt;&gt;&gt; a = np.array([[[1,0,1],
...                [0,1,0]],
...               [[1,1,0],
...                [0,0,1]]])
&gt;&gt;&gt; b = np.packbits(a, axis=-1)
&gt;&gt;&gt; b
array([[[160],[64]],[[192],[32]]], dtype=uint8)

Note that in binary 160 = 1010 0000, 64 = 0100 0000, 192 = 1100 0000,
and 32 = 0010 0000.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="piecewise"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">piecewise</span>(<span class="sig-arg">x</span>,
        <span class="sig-arg">condlist</span>,
        <span class="sig-arg">funclist</span>,
        <span class="sig-arg">*args</span>,
        <span class="sig-arg">**kw</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Evaluate a piecewise-defined function.</p>
<p>Given a set of conditions and corresponding functions, evaluate each
function on the input data wherever its condition is true.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>x <span class="classifier-delimiter">:</span> <span class="rst-classifier">(N,) ndarray</span></dt>
<dd>The input domain.</dd>
<dt>condlist <span class="classifier-delimiter">:</span> <span class="rst-classifier">list of M (N,)-shaped boolean arrays</span></dt>
<dd><p class="rst-first">Each boolean array corresponds to a function in <code class="link">funclist</code>.  Wherever
<code class="link">condlist[i]</code> is True, <code class="link">funclist[i](x)</code> is used as the output value.</p>
<p>Each boolean array in <code class="link">condlist</code> selects a piece of <code class="link">x</code>,
and should therefore be of the same shape as <code class="link">x</code>.</p>
<p class="rst-last">The length of <code class="link">condlist</code> must correspond to that of <code class="link">funclist</code>.
If one extra function is given, i.e. if the length of <code class="link">funclist</code> is
M+1, then that extra function is the default value, used wherever
all conditions are false.</p>
</dd>
<dt>funclist <span class="classifier-delimiter">:</span> <span class="rst-classifier">list of M or M+1 callables, f(x,*args,**kw), or values</span></dt>
<dd>Each function is evaluated over <code class="link">x</code> wherever its corresponding
condition is True.  It should take an array as input and give an array
or a scalar value as output.  If, instead of a callable,
a value is provided then a constant function (<tt class="rst-docutils literal"><span class="pre">lambda</span> <span class="pre">x:</span> <span class="pre">value</span></tt>) is
assumed.</dd>
<dt>args <span class="classifier-delimiter">:</span> <span class="rst-classifier">tuple, optional</span></dt>
<dd>Any further arguments given to <code class="link">piecewise</code> are passed to the functions
upon execution, i.e., if called <tt class="rst-docutils literal"><span class="pre">piecewise(...,...,1,'a')</span></tt>, then
each function is called as <tt class="rst-docutils literal"><span class="pre">f(x,1,'a')</span></tt>.</dd>
<dt>kw <span class="classifier-delimiter">:</span> <span class="rst-classifier">dictionary, optional</span></dt>
<dd>Keyword arguments used in calling <code class="link">piecewise</code> are passed to the
functions upon execution, i.e., if called
<tt class="rst-docutils literal"><span class="pre">piecewise(...,...,lambda=1)</span></tt>, then each function is called as
<tt class="rst-docutils literal"><span class="pre">f(x,lambda=1)</span></tt>.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray</span></dt>
<dd>The output is the same shape and type as x and is found by
calling the functions in <code class="link">funclist</code> on the appropriate portions of <code class="link">x</code>,
as defined by the boolean arrays in <code class="link">condlist</code>.  Portions not covered
by any condition have undefined values.</dd>
</dl>
</div>
<div class="rst-section" id="rst-notes">
<h1 class="heading">Notes</h1>
<p>This is similar to choose or select, except that functions are
evaluated on elements of <code class="link">x</code> that satisfy the corresponding condition from
<code class="link">condlist</code>.</p>
<p>The result is:</p>
<pre class="rst-literal-block">
      |--
      |funclist[0](x[condlist[0]])
out = |funclist[1](x[condlist[1]])
      |...
      |funclist[n2](x[condlist[n2]])
      |--
</pre>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<p>Define the sigma function, which is -1 for <tt class="rst-docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">0</span></tt> and +1 for <tt class="rst-docutils literal"><span class="pre">x</span> <span class="pre">&gt;=</span> <span class="pre">0</span></tt>.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>x = np.arange(6) - 2.5 <span class="py-comment"># x runs from -2.5 to 2.5 in steps of 1</span>
<span class="py-prompt">&gt;&gt;&gt; </span>np.piecewise(x, [x &lt; 0, x &gt;= 0.5], [-1,1])
<span class="py-output">array([-1., -1., -1.,  1.,  1.,  1.])</span></pre>
<p>Define the absolute value, which is <tt class="rst-docutils literal"><span class="pre">-x</span></tt> for <tt class="rst-docutils literal"><span class="pre">x</span> <span class="pre">&lt;0</span></tt> and <tt class="rst-docutils literal"><span class="pre">x</span></tt> for
<tt class="rst-docutils literal"><span class="pre">x</span> <span class="pre">&gt;=</span> <span class="pre">0</span></tt>.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.piecewise(x, [x &lt; 0, x &gt;= 0], [<span class="py-keyword">lambda</span> x: -x, <span class="py-keyword">lambda</span> x: x])
<span class="py-output">array([ 2.5,  1.5,  0.5,  0.5,  1.5,  2.5])</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="pkgload"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">pkgload</span>(<span class="sig-arg">*packages</span>,
        <span class="sig-arg">**options</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="numpy-pysrc.html#pkgload">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">
Load one or more packages into parent package top-level namespace.

This function is intended to shorten the need to import many
subpackages, say of scipy, constantly with statements such as

  import scipy.linalg, scipy.fftpack, scipy.etc...

Instead, you can say:

  import scipy
  scipy.pkgload('linalg','fftpack',...)

or

  scipy.pkgload()

to load all of them in one call.

If a name which doesn't exist in scipy's namespace is
given, a warning is shown.

Parameters
----------
 *packages : arg-tuple
      the names (one or more strings) of all the modules one
      wishes to load into the top-level namespace.
 verbose= : integer
      verbosity level [default: -1].
      verbose=-1 will suspend also warnings.
 force= : bool
      when True, force reloading loaded packages [default: False].
 postpone= : bool
      when True, don't load packages [default: False]

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="place"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">place</span>(<span class="sig-arg">arr</span>,
        <span class="sig-arg">mask</span>,
        <span class="sig-arg">vals</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Changes elements of an array based on conditional and input values.</p>
<p>Similar to <tt class="rst-docutils literal"><span class="pre">putmask(a,</span> <span class="pre">mask,</span> <span class="pre">vals)</span></tt> but the 1D array <code class="link">vals</code> has the
same number of elements as the non-zero values of <code class="link">mask</code>. Inverse of
<tt class="rst-docutils literal"><span class="pre">extract</span></tt>.</p>
<p>Sets <code class="link">a</code>.flat[n] = <code class="link">values</code>[n] for each n where <code class="link">mask</code>.flat[n] is true.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Array to put data into.</dd>
<dt>mask <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Boolean mask array.</dd>
<dt>values <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like, shape(number of non-zero <code class="link">mask</code>, )</span></dt>
<dd>Values to put into <code class="link">a</code>.</dd>
</dl>
</div>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<p>putmask, put, take</p>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="pmt"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">pmt</span>(<span class="sig-arg">rate</span>,
        <span class="sig-arg">nper</span>,
        <span class="sig-arg">pv</span>,
        <span class="sig-arg">fv</span>=<span class="sig-default">0</span>,
        <span class="sig-arg">when</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string">end</code><code class="variable-quote">'</code></span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Compute the payment against loan principal plus interest.

Parameters
----------
rate : array_like
    Rate of interest (per period)
nper : array_like
    Number of compounding periods
pv : array_like
    Present value
fv : array_like
    Future value
when : {{'begin', 1}, {'end', 0}}, {string, int}
    When payments are due ('begin' (1) or 'end' (0))

Returns
-------
out : ndarray
    Payment against loan plus interest.  If all input is scalar, returns a
    scalar float.  If any input is array_like, returns payment for each
    input element. If multiple inputs are array_like, they all must have
    the same shape.

Notes
-----
The payment ``pmt`` is computed by solving the equation::

 fv +
 pv*(1 + rate)**nper +
 pmt*(1 + rate*when)/rate*((1 + rate)**nper - 1) == 0

or, when ``rate == 0``::

  fv + pv + pmt * nper == 0

Examples
--------
What would the monthly payment need to be to pay off a $200,000 loan in 15
years at an annual interest rate of 7.5%?

&gt;&gt;&gt; np.pmt(0.075/12, 12*15, 200000)
-1854.0247200054619

In order to pay-off (i.e. have a future-value of 0) the $200,000 obtained
today, a monthly payment of $1,854.02 would be required.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="poly"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">poly</span>(<span class="sig-arg">seq_of_zeros</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return polynomial coefficients given a sequence of roots.

Calculate the coefficients of a polynomial given the zeros
of the polynomial.

If a square matrix is given, then the coefficients for
characteristic equation of the matrix, defined by
:math:`\mathrm{det}(\mathbf{A} - \lambda \mathbf{I})`,
are returned.

Parameters
----------
seq_of_zeros : ndarray
    A sequence of polynomial roots or a square matrix.

Returns
-------
coefs : ndarray
    A sequence of polynomial coefficients representing the polynomial

    :math:`\mathrm{coefs}[0] x^{n-1} + \mathrm{coefs}[1] x^{n-2} +
                  ... + \mathrm{coefs}[2] x + \mathrm{coefs}[n]`

See Also
--------
numpy.poly1d : A one-dimensional polynomial class.
numpy.roots : Return the roots of the polynomial coefficients in p
numpy.polyfit : Least squares polynomial fit

Examples
--------
Given a sequence of polynomial zeros,

&gt;&gt;&gt; b = np.roots([1, 3, 1, 5, 6])
&gt;&gt;&gt; np.poly(b)
array([ 1.,  3.,  1.,  5.,  6.])

Given a square matrix,

&gt;&gt;&gt; P = np.array([[19, 3], [-2, 26]])
&gt;&gt;&gt; np.poly(P)
array([   1.,  -45.,  500.])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="polyadd"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">polyadd</span>(<span class="sig-arg">a1</span>,
        <span class="sig-arg">a2</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Returns sum of two polynomials.

Returns sum of polynomials; `a1` + `a2`.  Input polynomials are
represented as an array_like sequence of terms or a poly1d object.

Parameters
----------
a1 : {array_like, poly1d}
    Polynomial as sequence of terms.
a2 : {array_like, poly1d}
    Polynomial as sequence of terms.

Returns
-------
out : {ndarray, poly1d}
    Array representing the polynomial terms.

See Also
--------
polyval, polydiv, polymul, polyadd

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="polyder"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">polyder</span>(<span class="sig-arg">p</span>,
        <span class="sig-arg">m</span>=<span class="sig-default">1</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return the derivative of the specified order of a polynomial.

Parameters
----------
p : poly1d or sequence
    Polynomial to differentiate.
    A sequence is interpreted as polynomial coefficients, see `poly1d`.
m : int, optional
    Order of differentiation (default: 1)

Returns
-------
der : poly1d
    A new polynomial representing the derivative.

See Also
--------
polyint : Anti-derivative of a polynomial.
poly1d : Class for one-dimensional polynomials.

Examples
--------
The derivative of the polynomial :math:`x^3 + x^2 + x^1 + 1` is:

&gt;&gt;&gt; p = np.poly1d([1,1,1,1])
&gt;&gt;&gt; p2 = np.polyder(p)
&gt;&gt;&gt; p2
poly1d([3, 2, 1])

which evaluates to:

&gt;&gt;&gt; p2(2.)
17.0

We can verify this, approximating the derivative with
``(f(x + h) - f(x))/h``:

&gt;&gt;&gt; (p(2. + 0.001) - p(2.)) / 0.001
17.007000999997857

The fourth-order derivative of a 3rd-order polynomial is zero:

&gt;&gt;&gt; np.polyder(p, 2)
poly1d([6, 2])
&gt;&gt;&gt; np.polyder(p, 3)
poly1d([6])
&gt;&gt;&gt; np.polyder(p, 4)
poly1d([ 0.])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="polydiv"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">polydiv</span>(<span class="sig-arg">u</span>,
        <span class="sig-arg">v</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Returns the quotient and remainder of polynomial division.

The input arrays specify the polynomial terms in turn with a length equal
to the polynomial degree plus 1.

Parameters
----------
u : {array_like, poly1d}
    Dividend polynomial.
v : {array_like, poly1d}
    Divisor polynomial.

Returns
-------
q : ndarray
    Polynomial terms of quotient.
r : ndarray
    Remainder of polynomial division.

See Also
--------
poly, polyadd, polyder, polydiv, polyfit, polyint, polymul, polysub,
polyval

Examples
--------
.. math:: \frac{3x^2 + 5x + 2}{2x + 1} = 1.5x + 1.75, remainder 0.25

&gt;&gt;&gt; x = np.array([3.0, 5.0, 2.0])
&gt;&gt;&gt; y = np.array([2.0, 1.0])
&gt;&gt;&gt; np.polydiv(x, y)
&gt;&gt;&gt; (array([ 1.5 ,  1.75]), array([ 0.25]))

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="polyfit"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">polyfit</span>(<span class="sig-arg">x</span>,
        <span class="sig-arg">y</span>,
        <span class="sig-arg">deg</span>,
        <span class="sig-arg">rcond</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">full</span>=<span class="sig-default">False</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Least squares polynomial fit.

Fit a polynomial ``p(x) = p[0] * x**deg + ... + p[deg]`` of degree `deg`
to points `(x, y)`. Returns a vector of coefficients `p` that minimises
the squared error.

Parameters
----------
x : array_like, shape (M,)
    x-coordinates of the M sample points ``(x[i], y[i])``.
y : array_like, shape (M,) or (M, K)
    y-coordinates of the sample points. Several data sets of sample
    points sharing the same x-coordinates can be fitted at once by
    passing in a 2D-array that contains one dataset per column.
deg : int
    Degree of the fitting polynomial
rcond : float, optional
    Relative condition number of the fit. Singular values smaller than this
    relative to the largest singular value will be ignored. The default
    value is len(x)*eps, where eps is the relative precision of the float
    type, about 2e-16 in most cases.
full : bool, optional
    Switch determining nature of return value. When it is
    False (the default) just the coefficients are returned, when True
    diagnostic information from the singular value decomposition is also
    returned.

Returns
-------
p : ndarray, shape (M,) or (M, K)
    Polynomial coefficients, highest power first.
    If `y` was 2-D, the coefficients for `k`-th data set are in ``p[:,k]``.

residuals, rank, singular_values, rcond : present only if `full` = True
    Residuals of the least-squares fit, the effective rank of the scaled
    Vandermonde coefficient matrix, its singular values, and the specified
    value of `rcond`. For more details, see `linalg.lstsq`.

Warns
-----
RankWarning
    The rank of the coefficient matrix in the least-squares fit is
    deficient. The warning is only raised if `full` = False.

    The warnings can be turned off by

    &gt;&gt;&gt; import warnings
    &gt;&gt;&gt; warnings.simplefilter('ignore', np.RankWarning)

See Also
--------
polyval : Computes polynomial values.
linalg.lstsq : Computes a least-squares fit.
scipy.interpolate.UnivariateSpline : Computes spline fits.

Notes
-----
The solution minimizes the squared error

.. math ::
    E = \sum_{j=0}^k |p(x_j) - y_j|^2

in the equations::

    x[0]**n * p[n] + ... + x[0] * p[1] + p[0] = y[0]
    x[1]**n * p[n] + ... + x[1] * p[1] + p[0] = y[1]
    ...
    x[k]**n * p[n] + ... + x[k] * p[1] + p[0] = y[k]

The coefficient matrix of the coefficients `p` is a Vandermonde matrix.

`polyfit` issues a `RankWarning` when the least-squares fit is badly
conditioned. This implies that the best fit is not well-defined due
to numerical error. The results may be improved by lowering the polynomial
degree or by replacing `x` by `x` - `x`.mean(). The `rcond` parameter
can also be set to a value smaller than its default, but the resulting
fit may be spurious: including contributions from the small singular
values can add numerical noise to the result.

Note that fitting polynomial coefficients is inherently badly conditioned
when the degree of the polynomial is large or the interval of sample points
is badly centered. The quality of the fit should always be checked in these
cases. When polynomial fits are not satisfactory, splines may be a good
alternative.

References
----------
.. [1] Wikipedia, &quot;Curve fitting&quot;,
       http://en.wikipedia.org/wiki/Curve_fitting
.. [2] Wikipedia, &quot;Polynomial interpolation&quot;,
       http://en.wikipedia.org/wiki/Polynomial_interpolation

Examples
--------
&gt;&gt;&gt; x = np.array([0.0, 1.0, 2.0, 3.0,  4.0,  5.0])
&gt;&gt;&gt; y = np.array([0.0, 0.8, 0.9, 0.1, -0.8, -1.0])
&gt;&gt;&gt; z = np.polyfit(x, y, 3)
array([ 0.08703704, -0.81349206,  1.69312169, -0.03968254])

It is convenient to use `poly1d` objects for dealing with polynomials:

&gt;&gt;&gt; p = np.poly1d(z)
&gt;&gt;&gt; p(0.5)
0.6143849206349179
&gt;&gt;&gt; p(3.5)
-0.34732142857143039
&gt;&gt;&gt; p(10)
22.579365079365115

High-order polynomials may oscillate wildly:

&gt;&gt;&gt; p30 = np.poly1d(np.polyfit(x, y, 30))
/... RankWarning: Polyfit may be poorly conditioned...
&gt;&gt;&gt; p30(4)
-0.80000000000000204
&gt;&gt;&gt; p30(5)
-0.99999999999999445
&gt;&gt;&gt; p30(4.5)
-0.10547061179440398

Illustration:

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; xp = np.linspace(-2, 6, 100)
&gt;&gt;&gt; plt.plot(x, y, '.', xp, p(xp), '-', xp, p30(xp), '--')
&gt;&gt;&gt; plt.ylim(-2,2)
&gt;&gt;&gt; plt.show()

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="polyint"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">polyint</span>(<span class="sig-arg">p</span>,
        <span class="sig-arg">m</span>=<span class="sig-default">1</span>,
        <span class="sig-arg">k</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return an antiderivative (indefinite integral) of a polynomial.

The returned order `m` antiderivative `P` of polynomial `p` satisfies
:math:`\frac{d^m}{dx^m}P(x) = p(x)` and is defined up to `m - 1`
integration constants `k`. The constants determine the low-order
polynomial part

.. math:: \frac{k_{m-1}}{0!} x^0 + \ldots + \frac{k_0}{(m-1)!}x^{m-1}

of `P` so that :math:`P^{(j)}(0) = k_{m-j-1}`.

Parameters
----------
p : {array_like, poly1d}
    Polynomial to differentiate.
    A sequence is interpreted as polynomial coefficients, see `poly1d`.
m : int, optional
    Order of the antiderivative. (Default: 1)
k : {None, list of `m` scalars, scalar}, optional
    Integration constants. They are given in the order of integration:
    those corresponding to highest-order terms come first.

    If ``None`` (default), all constants are assumed to be zero.
    If `m = 1`, a single scalar can be given instead of a list.

See Also
--------
polyder : derivative of a polynomial
poly1d.integ : equivalent method

Examples
--------
The defining property of the antiderivative:

&gt;&gt;&gt; p = np.poly1d([1,1,1])
&gt;&gt;&gt; P = np.polyint(p)
poly1d([ 0.33333333,  0.5       ,  1.        ,  0.        ])
&gt;&gt;&gt; np.polyder(P) == p
True

The integration constants default to zero, but can be specified:

&gt;&gt;&gt; P = np.polyint(p, 3)
&gt;&gt;&gt; P(0)
0.0
&gt;&gt;&gt; np.polyder(P)(0)
0.0
&gt;&gt;&gt; np.polyder(P, 2)(0)
0.0
&gt;&gt;&gt; P = np.polyint(p, 3, k=[6,5,3])
&gt;&gt;&gt; P
poly1d([ 0.01666667,  0.04166667,  0.16666667,  3.,  5.,  3. ])

Note that 3 = 6 / 2!, and that the constants are given in the order of
integrations. Constant of the highest-order polynomial term comes first:

&gt;&gt;&gt; np.polyder(P, 2)(0)
6.0
&gt;&gt;&gt; np.polyder(P, 1)(0)
5.0
&gt;&gt;&gt; P(0)
3.0

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="polymul"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">polymul</span>(<span class="sig-arg">a1</span>,
        <span class="sig-arg">a2</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Returns product of two polynomials represented as sequences.

The input arrays specify the polynomial terms in turn with a length equal
to the polynomial degree plus 1.

Parameters
----------
a1 : {array_like, poly1d}
    First multiplier polynomial.
a2 : {array_like, poly1d}
    Second multiplier polynomial.

Returns
-------
out : {ndarray, poly1d}
    Product of inputs.

See Also
--------
poly, polyadd, polyder, polydiv, polyfit, polyint, polysub,
polyval

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="polysub"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">polysub</span>(<span class="sig-arg">a1</span>,
        <span class="sig-arg">a2</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Returns difference from subtraction of two polynomials input as sequences.

Returns difference of polynomials; `a1` - `a2`.  Input polynomials are
represented as an array_like sequence of terms or a poly1d object.

Parameters
----------
a1 : {array_like, poly1d}
    Minuend polynomial as sequence of terms.
a2 : {array_like, poly1d}
    Subtrahend polynomial as sequence of terms.

Returns
-------
out : {ndarray, poly1d}
    Array representing the polynomial terms.

See Also
--------
polyval, polydiv, polymul, polyadd

Examples
--------
.. math:: (2 x^2 + 10 x - 2) - (3 x^2 + 10 x -4) = (-x^2 + 2)

&gt;&gt;&gt; np.polysub([2, 10, -2], [3, 10, -4])
array([-1,  0,  2])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="polyval"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">polyval</span>(<span class="sig-arg">p</span>,
        <span class="sig-arg">x</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Evaluate a polynomial at specific values.

If p is of length N, this function returns the value:

    p[0]*(x**N-1) + p[1]*(x**N-2) + ... + p[N-2]*x + p[N-1]

If x is a sequence then p(x) will be returned for all elements of x.
If x is another polynomial then the composite polynomial p(x) will
be returned.

Parameters
----------
p : {array_like, poly1d}
   1D array of polynomial coefficients from highest degree to zero or an
   instance of poly1d.
x : {array_like, poly1d}
   A number, a 1D array of numbers, or an instance of poly1d.

Returns
-------
values : {ndarray, poly1d}
   If either p or x is an instance of poly1d, then an instance of poly1d
   is returned, otherwise a 1D array is returned. In the case where x is
   a poly1d, the result is the composition of the two polynomials, i.e.,
   substitution is used.

See Also
--------
poly1d: A polynomial class.

Notes
-----
Horner's method is used to evaluate the polynomial. Even so, for
polynomials of high degree the values may be inaccurate due to
rounding errors. Use carefully.


Examples
--------
&gt;&gt;&gt; np.polyval([3,0,1], 5)  # 3 * 5**2 + 0 * 5**1 + 1
76

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="ppmt"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">ppmt</span>(<span class="sig-arg">rate</span>,
        <span class="sig-arg">per</span>,
        <span class="sig-arg">nper</span>,
        <span class="sig-arg">pv</span>,
        <span class="sig-arg">fv</span>=<span class="sig-default">0.0</span>,
        <span class="sig-arg">when</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string">end</code><code class="variable-quote">'</code></span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Not implemented. Compute the payment against loan principal.

Parameters
----------
rate : array_like
    Rate of interest (per period)
per : array_like, int
    Amount paid against the loan changes.  The `per` is the period of
    interest.
nper : array_like
    Number of compounding periods
pv : array_like
    Present value
fv : array_like, optional
    Future value
when : {{'begin', 1}, {'end', 0}}, {string, int}
    When payments are due ('begin' (1) or 'end' (0))

See Also
--------
pmt, pv, ipmt

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="prod"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">prod</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">axis</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">dtype</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">out</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return the product of array elements over a given axis.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Input data.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="rst-classifier">int, optional</span></dt>
<dd>Axis over which the product is taken.  By default, the product
of all elements is calculated.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="rst-classifier">data-type, optional</span></dt>
<dd>The data-type of the returned array, as well as of the accumulator
in which the elements are multiplied.  By default, if <code class="link">a</code> is of
integer type, <code class="link">dtype</code> is the default platform integer. (Note: if
the type of <code class="link">a</code> is unsigned, then so is <code class="link">dtype</code>.)  Otherwise,
the dtype is the same as that of <code class="link">a</code>.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray, optional</span></dt>
<dd>Alternative output array in which to place the result. It must have
the same shape as the expected output, but the type of the
output values will be cast if necessary.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>product_along_axis <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray, see <code class="link">dtype</code> parameter above.</span></dt>
<dd>An array shaped as <code class="link">a</code> but with the specified axis removed.
Returns a reference to <code class="link">out</code> if specified.</dd>
</dl>
</div>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<p>ndarray.prod : equivalent method</p>
</div>
<div class="rst-section" id="rst-notes">
<h1 class="heading">Notes</h1>
<p>Arithmetic is modular when using integer types, and no error is
raised on overflow.  That means that, on a 32-bit platform:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>x = np.array([536870910, 536870910, 536870910, 536870910])
<span class="py-prompt">&gt;&gt;&gt; </span>np.prod(x) <span class="py-comment">#random</span>
<span class="py-output">16</span></pre>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<p>By default, calculate the product of all elements:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.prod([1.,2.])
<span class="py-output">2.0</span></pre>
<p>Even when the input array is two-dimensional:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.prod([[1.,2.],[3.,4.]])
<span class="py-output">24.0</span></pre>
<p>But we can also specify the axis over which to multiply:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.prod([[1.,2.],[3.,4.]], axis=1)
<span class="py-output">array([  2.,  12.])</span></pre>
<p>If the type of <code class="link">x</code> is unsigned, then the output type is
the unsigned platform integer:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>x = np.array([1, 2, 3], dtype=np.uint8)
<span class="py-prompt">&gt;&gt;&gt; </span>np.prod(x).dtype == np.uint
<span class="py-output">True</span></pre>
<p>If <code class="link">x</code> is of a signed integer type, then the output type
is the default platform integer:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>x = np.array([1, 2, 3], dtype=np.int8)
<span class="py-prompt">&gt;&gt;&gt; </span>np.prod(x).dtype == np.int
<span class="py-output">True</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="product"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">product</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">axis</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">dtype</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">out</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return the product of array elements over a given axis.</p>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<p>prod : equivalent function; see for details.</p>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="ptp"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">ptp</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">axis</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">out</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Range of values (maximum - minimum) along an axis.</p>
<p>The name of the function comes from the acronym for 'peak to peak'.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Input values.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="rst-classifier">int, optional</span></dt>
<dd>Axis along which to find the peaks.  By default, flatten the
array.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Alternative output array in which to place the result. It must
have the same shape and buffer length as the expected output,
but the type of the output values will be cast if necessary.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>ptp <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray</span></dt>
<dd>A new array holding the result, unless <code class="link">out</code> was
specified, in which case a reference to <code class="link">out</code> is returned.</dd>
</dl>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>x = np.arange(4).reshape((2,2))
<span class="py-prompt">&gt;&gt;&gt; </span>x
<span class="py-output">array([[0, 1],</span>
<span class="py-output">       [2, 3]])</span></pre>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.ptp(x, axis=0)
<span class="py-output">array([2, 2])</span></pre>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.ptp(x, axis=1)
<span class="py-output">array([1, 1])</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="put"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">put</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">ind</span>,
        <span class="sig-arg">v</span>,
        <span class="sig-arg">mode</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string">raise</code><code class="variable-quote">'</code></span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Changes specific elements of one array by replacing from another array.</p>
<p>The indexing works on the flattened target array, <code class="link">put</code> is roughly
equivalent to:</p>
<pre class="rst-literal-block">
for i, val in zip(ind, v):
    x.flat[i] = val
</pre>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray</span></dt>
<dd>Target array.</dd>
<dt>ind <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Target indices, interpreted as integers.</dd>
<dt>v <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Values to place in <code class="link">a</code> at target indices. If <code class="link">v</code> is shorter than
<code class="link">ind</code> it will be repeated as necessary.</dd>
<dt>mode <span class="classifier-delimiter">:</span> <span class="rst-classifier">{'raise', 'wrap', 'clip'}, optional</span></dt>
<dd><p class="rst-first">Specifies how out-of-bounds indices will behave.</p>
<ul class="rst-simple">
<li>'raise' -- raise an error (default)</li>
<li>'wrap' -- wrap around</li>
<li>'clip' -- clip to the range</li>
</ul>
<p class="rst-last">'clip' mode means that all indices that are too large are replaced
by the index that addresses the last element along that axis. Note
that this disables indexing with negative numbers.</p>
</dd>
</dl>
</div>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<p>putmask, place</p>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>x = np.arange(5)
<span class="py-prompt">&gt;&gt;&gt; </span>np.put(x, [0, 2], [-44, -55])
<span class="py-prompt">&gt;&gt;&gt; </span>x
<span class="py-output">array([-44,   1, -55,   3,   4])</span></pre>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>x = np.arange(5)
<span class="py-prompt">&gt;&gt;&gt; </span>np.put(x, 22, -5, mode=<span class="py-string">'clip'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>x
<span class="py-output">array([ 0,  1,  2,  3, -5])</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="putmask"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">putmask</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">mask</span>,
        <span class="sig-arg">values</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">
Changes elements of an array based on conditional and input values.

Sets ``a.flat[n] = values[n]`` for each n where ``mask.flat[n]==True``.

If `values` is not the same size as `a` and `mask` then it will repeat.
This gives behavior different from ``a[mask] = values``.

Parameters
----------
a : array_like
    Target array.
mask : array_like
    Boolean mask array. It has to be the same shape as `a`.
values : array_like
    Values to put into `a` where `mask` is True. If `values` is smaller
    than `a` it will be repeated.

See Also
--------
place, put, take

Examples
--------
&gt;&gt;&gt; x = np.arange(6).reshape(2, 3)
&gt;&gt;&gt; np.putmask(x, x&gt;2, x**2)
&gt;&gt;&gt; x
array([[ 0,  1,  2],
       [ 9, 16, 25]])

If `values` is smaller than `a` it is repeated:

&gt;&gt;&gt; x = np.arange(5)
&gt;&gt;&gt; np.putmask(x, x&gt;1, [-33, -44])
&gt;&gt;&gt; x
array([  0,   1, -33, -44, -33])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="pv"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">pv</span>(<span class="sig-arg">rate</span>,
        <span class="sig-arg">nper</span>,
        <span class="sig-arg">pmt</span>,
        <span class="sig-arg">fv</span>=<span class="sig-default">0.0</span>,
        <span class="sig-arg">when</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string">end</code><code class="variable-quote">'</code></span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Compute the present value.

Parameters
----------
rate : array_like
    Rate of interest (per period)
nper : array_like
    Number of compounding periods
pmt : array_like
    Payment
fv : array_like, optional
    Future value
when : {{'begin', 1}, {'end', 0}}, {string, int}, optional
    When payments are due ('begin' (1) or 'end' (0))

Returns
-------
out : ndarray, float
    Present value of a series of payments or investments.

Notes
-----
The present value ``pv`` is computed by solving the equation::

 fv +
 pv*(1 + rate)**nper +
 pmt*(1 + rate*when)/rate*((1 + rate)**nper - 1) = 0

or, when ``rate = 0``::

 fv + pv + pmt * nper = 0

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="rank"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">rank</span>(<span class="sig-arg">a</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return the number of dimensions of an array.</p>
<p>If <code class="link">a</code> is not already an array, a conversion is attempted.
Scalars are zero dimensional.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Array whose number of dimensions is desired. If <code class="link">a</code> is not an array,
a conversion is attempted.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>number_of_dimensions <span class="classifier-delimiter">:</span> <span class="rst-classifier">int</span></dt>
<dd>The number of dimensions in the array.</dd>
</dl>
</div>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<p>ndim : equivalent function
ndarray.ndim : equivalent property
shape : dimensions of array
ndarray.shape : dimensions of array</p>
</div>
<div class="rst-section" id="rst-notes">
<h1 class="heading">Notes</h1>
<p>In the old Numeric package, <code class="link">rank</code> was the term used for the number of
dimensions, but in Numpy <code class="link">ndim</code> is used instead.</p>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.rank([1,2,3])
<span class="py-output">1</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.rank(np.array([[1,2,3],[4,5,6]]))
<span class="py-output">2</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.rank(1)
<span class="py-output">0</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="rate"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">rate</span>(<span class="sig-arg">nper</span>,
        <span class="sig-arg">pmt</span>,
        <span class="sig-arg">pv</span>,
        <span class="sig-arg">fv</span>,
        <span class="sig-arg">when</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string">end</code><code class="variable-quote">'</code></span>,
        <span class="sig-arg">guess</span>=<span class="sig-default">0.1</span>,
        <span class="sig-arg">tol</span>=<span class="sig-default">1e-06</span>,
        <span class="sig-arg">maxiter</span>=<span class="sig-default">100</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Compute the rate of interest per period.

Parameters
----------
nper : array_like
    Number of compounding periods
pmt : array_like
    Payment
pv : array_like
    Present value
fv : array_like
    Future value
when : {{'begin', 1}, {'end', 0}}, {string, int}, optional
    When payments are due ('begin' (1) or 'end' (0))
guess : float, optional
    Starting guess for solving the rate of interest
tol : float, optional
    Required tolerance for the solution
maxiter : int, optional
    Maximum iterations in finding the solution

Notes
-----
The rate of interest ``rate`` is computed by solving the equation::

 fv + pv*(1+rate)**nper + pmt*(1+rate*when)/rate * ((1+rate)**nper - 1) = 0

or, if ``rate = 0``::

 fv + pv + pmt * nper = 0

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="ravel"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">ravel</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">order</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string">C</code><code class="variable-quote">'</code></span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return a flattened array.

A 1-D array, containing the elements of the input, is returned.  A copy is
made only if needed.

Parameters
----------
a : array_like
    Input array.  The elements in `a` are read in the order specified by
    `order`, and packed as a 1-D array.
order : {'C','F'}, optional
    The elements of `a` are read in this order.  It can be either
    'C' for row-major order, or `F` for column-major order.
    By default, row-major order is used.

Returns
-------
1d_array : ndarray
    Output of the same dtype as `a`, and of shape ``(a.size(),)``.

See Also
--------
ndarray.flat : 1-D iterator over an array.
ndarray.flatten : 1-D array copy of the elements of an array
                  in row-major order.

Notes
-----
In row-major order, the row index varies the slowest, and the column
index the quickest.  This can be generalized to multiple dimensions,
where row-major order implies that the index along the first axis
varies slowest, and the index along the last quickest.  The opposite holds
for Fortran-, or column-major, mode.

Examples
--------
If an array is in C-order (default), then `ravel` is equivalent
to ``reshape(-1)``:

&gt;&gt;&gt; x = np.array([[1, 2, 3], [4, 5, 6]])
&gt;&gt;&gt; print x.reshape(-1)
[1  2  3  4  5  6]

&gt;&gt;&gt; print np.ravel(x)
[1  2  3  4  5  6]

When flattening using Fortran-order, however, we see

&gt;&gt;&gt; print np.ravel(x, order='F')
[1 4 2 5 3 6]

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="real"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">real</span>(<span class="sig-arg">val</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return the real part of the elements of the array.

Parameters
----------
val : array_like
    Input array.

Returns
-------
out : ndarray
    If `val` is real, the type of `val` is used for the output.  If `val`
    has complex elements, the returned type is float.

See Also
--------
real_if_close, imag, angle

Examples
--------
&gt;&gt;&gt; a = np.array([1+2j,3+4j,5+6j])
&gt;&gt;&gt; a.real
array([ 1.,  3.,  5.])
&gt;&gt;&gt; a.real = 9
&gt;&gt;&gt; a
array([ 9.+2.j,  9.+4.j,  9.+6.j])
&gt;&gt;&gt; a.real = np.array([9,8,7])
&gt;&gt;&gt; a
array([ 9.+2.j,  8.+4.j,  7.+6.j])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="real_if_close"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">real_if_close</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">tol</span>=<span class="sig-default">100</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

If complex input returns a real array if complex parts are close to zero.

&quot;Close to zero&quot; is defined as `tol` * (machine epsilon of the type for
`a`).

Parameters
----------
a : array_like
    Input array.
tol : float
    Tolerance in machine epsilons for the complex part of the elements
    in the array.

Returns
-------
out : ndarray
    If `a` is real, the type of `a` is used for the output.  If `a`
    has complex elements, the returned type is float.

See Also
--------
real, imag, angle

Notes
-----
Machine epsilon varies from machine to machine and between data types
but Python floats on most platforms have a machine epsilon equal to
2.2204460492503131e-16.  You can use 'np.finfo(np.float).eps' to print
out the machine epsilon for floats.

Examples
--------
&gt;&gt;&gt; np.finfo(np.float).eps
2.2204460492503131e-16

&gt;&gt;&gt; np.real_if_close([2.1 + 4e-14j], tol=1000)
array([ 2.1])
&gt;&gt;&gt; np.real_if_close([2.1 + 4e-13j], tol=1000)
array([ 2.1 +4.00000000e-13j])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="recfromcsv"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">recfromcsv</span>(<span class="sig-arg">fname</span>,
        <span class="sig-arg">dtype</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">comments</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string">#</code><code class="variable-quote">'</code></span>,
        <span class="sig-arg">skiprows</span>=<span class="sig-default">0</span>,
        <span class="sig-arg">converters</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">missing</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string"></code><code class="variable-quote">'</code></span>,
        <span class="sig-arg">missing_values</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">usecols</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">unpack</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">names</span>=<span class="sig-default">True</span>,
        <span class="sig-arg">excludelist</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">deletechars</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">case_sensitive</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string">lower</code><code class="variable-quote">'</code></span>,
        <span class="sig-arg">usemask</span>=<span class="sig-default">False</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Load ASCII data stored in comma-separated file and returns a recarray (if 
`usemask=False`) or a MaskedRecords (if `usemask=True`).

Complete description of all the optional input parameters is available in
the docstring of the `genfromtxt` function.

See Also
--------
numpy.genfromtxt : generic function

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="recfromtxt"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">recfromtxt</span>(<span class="sig-arg">fname</span>,
        <span class="sig-arg">dtype</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">comments</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string">#</code><code class="variable-quote">'</code></span>,
        <span class="sig-arg">delimiter</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">skiprows</span>=<span class="sig-default">0</span>,
        <span class="sig-arg">converters</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">missing</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string"></code><code class="variable-quote">'</code></span>,
        <span class="sig-arg">missing_values</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">usecols</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">unpack</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">names</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">excludelist</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">deletechars</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">case_sensitive</span>=<span class="sig-default">True</span>,
        <span class="sig-arg">usemask</span>=<span class="sig-default">False</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Load ASCII data stored in fname and returns a standard recarray (if 
`usemask=False`) or a MaskedRecords (if `usemask=True`).

Complete description of all the optional input parameters is available in
the docstring of the `genfromtxt` function.

See Also
--------
numpy.genfromtxt : generic function

Warnings
--------
* by default, `dtype=None`, which means that the dtype of the output array
  will be determined from the data.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="repeat"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">repeat</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">repeats</span>,
        <span class="sig-arg">axis</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Repeat elements of an array.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Input array.</dd>
<dt>repeats <span class="classifier-delimiter">:</span> <span class="rst-classifier">{int, array of ints}</span></dt>
<dd>The number of repetitions for each element.  <code class="link">repeats</code> is broadcasted
to fit the shape of the given axis.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="rst-classifier">int, optional</span></dt>
<dd>The axis along which to repeat values.  By default, use the
flattened input array, and return a flat output array.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>repeated_array <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray</span></dt>
<dd>Output array which has the same shape as <code class="link">a</code>, except along
the given axis.</dd>
</dl>
</div>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<p>tile : Tile an array.</p>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>x = np.array([[1,2],[3,4]])
<span class="py-prompt">&gt;&gt;&gt; </span>np.repeat(x, 2)
<span class="py-output">array([1, 1, 2, 2, 3, 3, 4, 4])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.repeat(x, 3, axis=1)
<span class="py-output">array([[1, 1, 1, 2, 2, 2],</span>
<span class="py-output">       [3, 3, 3, 4, 4, 4]])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.repeat(x, [1, 2], axis=0)
<span class="py-output">array([[1, 2],</span>
<span class="py-output">       [3, 4],</span>
<span class="py-output">       [3, 4]])</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="require"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">require</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">dtype</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">requirements</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return an ndarray of the provided type that satisfies requirements.

This function is useful to be sure that an array with the correct flags
is returned for passing to compiled code (perhaps through ctypes).

Parameters
----------
a : array_like
   The object to be converted to a type-and-requirement satisfying array
dtype : data-type
   The required data-type (None is the default data-type -- float64)
requirements : list of strings
   The requirements list can be any of the following

   * 'ENSUREARRAY' ('E')  - ensure that  a base-class ndarray
   * 'F_CONTIGUOUS' ('F') - ensure a Fortran-contiguous array
   * 'C_CONTIGUOUS' ('C') - ensure a C-contiguous array
   * 'ALIGNED' ('A')      - ensure a data-type aligned array
   * 'WRITEABLE' ('W')    - ensure a writeable array
   * 'OWNDATA' ('O')      - ensure an array that owns its own data

Notes
-----
The returned array will be guaranteed to have the listed requirements
by making a copy if needed.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="reshape"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">reshape</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">newshape</span>,
        <span class="sig-arg">order</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string">C</code><code class="variable-quote">'</code></span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Gives a new shape to an array without changing its data.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Array to be reshaped.</dd>
<dt>newshape <span class="classifier-delimiter">:</span> <span class="rst-classifier">{tuple, int}</span></dt>
<dd>The new shape should be compatible with the original shape. If
an integer, then the result will be a 1-D array of that length.
One shape dimension can be -1. In this case, the value is inferred
from the length of the array and remaining dimensions.</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="rst-classifier">{'C', 'F'}, optional</span></dt>
<dd>Determines whether the array data should be viewed as in C
(row-major) order or FORTRAN (column-major) order.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>reshaped_array <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray</span></dt>
<dd>This will be a new view object if possible; otherwise, it will
be a copy.</dd>
</dl>
</div>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<p>ndarray.reshape : Equivalent method.</p>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>a = np.array([[1,2,3], [4,5,6]])
<span class="py-prompt">&gt;&gt;&gt; </span>np.reshape(a, 6)
<span class="py-output">array([1, 2, 3, 4, 5, 6])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.reshape(a, 6, order=<span class="py-string">'F'</span>)
<span class="py-output">array([1, 4, 2, 5, 3, 6])</span></pre>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.reshape(a, (3,-1))       <span class="py-comment"># the unspecified value is inferred to be 2</span>
<span class="py-output">array([[1, 2],</span>
<span class="py-output">       [3, 4],</span>
<span class="py-output">       [5, 6]])</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="resize"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">resize</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">new_shape</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return a new array with the specified shape.</p>
<p>If the new array is larger than the original array, then the new array
is filled with repeated copied of <code class="link">a</code>. Note that this behavior is different
from a.resize(new_shape) which fills with zeros instead of repeated
copies of <code class="link">a</code>.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Array to be resized.</dd>
<dt>new_shape <span class="classifier-delimiter">:</span> <span class="rst-classifier">{tuple, int}</span></dt>
<dd>Shape of resized array.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>reshaped_array <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray</span></dt>
<dd>The new array is formed from the data in the old array, repeated if
necessary to fill out the required number of elements.</dd>
</dl>
</div>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<p>ndarray.resize : resize an array in-place.</p>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>a=np.array([[0,1],[2,3]])
<span class="py-prompt">&gt;&gt;&gt; </span>np.resize(a,(1,4))
<span class="py-output">array([[0, 1, 2, 3]])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.resize(a,(2,4))
<span class="py-output">array([[0, 1, 2, 3],</span>
<span class="py-output">       [0, 1, 2, 3]])</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="restoredot"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">restoredot</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">
Restore `dot`, `vdot`, and `innerproduct` to the default non-BLAS
implementations.

Typically, the user will only need to call this when troubleshooting and
installation problem, reproducing the conditions of a build without an
accelerated BLAS, or when being very careful about benchmarking linear
algebra operations.

See Also
--------
alterdot : `restoredot` undoes the effects of `alterdot`.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="roll"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">roll</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">shift</span>,
        <span class="sig-arg">axis</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Roll array elements along a given axis.

Elements that roll beyond the last position are re-introduced at
the first.

Parameters
----------
a : array_like
    Input array.
shift : int
    The number of places by which elements are shifted.
axis : int, optional
    The axis along which elements are shifted.  By default, the array
    is flattened before shifting, after which the original
    shape is restored.

Returns
-------
res : ndarray
    Output array, with the same shape as `a`.

See Also
--------
rollaxis : Roll the specified axis backwards, until it lies in a
           given position.

Examples
--------
&gt;&gt;&gt; x = np.arange(10)
&gt;&gt;&gt; np.roll(x, 2)
array([8, 9, 0, 1, 2, 3, 4, 5, 6, 7])

&gt;&gt;&gt; x2 = np.reshape(x, (2,5))
&gt;&gt;&gt; x2
array([[0, 1, 2, 3, 4],
       [5, 6, 7, 8, 9]])
&gt;&gt;&gt; np.roll(x2, 1)
array([[9, 0, 1, 2, 3],
       [4, 5, 6, 7, 8]])
&gt;&gt;&gt; np.roll(x2, 1, axis=0)
array([[5, 6, 7, 8, 9],
       [0, 1, 2, 3, 4]])
&gt;&gt;&gt; np.roll(x2, 1, axis=1)
array([[4, 0, 1, 2, 3],
       [9, 5, 6, 7, 8]])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="rollaxis"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">rollaxis</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">axis</span>,
        <span class="sig-arg">start</span>=<span class="sig-default">0</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Roll the specified axis backwards, until it lies in a given position.

Parameters
----------
a : ndarray
    Input array.
axis : int
    The axis to roll backwards.  The positions of the other axes do not
    change relative to one another.
start : int, optional
    The axis is rolled until it lies before this position.

Returns
-------
res : ndarray
    Output array.

See Also
--------
roll : Roll the elements of an array by a number of positions along a
       given axis.

Examples
--------
&gt;&gt;&gt; a = np.ones((3,4,5,6))
&gt;&gt;&gt; np.rollaxis(a, 3, 1).shape
(3, 6, 4, 5)
&gt;&gt;&gt; np.rollaxis(a, 2).shape
(5, 3, 4, 6)
&gt;&gt;&gt; np.rollaxis(a, 1, 4).shape
(3, 5, 6, 4)

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="roots"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">roots</span>(<span class="sig-arg">p</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return the roots of a polynomial with coefficients given in p.

The values in the rank-1 array `p` are coefficients of a polynomial.
If the length of `p` is n+1 then the polynomial is described by
p[0] * x**n + p[1] * x**(n-1) + ... + p[n-1]*x + p[n]

Parameters
----------
p : array_like of shape(M,)
    Rank-1 array of polynomial co-efficients.

Returns
-------
out : ndarray
    An array containing the complex roots of the polynomial.

Raises
------
ValueError:
    When `p` cannot be converted to a rank-1 array.

Examples
--------

&gt;&gt;&gt; coeff = [3.2, 2, 1]
&gt;&gt;&gt; print np.roots(coeff)
[-0.3125+0.46351241j -0.3125-0.46351241j]

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="rot90"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">rot90</span>(<span class="sig-arg">m</span>,
        <span class="sig-arg">k</span>=<span class="sig-default">1</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Rotate an array by 90 degrees in the counter-clockwise direction.

The first two dimensions are rotated; therefore, the array must be at
least 2-D.

Parameters
----------
m : array_like
    Array of two or more dimensions.
k : integer
    Number of times the array is rotated by 90 degrees.

Returns
-------
y : ndarray
    Rotated array.

See Also
--------
fliplr : Flip an array horizontally.
flipud : Flip an array vertically.

Examples
--------
&gt;&gt;&gt; m = np.array([[1,2],[3,4]], int)
&gt;&gt;&gt; m
array([[1, 2],
       [3, 4]])
&gt;&gt;&gt; np.rot90(m)
array([[2, 4],
       [1, 3]])
&gt;&gt;&gt; np.rot90(m, 2)
array([[4, 3],
       [2, 1]])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="round_"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">round_</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">decimals</span>=<span class="sig-default">0</span>,
        <span class="sig-arg">out</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Round an array to the given number of decimals.</p>
<p>Refer to <code class="link">around</code> for full documentation.</p>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<p>around : equivalent function</p>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="row_stack"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">row_stack</span>(<span class="sig-arg">tup</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Stack arrays in sequence vertically (row wise).

Take a sequence of arrays and stack them vertically to make a single
array. Rebuild arrays divided by `vsplit`.

Parameters
----------
tup : sequence of ndarrays
    Tuple containing arrays to be stacked. The arrays must have the same
    shape along all but the first axis.

Returns
-------
stacked : ndarray
    The array formed by stacking the given arrays.

See Also
--------
hstack : Stack arrays in sequence horizontally (column wise).
dstack : Stack arrays in sequence depth wise (along third dimension).
concatenate : Join a sequence of arrays together.
vsplit : Split array into a list of multiple sub-arrays vertically.


Notes
-----
Equivalent to ``np.concatenate(tup, axis=0)``

Examples
--------
&gt;&gt;&gt; a = np.array([1, 2, 3])
&gt;&gt;&gt; b = np.array([2, 3, 4])
&gt;&gt;&gt; np.vstack((a,b))
array([[1, 2, 3],
       [2, 3, 4]])

&gt;&gt;&gt; a = np.array([[1], [2], [3]])
&gt;&gt;&gt; b = np.array([[2], [3], [4]])
&gt;&gt;&gt; np.vstack((a,b))
array([[1],
       [2],
       [3],
       [2],
       [3],
       [4]])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="safe_eval"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">safe_eval</span>(<span class="sig-arg">source</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Protected string evaluation.

Evaluate a string containing a Python literal expression without
allowing the execution of arbitrary non-literal code.

Parameters
----------
source : str

Returns
-------
obj : object

Raises
------
SyntaxError
    If the code has invalid Python syntax, or if it contains non-literal
    code.

Examples
--------
&gt;&gt;&gt; from numpy.lib.utils import safe_eval
&gt;&gt;&gt; safe_eval('1')
1
&gt;&gt;&gt; safe_eval('[1, 2, 3]')
[1, 2, 3]
&gt;&gt;&gt; safe_eval('{&quot;foo&quot;: (&quot;bar&quot;, 10.0)}')
{'foo': ('bar', 10.0)}
&gt;&gt;&gt; safe_eval('import os')
Traceback (most recent call last):
  ...
SyntaxError: invalid syntax
&gt;&gt;&gt; safe_eval('open(&quot;/home/user/.ssh/id_dsa&quot;).read()')
Traceback (most recent call last):
  ...
SyntaxError: Unsupported source construct: compiler.ast.CallFunc
&gt;&gt;&gt; safe_eval('dict')
Traceback (most recent call last):
  ...
SyntaxError: Unknown name: dict

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="save"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">save</span>(<span class="sig-arg">file</span>,
        <span class="sig-arg">arr</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Save an array to a binary file in NumPy format.

Parameters
----------
f : file or string
    File or filename to which the data is saved.  If the filename
    does not already have a ``.npy`` extension, it is added.
x : array_like
    Array data.

See Also
--------
savez : Save several arrays into an .npz compressed archive
savetxt : Save an array to a file as plain text

Examples
--------
&gt;&gt;&gt; from tempfile import TemporaryFile
&gt;&gt;&gt; outfile = TemporaryFile()

&gt;&gt;&gt; x = np.arange(10)
&gt;&gt;&gt; np.save(outfile, x)

&gt;&gt;&gt; outfile.seek(0)
&gt;&gt;&gt; np.load(outfile)
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="savetxt"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">savetxt</span>(<span class="sig-arg">fname</span>,
        <span class="sig-arg">X</span>,
        <span class="sig-arg">fmt</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string">%.18e</code><code class="variable-quote">'</code></span>,
        <span class="sig-arg">delimiter</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string"> </code><code class="variable-quote">'</code></span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Save an array to file.

Parameters
----------
fname : filename or a file handle
    If the filename ends in .gz, the file is automatically saved in
    compressed gzip format.  The load() command understands gzipped
    files transparently.
X : array_like
    Data.
fmt : string or sequence of strings
    A single format (%10.5f), a sequence of formats, or a
    multi-format string, e.g. 'Iteration %d -- %10.5f', in which
    case delimiter is ignored.
delimiter : str
    Character separating columns.

See Also
--------
save : Save an array to a binary file in NumPy format
savez : Save several arrays into an .npz compressed archive

Notes
-----
Further explanation of the `fmt` parameter
(``%[flag]width[.precision]specifier``):

flags:
    ``-`` : left justify

    ``+`` : Forces to preceed result with + or -.

    ``0`` : Left pad the number with zeros instead of space (see width).

width:
    Minimum number of characters to be printed. The value is not truncated
    if it has more characters.

precision:
    - For integer specifiers (eg. ``d,i,o,x``), the minimum number of
      digits.
    - For ``e, E`` and ``f`` specifiers, the number of digits to print
      after the decimal point.
    - For ``g`` and ``G``, the maximum number of significant digits.
    - For ``s``, the maximum number of characters.

specifiers:
    ``c`` : character

    ``d`` or ``i`` : signed decimal integer

    ``e`` or ``E`` : scientific notation with ``e`` or ``E``.

    ``f`` : decimal floating point

    ``g,G`` : use the shorter of ``e,E`` or ``f``

    ``o`` : signed octal

    ``s`` : string of characters

    ``u`` : unsigned decimal integer

    ``x,X`` : unsigned hexadecimal integer

This is not an exhaustive specification.



Examples
--------
&gt;&gt;&gt; savetxt('test.out', x, delimiter=',') # X is an array
&gt;&gt;&gt; savetxt('test.out', (x,y,z)) # x,y,z equal sized 1D arrays
&gt;&gt;&gt; savetxt('test.out', x, fmt='%1.4e') # use exponential notation

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="savez"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">savez</span>(<span class="sig-arg">file</span>,
        <span class="sig-arg">*args</span>,
        <span class="sig-arg">**kwds</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Save several arrays into a single, compressed file with extension &quot;.npz&quot;

If keyword arguments are given, the names for variables assigned to the
keywords are the keyword names (not the variable names in the caller).
If arguments are passed in with no keywords, the corresponding variable
names are arr_0, arr_1, etc.

Parameters
----------
file : Either the filename (string) or an open file (file-like object)
    If file is a string, it names the output file.  &quot;.npz&quot; will be appended
    if it is not already there.
args : Arguments
    Any function arguments other than the file name are variables to save.
    Since it is not possible for Python to know their names outside the
    savez function, they will be saved with names &quot;arr_0&quot;, &quot;arr_1&quot;, and so
    on.  These arguments can be any expression.
kwds : Keyword arguments
    All keyword=value pairs cause the value to be saved with the name of
    the keyword.

See Also
--------
save : Save a single array to a binary file in NumPy format
savetxt : Save an array to a file as plain text

Notes
-----
The .npz file format is a zipped archive of files named after the variables
they contain.  Each file contains one variable in .npy format.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="searchsorted"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">searchsorted</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">v</span>,
        <span class="sig-arg">side</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string">left</code><code class="variable-quote">'</code></span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Find indices where elements should be inserted to maintain order.</p>
<p>Find the indices into a sorted array <code class="link">a</code> such that, if the corresponding
elements in <code class="link">v</code> were inserted before the indices, the order of <code class="link">a</code> would
be preserved.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="rst-classifier">1-D array_like</span></dt>
<dd>Input array, sorted in ascending order.</dd>
<dt>v <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Values to insert into <code class="link">a</code>.</dd>
<dt>side <span class="classifier-delimiter">:</span> <span class="rst-classifier">{'left', 'right'}, optional</span></dt>
<dd>If 'left', the index of the first suitable location found is given.  If
'right', return the last such index.  If there is no suitable
index, return either 0 or N (where N is the length of <code class="link">a</code>).</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>indices <span class="classifier-delimiter">:</span> <span class="rst-classifier">array of ints</span></dt>
<dd>Array of insertion points with the same shape as <code class="link">v</code>.</dd>
</dl>
</div>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<p>sort : Return a sorted copy of an array.
histogram : Produce histogram from 1-D data.</p>
</div>
<div class="rst-section" id="rst-notes">
<h1 class="heading">Notes</h1>
<p>Binary search is used to find the required insertion points.</p>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.searchsorted([1,2,3,4,5], 3)
<span class="py-output">2</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.searchsorted([1,2,3,4,5], 3, side=<span class="py-string">'right'</span>)
<span class="py-output">3</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.searchsorted([1,2,3,4,5], [-10, 10, 2, 3])
<span class="py-output">array([0, 5, 1, 2])</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="select"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">select</span>(<span class="sig-arg">condlist</span>,
        <span class="sig-arg">choicelist</span>,
        <span class="sig-arg">default</span>=<span class="sig-default">0</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return an array drawn from elements in choicelist, depending on conditions.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>condlist <span class="classifier-delimiter">:</span> <span class="rst-classifier">list of N boolean arrays of length M</span></dt>
<dd>The conditions C_0 through C_(N-1) which determine
from which vector the output elements are taken.</dd>
<dt>choicelist <span class="classifier-delimiter">:</span> <span class="rst-classifier">list of N arrays of length M</span></dt>
<dd>Th vectors V_0 through V_(N-1), from which the output
elements are chosen.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>output <span class="classifier-delimiter">:</span> <span class="rst-classifier">1-dimensional array of length M</span></dt>
<dd>The output at position m is the m-th element of the first
vector V_n for which C_n[m] is non-zero.  Note that the
output depends on the order of conditions, since the
first satisfied condition is used.</dd>
</dl>
</div>
<div class="rst-section" id="rst-notes">
<h1 class="heading">Notes</h1>
<p>Equivalent to:</p>
<pre class="rst-literal-block">
output = []
for m in range(M):
    output += [V[m] for V,C in zip(values,cond) if C[m]]
              or [default]
</pre>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>t = np.arange(10)
<span class="py-prompt">&gt;&gt;&gt; </span>s = np.arange(10)*100
<span class="py-prompt">&gt;&gt;&gt; </span>condlist = [t == 4, t &gt; 5]
<span class="py-prompt">&gt;&gt;&gt; </span>choicelist = [s, t]
<span class="py-prompt">&gt;&gt;&gt; </span>np.select(condlist, choicelist)
<span class="py-output">array([  0,   0,   0,   0, 400,   0,   6,   7,   8,   9])</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="set_numeric_ops"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">set_numeric_ops</span>(<span class="sig-arg">op1</span>=<span class="sig-default">func1</span>,
        <span class="sig-arg">op2</span>=<span class="sig-default">func2</span>,
        <span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">
Set numerical operators for array objects.

Parameters
----------
op1, op2, ... : callable
    Each ``op = func`` pair describes an operator to be replaced.
    For example, ``add = lambda x, y: np.add(x, y) % 5`` would replace
    addition by modulus 5 addition.

Returns
-------
saved_ops : list of callables
    A list of all operators, stored before making replacements.

Notes
-----
.. WARNING::
   Use with care!  Incorrect usage may lead to memory errors.

A function replacing an operator cannot make use of that operator.
For example, when replacing add, you may not use ``+``.  Instead,
directly call ufuncs:

&gt;&gt;&gt; def add_mod5(x, y):
...     return np.add(x, y) % 5
...
&gt;&gt;&gt; old_funcs = np.set_numeric_ops(add=add_mod5)

&gt;&gt;&gt; x = np.arange(12).reshape((3, 4))
&gt;&gt;&gt; x + x
array([[0, 2, 4, 1],
       [3, 0, 2, 4],
       [1, 3, 0, 2]])

&gt;&gt;&gt; ignore = np.set_numeric_ops(**old_funcs) # restore operators

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="set_printoptions"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">set_printoptions</span>(<span class="sig-arg">precision</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">threshold</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">edgeitems</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">linewidth</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">suppress</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">nanstr</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">infstr</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Set printing options.</p>
<p>These options determine the way floating point numbers, arrays and
other NumPy objects are displayed.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>precision <span class="classifier-delimiter">:</span> <span class="rst-classifier">int, optional</span></dt>
<dd>Number of digits of precision for floating point output (default 8).</dd>
<dt>threshold <span class="classifier-delimiter">:</span> <span class="rst-classifier">int, optional</span></dt>
<dd>Total number of array elements which trigger summarization
rather than full repr (default 1000).</dd>
<dt>edgeitems <span class="classifier-delimiter">:</span> <span class="rst-classifier">int, optional</span></dt>
<dd>Number of array items in summary at beginning and end of
each dimension (default 3).</dd>
<dt>linewidth <span class="classifier-delimiter">:</span> <span class="rst-classifier">int, optional</span></dt>
<dd>The number of characters per line for the purpose of inserting
line breaks (default 75).</dd>
<dt>suppress <span class="classifier-delimiter">:</span> <span class="rst-classifier">bool, optional</span></dt>
<dd>Whether or not suppress printing of small floating point values
using scientific notation (default False).</dd>
<dt>nanstr <span class="classifier-delimiter">:</span> <span class="rst-classifier">string, optional</span></dt>
<dd>String representation of floating point not-a-number (default nan).</dd>
<dt>infstr <span class="classifier-delimiter">:</span> <span class="rst-classifier">string, optional</span></dt>
<dd>String representation of floating point infinity (default inf).</dd>
</dl>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<p>Floating point precision can be set:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.set_printoptions(precision=4)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> np.array([1.123456789])
<span class="py-output">[ 1.1235]</span></pre>
<p>Long arrays can be summarised:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.set_printoptions(threshold=5)
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> np.arange(10)
<span class="py-output">[0 1 2 ..., 7 8 9]</span></pre>
<p>Small results can be suppressed:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>eps = np.finfo(float).eps
<span class="py-prompt">&gt;&gt;&gt; </span>x = np.arange(4.)</pre>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>x**2 - (x + eps)**2
<span class="py-output">array([ -4.9304e-32,  -4.4409e-16,   0.0000e+00,   0.0000e+00])</span></pre>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.set_printoptions(suppress=True)</pre>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>x**2 - (x + eps)**2
<span class="py-output">array([-0., -0.,  0.,  0.])</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="set_string_function"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">set_string_function</span>(<span class="sig-arg">f</span>,
        <span class="sig-arg">repr</span>=<span class="sig-default">1</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">
Set a Python function to be used when pretty printing arrays.

Parameters
----------
f : Python function
    Function to be used to pretty print arrays. The function should expect
    a single array argument and return a string of the representation of
    the array.
repr : int
    Unknown.

Examples
--------
&gt;&gt;&gt; def pprint(arr):
...     return 'HA! - What are you going to do now?'
...
&gt;&gt;&gt; np.set_string_function(pprint)
&gt;&gt;&gt; a = np.arange(10)
&gt;&gt;&gt; a
HA! - What are you going to do now?
&gt;&gt;&gt; print a
[0 1 2 3 4 5 6 7 8 9]

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="setbufsize"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">setbufsize</span>(<span class="sig-arg">size</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Set the size of the buffer used in ufuncs.

Parameters
----------
size : int
    Size of buffer.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="setdiff1d"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">setdiff1d</span>(<span class="sig-arg">ar1</span>,
        <span class="sig-arg">ar2</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Set difference of 1D arrays with unique elements.

Use unique1d() to generate arrays with only unique elements to use as
inputs to this function.

Parameters
----------
ar1 : array_like
    Input array.
ar2 : array_like
    Input comparison array.

Returns
-------
difference : ndarray
    The values in ar1 that are not in ar2.

See Also
--------
numpy.lib.arraysetops : Module with a number of other functions for
                        performing set operations on arrays.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="seterr"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">seterr</span>(<span class="sig-arg">all</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">divide</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">over</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">under</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">invalid</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Set how floating-point errors are handled.

Note that operations on integer scalar types (such as `int16`) are
handled like floating point, and are affected by these settings.

Parameters
----------
all : {'ignore', 'warn', 'raise', 'call'}, optional
    Set treatment for all types of floating-point errors at once:

    - ignore: Take no action when the exception occurs
    - warn: Print a `RuntimeWarning` (via the Python `warnings` module)
    - raise: Raise a `FloatingPointError`
    - call: Call a function specified using the `seterrcall` function.

    The default is not to change the current behavior.
divide : {'ignore', 'warn', 'raise', 'call'}, optional
    Treatment for division by zero.
over : {'ignore', 'warn', 'raise', 'call'}, optional
    Treatment for floating-point overflow.
under : {'ignore', 'warn', 'raise', 'call'}, optional
    Treatment for floating-point underflow.
invalid : {'ignore', 'warn', 'raise', 'call'}, optional
    Treatment for invalid floating-point operation.

Returns
-------
old_settings : dict
    Dictionary containing the old settings.

See also
--------
seterrcall : set a callback function for the 'call' mode.
geterr, geterrcall

Notes
-----
The floating-point exceptions are defined in the IEEE 754 standard [1]:

- Division by zero: infinite result obtained from finite numbers.
- Overflow: result too large to be expressed.
- Underflow: result so close to zero that some precision
  was lost.
- Invalid operation: result is not an expressible number, typically
  indicates that a NaN was produced.

.. [1] http://en.wikipedia.org/wiki/IEEE_754

Examples
--------

Set mode:

&gt;&gt;&gt; seterr(over='raise') # doctest: +SKIP
{'over': 'ignore', 'divide': 'ignore', 'invalid': 'ignore',
 'under': 'ignore'}

&gt;&gt;&gt; old_settings = seterr(all='warn', over='raise') # doctest: +SKIP

&gt;&gt;&gt; int16(32000) * int16(3) # doctest: +SKIP
Traceback (most recent call last):
      File &quot;&lt;stdin&gt;&quot;, line 1, in ?
FloatingPointError: overflow encountered in short_scalars
&gt;&gt;&gt; seterr(all='ignore') # doctest: +SKIP
{'over': 'ignore', 'divide': 'ignore', 'invalid': 'ignore',
 'under': 'ignore'}

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="seterrcall"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">seterrcall</span>(<span class="sig-arg">func</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Set the floating-point error callback function or log object.

There are two ways to capture floating-point error messages.  The first
is to set the error-handler to 'call', using `seterr`.  Then, set
the function to call using this function.

The second is to set the error-handler to `log`, using `seterr`.
Floating-point errors then trigger a call to the 'write' method of
the provided object.

Parameters
----------
log_func_or_obj : callable f(err, flag) or object with write method
    Function to call upon floating-point errors ('call'-mode) or
    object whose 'write' method is used to log such message ('log'-mode).

    The call function takes two arguments. The first is the
    type of error (one of &quot;divide&quot;, &quot;over&quot;, &quot;under&quot;, or &quot;invalid&quot;),
    and the second is the status flag.  The flag is a byte, whose
    least-significant bits indicate the status::

      [0 0 0 0 invalid over under invalid]

    In other words, ``flags = divide + 2*over + 4*under + 8*invalid``.

    If an object is provided, it's write method should take one argument,
    a string.

Returns
-------
h : callable or log instance
    The old error handler.

Examples
--------
Callback upon error:

&gt;&gt;&gt; def err_handler(type, flag):
    print &quot;Floating point error (%s), with flag %s&quot; % (type, flag)
...

&gt;&gt;&gt; saved_handler = np.seterrcall(err_handler)
&gt;&gt;&gt; save_err = np.seterr(all='call')

&gt;&gt;&gt; np.array([1,2,3])/0.0
Floating point error (divide by zero), with flag 1
array([ Inf,  Inf,  Inf])

&gt;&gt;&gt; np.seterrcall(saved_handler)
&gt;&gt;&gt; np.seterr(**save_err)

Log error message:

&gt;&gt;&gt; class Log(object):
        def write(self, msg):
            print &quot;LOG: %s&quot; % msg
...

&gt;&gt;&gt; log = Log()
&gt;&gt;&gt; saved_handler = np.seterrcall(log)
&gt;&gt;&gt; save_err = np.seterr(all='log')

&gt;&gt;&gt; np.array([1,2,3])/0.0
LOG: Warning: divide by zero encountered in divide

&gt;&gt;&gt; np.seterrcall(saved_handler)
&gt;&gt;&gt; np.seterr(**save_err)

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="seterrobj"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">seterrobj</span>(<span class="sig-arg">errobj</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">
Used internally by `seterr`.

Parameters
----------
errobj : list
    [buffer_size, error_mask, callback_func]

See Also
--------
seterrcall

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="setmember1d"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">setmember1d</span>(<span class="sig-arg">ar1</span>,
        <span class="sig-arg">ar2</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return a boolean array set True where first element is in second array.

Boolean array is the shape of `ar1` containing True where the elements
of `ar1` are in `ar2` and False otherwise.

Use unique1d() to generate arrays with only unique elements to use as
inputs to this function.

Parameters
----------
ar1 : array_like
    Input array.
ar2 : array_like
    Input array.

Returns
-------
mask : ndarray, bool
    The values `ar1[mask]` are in `ar2`.


See Also
--------
numpy.lib.arraysetops : Module with a number of other functions for
                        performing set operations on arrays.

Examples
--------
&gt;&gt;&gt; test = np.arange(5)
&gt;&gt;&gt; states = [0, 2]
&gt;&gt;&gt; mask = np.setmember1d(test,states)
&gt;&gt;&gt; mask
array([ True, False,  True, False, False], dtype=bool)
&gt;&gt;&gt; test[mask]
array([0, 2])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="setxor1d"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">setxor1d</span>(<span class="sig-arg">ar1</span>,
        <span class="sig-arg">ar2</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Set exclusive-or of 1D arrays with unique elements.

Use unique1d() to generate arrays with only unique elements to use as
inputs to this function.

Parameters
----------
ar1 : array_like
    Input array.
ar2 : array_like
    Input array.

Returns
-------
xor : ndarray
    The values that are only in one, but not both, of the input arrays.

See Also
--------
numpy.lib.arraysetops : Module with a number of other functions for
                        performing set operations on arrays.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="shape"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">shape</span>(<span class="sig-arg">a</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return the shape of an array.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Input array.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>shape <span class="classifier-delimiter">:</span> <span class="rst-classifier">tuple</span></dt>
<dd>The elements of the tuple give the lengths of the corresponding array
dimensions.</dd>
</dl>
</div>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<p>alen,
ndarray.shape : array method</p>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.shape(np.eye(3))
<span class="py-output">(3, 3)</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.shape([[1,2]])
<span class="py-output">(1, 2)</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.shape([0])
<span class="py-output">(1,)</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.shape(0)
<span class="py-output">()</span></pre>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>a = np.array([(1,2),(3,4)], dtype=[(<span class="py-string">'x'</span>, <span class="py-string">'i4'</span>), (<span class="py-string">'y'</span>, <span class="py-string">'i4'</span>)])
<span class="py-prompt">&gt;&gt;&gt; </span>np.shape(a)
<span class="py-output">(2,)</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>a.shape
<span class="py-output">(2,)</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="sinc"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">sinc</span>(<span class="sig-arg">x</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return the sinc function.

The sinc function is :math:`\sin(\pi x)/(\pi x)`.

Parameters
----------
x : ndarray
    Array (possibly multi-dimensional) of values for which to to
    calculate ``sinc(x)``.

Returns
-------
out : ndarray
    ``sinc(x)``, which has the same shape as the input.

Notes
-----
``sinc(0)`` is the limit value 1.

The name sinc is short for &quot;sine cardinal&quot; or &quot;sinus cardinalis&quot;.

The sinc function is used in various signal processing applications,
including in anti-aliasing, in the construction of a
Lanczos resampling filter, and in interpolation.

For bandlimited interpolation of discrete-time signals, the ideal
interpolation kernel is proportional to the sinc function.

References
----------
.. [1] Weisstein, Eric W. &quot;Sinc Function.&quot; From MathWorld--A Wolfram Web
       Resource. http://mathworld.wolfram.com/SincFunction.html
.. [2] Wikipedia, &quot;Sinc function&quot;,
       http://en.wikipedia.org/wiki/Sinc_function

Examples
--------
&gt;&gt;&gt; x = np.arange(-20., 21.)/5.
&gt;&gt;&gt; np.sinc(x)
array([ -3.89804309e-17,  -4.92362781e-02,  -8.40918587e-02,
        -8.90384387e-02,  -5.84680802e-02,   3.89804309e-17,
         6.68206631e-02,   1.16434881e-01,   1.26137788e-01,
         8.50444803e-02,  -3.89804309e-17,  -1.03943254e-01,
        -1.89206682e-01,  -2.16236208e-01,  -1.55914881e-01,
         3.89804309e-17,   2.33872321e-01,   5.04551152e-01,
         7.56826729e-01,   9.35489284e-01,   1.00000000e+00,
         9.35489284e-01,   7.56826729e-01,   5.04551152e-01,
         2.33872321e-01,   3.89804309e-17,  -1.55914881e-01,
        -2.16236208e-01,  -1.89206682e-01,  -1.03943254e-01,
        -3.89804309e-17,   8.50444803e-02,   1.26137788e-01,
         1.16434881e-01,   6.68206631e-02,   3.89804309e-17,
        -5.84680802e-02,  -8.90384387e-02,  -8.40918587e-02,
        -4.92362781e-02,  -3.89804309e-17])

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; plt.plot(x, sinc(x))
&gt;&gt;&gt; plt.title(&quot;Sinc Function&quot;)
&gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;)
&gt;&gt;&gt; plt.xlabel(&quot;X&quot;)
&gt;&gt;&gt; plt.show()

It works in 2-D as well:

&gt;&gt;&gt; x = np.arange(-200., 201.)/50.
&gt;&gt;&gt; xx = np.outer(x, x)
&gt;&gt;&gt; plt.imshow(sinc(xx))

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="size"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">size</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">axis</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return the number of elements along a given axis.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Input data.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="rst-classifier">int, optional</span></dt>
<dd>Axis along which the elements are counted.  By default, give
the total number of elements.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>element_count <span class="classifier-delimiter">:</span> <span class="rst-classifier">int</span></dt>
<dd>Number of elements along the specified axis.</dd>
</dl>
</div>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<p>shape : dimensions of array
ndarray.shape : dimensions of array
ndarray.size : number of elements in array</p>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>a = np.array([[1,2,3],[4,5,6]])
<span class="py-prompt">&gt;&gt;&gt; </span>np.size(a)
<span class="py-output">6</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.size(a,1)
<span class="py-output">3</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.size(a,0)
<span class="py-output">2</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="sometrue"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">sometrue</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">axis</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">out</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Check whether some values are true.</p>
<p>Refer to <code class="link">any</code> for full documentation.</p>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<p>any : equivalent function</p>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="sort"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">sort</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">axis</span>=<span class="sig-default">-1</span>,
        <span class="sig-arg">kind</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string">quicksort</code><code class="variable-quote">'</code></span>,
        <span class="sig-arg">order</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return a sorted copy of an array.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Array to be sorted.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="rst-classifier">int or None, optional</span></dt>
<dd>Axis along which to sort. If None, the array is flattened before
sorting. The default is -1, which sorts along the last axis.</dd>
<dt>kind <span class="classifier-delimiter">:</span> <span class="rst-classifier">{'quicksort', 'mergesort', 'heapsort'}, optional</span></dt>
<dd>Sorting algorithm. Default is 'quicksort'.</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="rst-classifier">list, optional</span></dt>
<dd>When <code class="link">a</code> is a structured array, this argument specifies which fields
to compare first, second, and so on.  This list does not need to
include all of the fields.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>sorted_array <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray</span></dt>
<dd>Array of the same type and shape as <code class="link">a</code>.</dd>
</dl>
</div>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<p>ndarray.sort : Method to sort an array in-place.
argsort : Indirect sort.
lexsort : Indirect stable sort on multiple keys.
searchsorted : Find elements in a sorted array.</p>
</div>
<div class="rst-section" id="rst-notes">
<h1 class="heading">Notes</h1>
<p>The various sorting algorithms are characterized by their average speed,
worst case performance, work space size, and whether they are stable. A
stable sort keeps items with the same key in the same relative
order. The three available algorithms have the following
properties:</p>
<table border="1" class="rst-docutils">
<colgroup>
<col width="22%" />
<col width="14%" />
<col width="26%" />
<col width="24%" />
<col width="14%" />
</colgroup>
<thead valign="bottom">
<tr><th class="rst-head">kind</th>
<th class="rst-head">speed</th>
<th class="rst-head">worst case</th>
<th class="rst-head">work space</th>
<th class="rst-head">stable</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>'quicksort'</td>
<td>1</td>
<td>O(n^2)</td>
<td>0</td>
<td>no</td>
</tr>
<tr><td>'mergesort'</td>
<td>2</td>
<td>O(n*log(n))</td>
<td>~n/2</td>
<td>yes</td>
</tr>
<tr><td>'heapsort'</td>
<td>3</td>
<td>O(n*log(n))</td>
<td>0</td>
<td>no</td>
</tr>
</tbody>
</table>
<p>All the sort algorithms make temporary copies of the data when
sorting along any but the last axis.  Consequently, sorting along
the last axis is faster and uses less space than sorting along
any other axis.</p>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>a = np.array([[1,4],[3,1]])
<span class="py-prompt">&gt;&gt;&gt; </span>np.sort(a)                <span class="py-comment"># sort along the last axis</span>
<span class="py-output">array([[1, 4],</span>
<span class="py-output">       [1, 3]])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.sort(a, axis=None)     <span class="py-comment"># sort the flattened array</span>
<span class="py-output">array([1, 1, 3, 4])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.sort(a, axis=0)        <span class="py-comment"># sort along the first axis</span>
<span class="py-output">array([[1, 1],</span>
<span class="py-output">       [3, 4]])</span></pre>
<p>Use the <code class="link">order</code> keyword to specify a field to use when sorting a
structured array:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>dtype = [(<span class="py-string">'name'</span>, <span class="py-string">'S10'</span>), (<span class="py-string">'height'</span>, float), (<span class="py-string">'age'</span>, int)]
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">values</span> = [(<span class="py-string">'Arthur'</span>, 1.8, 41), (<span class="py-string">'Lancelot'</span>, 1.9, 38),
<span class="py-more">... </span>          (<span class="py-string">'Galahad'</span>, 1.7, 38)]
<span class="py-prompt">&gt;&gt;&gt; </span>a = np.array(<span class="py-builtin">values</span>, dtype=dtype)       <span class="py-comment"># create a structured array</span>
<span class="py-prompt">&gt;&gt;&gt; </span>np.sort(a, order=<span class="py-string">'height'</span>)                        <span class="py-comment"># doctest: +SKIP</span>
<span class="py-output">array([('Galahad', 1.7, 38), ('Arthur', 1.8, 41),</span>
<span class="py-output">       ('Lancelot', 1.8999999999999999, 38)],</span>
<span class="py-output">      dtype=[('name', '|S10'), ('height', '&lt;f8'), ('age', '&lt;i4')])</span></pre>
<p>Sort by age, then height if ages are equal:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.sort(a, order=[<span class="py-string">'age'</span>, <span class="py-string">'height'</span>])               <span class="py-comment"># doctest: +SKIP</span>
<span class="py-output">array([('Galahad', 1.7, 38), ('Lancelot', 1.8999999999999999, 38),</span>
<span class="py-output">       ('Arthur', 1.8, 41)],</span>
<span class="py-output">      dtype=[('name', '|S10'), ('height', '&lt;f8'), ('age', '&lt;i4')])</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="sort_complex"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">sort_complex</span>(<span class="sig-arg">a</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Sort a complex array using the real part first, then the imaginary part.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Input array</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="rst-classifier">complex ndarray</span></dt>
<dd>Always returns a sorted complex array.</dd>
</dl>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.sort_complex([5, 3, 6, 2, 1])
<span class="py-output">array([ 1.+0.j,  2.+0.j,  3.+0.j,  5.+0.j,  6.+0.j])</span></pre>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.sort_complex([1 + 2j, 2 - 1j, 3 - 2j, 3 - 3j, 3 + 5j])
<span class="py-output">array([ 1.+2.j,  2.-1.j,  3.-5.j,  3.-3.j,  3.+2.j])</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="source"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">source</span>(<span class="sig-arg">object</span>,
        <span class="sig-arg">output</span>=<span class="sig-default">&lt;epydoc.docintrospecter._DevNull instance at 0x9c5774c&gt;</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Print or write to a file the source code for a Numpy object.

Parameters
----------
object : numpy object
    Input object.
output : file object, optional
    If `output` not supplied then source code is printed to screen
    (sys.stdout).  File object must be created with either write 'w' or
    append 'a' modes.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="split"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">split</span>(<span class="sig-arg">ary</span>,
        <span class="sig-arg">indices_or_sections</span>,
        <span class="sig-arg">axis</span>=<span class="sig-default">0</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Split an array into multiple sub-arrays of equal size.

Parameters
----------
ary : ndarray
    Array to be divided into sub-arrays.
indices_or_sections : int or 1-D array
    If `indices_or_sections` is an integer, N, the array will be divided
    into N equal arrays along `axis`.  If such a split is not possible,
    an error is raised.

    If `indices_or_sections` is a 1-D array of sorted integers, the entries
    indicate where along `axis` the array is split.  For example,
    ``[2, 3]`` would, for ``axis = 0``, result in

      - ary[:2]
      - ary[2:3]
      - ary[3:]

    If an index exceeds the dimension of the array along `axis`,
    an empty sub-array is returned correspondingly.
axis : int, optional
    The axis along which to split, default is 0.

Returns
-------
sub-arrays : list of ndarrays
    A list of sub-arrays.

Raises
------
ValueError
    If `indices_or_sections` is given as an integer, but
    a split does not result in equal division.

See Also
--------
array_split : Split an array into multiple sub-arrays of equal or
              near-equal size.  Does not raise an exception if
              an equal division cannot be made.
hsplit : Split array into multiple sub-arrays horizontally (column-wise).
vsplit : Split array into multiple sub-arrays vertically (row wise).
dsplit : Split array into multiple sub-arrays along the 3rd axis (depth).
concatenate : Join arrays together.
hstack : Stack arrays in sequence horizontally (column wise).
vstack : Stack arrays in sequence vertically (row wise).
dstack : Stack arrays in sequence depth wise (along third dimension).

Examples
--------
&gt;&gt;&gt; x = np.arange(9.0)
&gt;&gt;&gt; np.split(x, 3)
[array([ 0.,  1.,  2.]), array([ 3.,  4.,  5.]), array([ 6.,  7.,  8.])]

&gt;&gt;&gt; x = np.arange(8.0)
&gt;&gt;&gt; np.split(x, [3, 5, 6, 10])
[array([ 0.,  1.,  2.]),
 array([ 3.,  4.]),
 array([ 5.]),
 array([ 6.,  7.]),
 array([], dtype=float64)]

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="squeeze"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">squeeze</span>(<span class="sig-arg">a</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Remove single-dimensional entries from the shape of an array.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Input data.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>squeezed <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray</span></dt>
<dd>The input array, but with with all dimensions of length 1
removed.  Whenever possible, a view on <code class="link">a</code> is returned.</dd>
</dl>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>x = np.array([[[0], [1], [2]]])
<span class="py-prompt">&gt;&gt;&gt; </span>x.shape
<span class="py-output">(1, 3, 1)</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.squeeze(x).shape
<span class="py-output">(3,)</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="std"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">std</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">axis</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">dtype</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">out</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">ddof</span>=<span class="sig-default">0</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Compute the standard deviation along the specified axis.</p>
<p>Returns the standard deviation, a measure of the spread of a distribution,
of the array elements. The standard deviation is computed for the
flattened array by default, otherwise over the specified axis.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Calculate the standard deviation of these values.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="rst-classifier">int, optional</span></dt>
<dd>Axis along which the standard deviation is computed. The default is
to compute the standard deviation of the flattened array.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="rst-classifier">dtype, optional</span></dt>
<dd>Type to use in computing the standard deviation. For arrays of
integer type the default is float64, for arrays of float types it is
the same as the array type.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray, optional</span></dt>
<dd>Alternative output array in which to place the result. It must have
the same shape as the expected output but the type (of the calculated
values) will be cast if necessary.</dd>
<dt>ddof <span class="classifier-delimiter">:</span> <span class="rst-classifier">int, optional</span></dt>
<dd>Means Delta Degrees of Freedom.  The divisor used in calculations
is <tt class="rst-docutils literal"><span class="pre">N</span> <span class="pre">-</span> <span class="pre">ddof</span></tt>, where <tt class="rst-docutils literal"><span class="pre">N</span></tt> represents the number of elements.
By default <code class="link">ddof</code> is zero.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>standard_deviation <span class="classifier-delimiter">:</span> <span class="rst-classifier">{ndarray, scalar}; see dtype parameter above.</span></dt>
<dd>If <code class="link">out</code> is None, return a new array containing the standard deviation,
otherwise return a reference to the output array.</dd>
</dl>
</div>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<p>numpy.var : Variance
numpy.mean : Average</p>
</div>
<div class="rst-section" id="rst-notes">
<h1 class="heading">Notes</h1>
<p>The standard deviation is the square root of the average of the squared
deviations from the mean, i.e., <tt class="rst-docutils literal"><span class="pre">std</span> <span class="pre">=</span> <span class="pre">sqrt(mean(abs(x</span> <span class="pre">-</span> <span class="pre">x.mean())**2))</span></tt>.</p>
<p>The mean is normally calculated as <tt class="rst-docutils literal"><span class="pre">x.sum()</span> <span class="pre">/</span> <span class="pre">N</span></tt>, where
<tt class="rst-docutils literal"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">len(x)</span></tt>.  If, however, <code class="link">ddof</code> is specified, the divisor <tt class="rst-docutils literal"><span class="pre">N</span> <span class="pre">-</span> <span class="pre">ddof</span></tt>
is used instead. In standard statistical practice, <tt class="rst-docutils literal"><span class="pre">ddof=1</span></tt> provides an
unbiased estimator of the variance of the infinite population. <tt class="rst-docutils literal"><span class="pre">ddof=0</span></tt>
provides a maximum likelihood estimate of the variance for normally
distributed variables. The standard deviation computed in this function
is the square root of the estimated variance, so even with <tt class="rst-docutils literal"><span class="pre">ddof=1</span></tt>, it
will not be an unbiased estimate of the standard deviation per se.</p>
<p>Note that, for complex numbers, std takes the absolute
value before squaring, so that the result is always real and nonnegative.</p>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>a = np.array([[1, 2], [3, 4]])
<span class="py-prompt">&gt;&gt;&gt; </span>np.std(a)
<span class="py-output">1.1180339887498949</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.std(a, 0)
<span class="py-output">array([ 1.,  1.])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.std(a, 1)
<span class="py-output">array([ 0.5,  0.5])</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="sum"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">sum</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">axis</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">dtype</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">out</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return the sum of array elements over a given axis.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Elements to sum.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="rst-classifier">integer, optional</span></dt>
<dd>Axis over which the sum is taken. By default <code class="link">axis</code> is None,
and all elements are summed.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="rst-classifier">dtype, optional</span></dt>
<dd>The type of the returned array and of the accumulator in which
the elements are summed.  By default, the dtype of <code class="link">a</code> is used.
An exception is when <code class="link">a</code> has an integer type with less precision
than the default platform integer.  In that case, the default
platform integer is used instead.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray, optional</span></dt>
<dd>Array into which the output is placed.  By default, a new array is
created.  If <code class="link">out</code> is given, it must be of the appropriate shape
(the shape of <code class="link">a</code> with <code class="link">axis</code> removed, i.e.,
<tt class="rst-docutils literal"><span class="pre">numpy.delete(a.shape,</span> <span class="pre">axis)</span></tt>).  Its type is preserved.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>sum_along_axis <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray</span></dt>
<dd>An array with the same shape as <code class="link">a</code>, with the specified
axis removed.   If <code class="link">a</code> is a 0-d array, or if <code class="link">axis</code> is None, a scalar
is returned.  If an output array is specified, a reference to
<code class="link">out</code> is returned.</dd>
</dl>
</div>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<p>ndarray.sum : equivalent method</p>
</div>
<div class="rst-section" id="rst-notes">
<h1 class="heading">Notes</h1>
<p>Arithmetic is modular when using integer types, and no error is
raised on overflow.</p>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.sum([0.5, 1.5])
<span class="py-output">2.0</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.sum([0.5, 1.5], dtype=np.int32)
<span class="py-output">1</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.sum([[0, 1], [0, 5]])
<span class="py-output">6</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.sum([[0, 1], [0, 5]], axis=1)
<span class="py-output">array([1, 5])</span></pre>
<p>If the accumulator is too small, overflow occurs:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.ones(128, dtype=np.int8).sum(dtype=np.int8)
<span class="py-output">-128</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="swapaxes"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">swapaxes</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">axis1</span>,
        <span class="sig-arg">axis2</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Interchange two axes of an array.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Input array.</dd>
<dt>axis1 <span class="classifier-delimiter">:</span> <span class="rst-classifier">int</span></dt>
<dd>First axis.</dd>
<dt>axis2 <span class="classifier-delimiter">:</span> <span class="rst-classifier">int</span></dt>
<dd>Second axis.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>a_swapped <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray</span></dt>
<dd>If <code class="link">a</code> is an ndarray, then a view of <code class="link">a</code> is returned; otherwise
a new array is created.</dd>
</dl>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>x = np.array([[1,2,3]])
<span class="py-prompt">&gt;&gt;&gt; </span>np.swapaxes(x,0,1)
<span class="py-output">array([[1],</span>
<span class="py-output">       [2],</span>
<span class="py-output">       [3]])</span></pre>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>x = np.array([[[0,1],[2,3]],[[4,5],[6,7]]])
<span class="py-prompt">&gt;&gt;&gt; </span>x
<span class="py-output">array([[[0, 1],</span>
<span class="py-output">        [2, 3]],</span>
<span class="py-output">       [[4, 5],</span>
<span class="py-output">        [6, 7]]])</span></pre>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.swapaxes(x,0,2)
<span class="py-output">array([[[0, 4],</span>
<span class="py-output">        [2, 6]],</span>
<span class="py-output">       [[1, 5],</span>
<span class="py-output">        [3, 7]]])</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="take"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">take</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">indices</span>,
        <span class="sig-arg">axis</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">out</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">mode</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string">raise</code><code class="variable-quote">'</code></span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Take elements from an array along an axis.</p>
<p>This function does the same thing as &quot;fancy&quot; indexing (indexing arrays
using arrays); however, it can be easier to use if you need elements
along a given axis.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>The source array.</dd>
<dt>indices <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>The indices of the values to extract.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="rst-classifier">int, optional</span></dt>
<dd>The axis over which to select values. By default, the flattened
input array is used.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray, optional</span></dt>
<dd>If provided, the result will be placed in this array. It should
be of the appropriate shape and dtype.</dd>
<dt>mode <span class="classifier-delimiter">:</span> <span class="rst-classifier">{'raise', 'wrap', 'clip'}, optional</span></dt>
<dd><p class="rst-first">Specifies how out-of-bounds indices will behave.</p>
<ul class="rst-simple">
<li>'raise' -- raise an error (default)</li>
<li>'wrap' -- wrap around</li>
<li>'clip' -- clip to the range</li>
</ul>
<p class="rst-last">'clip' mode means that all indices that are too large are replaced
by the index that addresses the last element along that axis. Note
that this disables indexing with negative numbers.</p>
</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>subarray <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray</span></dt>
<dd>The returned array has the same type as <code class="link">a</code>.</dd>
</dl>
</div>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<p>ndarray.take : equivalent method</p>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>a = [4, 3, 5, 7, 6, 8]
<span class="py-prompt">&gt;&gt;&gt; </span>indices = [0, 1, 4]
<span class="py-prompt">&gt;&gt;&gt; </span>np.take(a, indices)
<span class="py-output">array([4, 3, 6])</span></pre>
<p>In this example if <code class="link">a</code> is an ndarray, &quot;fancy&quot; indexing can be used.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>a = np.array(a)
<span class="py-prompt">&gt;&gt;&gt; </span>a[indices]
<span class="py-output">array([4, 3, 6])</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="tensordot"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">tensordot</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">b</span>,
        <span class="sig-arg">axes</span>=<span class="sig-default">2</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Returns the tensor dot product for (ndim &gt;= 1) arrays along an axes.

The first element of the sequence determines the axis or axes
in `a` to sum over, and the second element in `axes` argument sequence
determines the axis or axes in `b` to sum over.

Parameters
----------
a : array_like
    Input array.
b : array_like
    Input array.
axes : shape tuple
    Axes to be summed over.

See Also
--------
dot

Notes
-----
r_{xxx, yyy} = \sum_k a_{xxx,k} b_{k,yyy}

When there is more than one axis to sum over, the corresponding
arguments to axes should be sequences of the same length with the first
axis to sum over given first in both sequences, the second axis second,
and so forth.

If the `axes` argument is an integer, N, then the last N dimensions of `a`
and first N dimensions of `b` are summed over.

Examples
--------
&gt;&gt;&gt; a = np.arange(60.).reshape(3,4,5)
&gt;&gt;&gt; b = np.arange(24.).reshape(4,3,2)
&gt;&gt;&gt; c = np.tensordot(a,b, axes=([1,0],[0,1]))
&gt;&gt;&gt; c.shape
(5, 2)
&gt;&gt;&gt; c
array([[ 4400.,  4730.],
       [ 4532.,  4874.],
       [ 4664.,  5018.],
       [ 4796.,  5162.],
       [ 4928.,  5306.]])

&gt;&gt;&gt; # A slower but equivalent way of computing the same...
&gt;&gt;&gt; c = np.zeros((5,2))
&gt;&gt;&gt; for i in range(5):
...   for j in range(2):
...     for k in range(3):
...       for n in range(4):
...         c[i,j] += a[k,n,i] * b[n,k,j]

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="tile"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">tile</span>(<span class="sig-arg">A</span>,
        <span class="sig-arg">reps</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Construct an array by repeating A the number of times given by reps.

Parameters
----------
A : array_like
    The input array.
reps : array_like
    The number of repetitions of `A` along each axis.

Returns
-------
c : ndarray
    The output array.

See Also
--------
repeat

Notes
-----
If `reps` has length d, the result will have dimension of max(d, `A`.ndim).

If `A`.ndim &lt; d, `A` is promoted to be d-dimensional by prepending new
axes. So a shape (3,) array is promoted to (1,3) for 2-D replication,
or shape (1,1,3) for 3-D replication. If this is not the desired behavior,
promote `A` to d-dimensions manually before calling this function.

If `A`.ndim &gt; d, `reps` is promoted to `A`.ndim by pre-pending 1's to it.
Thus for an `A` of shape (2,3,4,5), a `reps` of (2,2) is treated as
(1,1,2,2).

Examples
--------
&gt;&gt;&gt; a = np.array([0, 1, 2])
&gt;&gt;&gt; np.tile(a, 2)
array([0, 1, 2, 0, 1, 2])
&gt;&gt;&gt; np.tile(a, (2, 2))
array([[0, 1, 2, 0, 1, 2],
       [0, 1, 2, 0, 1, 2]])
&gt;&gt;&gt; np.tile(a, (2, 1, 2))
array([[[0, 1, 2, 0, 1, 2]],
&lt;BLANKLINE&gt;
       [[0, 1, 2, 0, 1, 2]]])

&gt;&gt;&gt; b = np.array([[1, 2], [3, 4]])
&gt;&gt;&gt; np.tile(b, 2)
array([[1, 2, 1, 2],
       [3, 4, 3, 4]])
&gt;&gt;&gt; np.tile(b, (2, 1))
array([[1, 2],
       [3, 4],
       [1, 2],
       [3, 4]])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="trace"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">trace</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">offset</span>=<span class="sig-default">0</span>,
        <span class="sig-arg">axis1</span>=<span class="sig-default">0</span>,
        <span class="sig-arg">axis2</span>=<span class="sig-default">1</span>,
        <span class="sig-arg">dtype</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">out</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return the sum along diagonals of the array.</p>
<p>If <code class="link">a</code> is 2-D, the sum along its diagonal with the given offset
is returned, i.e., the sum of elements <tt class="rst-docutils literal"><span class="pre">a[i,i+offset]</span></tt> for all i.</p>
<p>If <code class="link">a</code> has more than two dimensions, then the axes specified by axis1 and
axis2 are used to determine the 2-D sub-arrays whose traces are returned.
The shape of the resulting array is the same as that of <code class="link">a</code> with <code class="link">axis1</code>
and <code class="link">axis2</code> removed.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Input array, from which the diagonals are taken.</dd>
<dt>offset <span class="classifier-delimiter">:</span> <span class="rst-classifier">int, optional</span></dt>
<dd>Offset of the diagonal from the main diagonal. Can be both positive
and negative. Defaults to 0.</dd>
<dt>axis1, axis2 <span class="classifier-delimiter">:</span> <span class="rst-classifier">int, optional</span></dt>
<dd>Axes to be used as the first and second axis of the 2-D sub-arrays
from which the diagonals should be taken. Defaults are the first two
axes of <code class="link">a</code>.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="rst-classifier">dtype, optional</span></dt>
<dd>Determines the data-type of the returned array and of the accumulator
where the elements are summed. If dtype has the value None and <code class="link">a</code> is
of integer type of precision less than the default integer
precision, then the default integer precision is used. Otherwise,
the precision is the same as that of <code class="link">a</code>.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray, optional</span></dt>
<dd>Array into which the output is placed. Its type is preserved and
it must be of the right shape to hold the output.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>sum_along_diagonals <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray</span></dt>
<dd>If <code class="link">a</code> is 2-D, the sum along the diagonal is returned.  If <code class="link">a</code> has
larger dimensions, then an array of sums along diagonals is returned.</dd>
</dl>
</div>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<p>diag, diagonal, diagflat</p>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.trace(np.eye(3))
<span class="py-output">3.0</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>a = np.arange(8).reshape((2,2,2))
<span class="py-prompt">&gt;&gt;&gt; </span>np.trace(a)
<span class="py-output">array([6, 8])</span></pre>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>a = np.arange(24).reshape((2,2,2,3))
<span class="py-prompt">&gt;&gt;&gt; </span>np.trace(a).shape
<span class="py-output">(2, 3)</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="transpose"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">transpose</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">axes</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Permute the dimensions of an array.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Input array.</dd>
<dt>axes <span class="classifier-delimiter">:</span> <span class="rst-classifier">list of ints, optional</span></dt>
<dd>By default, reverse the dimensions, otherwise permute the axes
according to the values given.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>p <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray</span></dt>
<dd><code class="link">a</code> with its axes permuted.  A view is returned whenever
possible.</dd>
</dl>
</div>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<p>rollaxis</p>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>x = np.arange(4).reshape((2,2))
<span class="py-prompt">&gt;&gt;&gt; </span>x
<span class="py-output">array([[0, 1],</span>
<span class="py-output">       [2, 3]])</span></pre>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.transpose(x)
<span class="py-output">array([[0, 2],</span>
<span class="py-output">       [1, 3]])</span></pre>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>x = np.ones((1, 2, 3))
<span class="py-prompt">&gt;&gt;&gt; </span>np.transpose(x, (1, 0, 2)).shape
<span class="py-output">(2, 1, 3)</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="trapz"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">trapz</span>(<span class="sig-arg">y</span>,
        <span class="sig-arg">x</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">dx</span>=<span class="sig-default">1.0</span>,
        <span class="sig-arg">axis</span>=<span class="sig-default">-1</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Integrate along the given axis using the composite trapezoidal rule.</p>
<p>Integrate <code class="link">y</code> (<code class="link">x</code>) along given axis.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Input array to integrate.</dd>
<dt>x <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like, optional</span></dt>
<dd>If <code class="link">x</code> is None, then spacing between all <code class="link">y</code> elements is <code class="link">dx</code>.</dd>
<dt>dx <span class="classifier-delimiter">:</span> <span class="rst-classifier">scalar, optional</span></dt>
<dd>If <code class="link">x</code> is None, spacing given by <code class="link">dx</code> is assumed. Default is 1.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="rst-classifier">int, optional</span></dt>
<dd>Specify the axis.</dd>
</dl>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.trapz([1,2,3])
<span class="py-prompt">&gt;&gt;&gt; </span>4.0
<span class="py-prompt">&gt;&gt;&gt; </span>np.trapz([1,2,3], [4,6,8])
<span class="py-prompt">&gt;&gt;&gt; </span>8.0</pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="tri"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">tri</span>(<span class="sig-arg">N</span>,
        <span class="sig-arg">M</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">k</span>=<span class="sig-default">0</span>,
        <span class="sig-arg">dtype</span>=<span class="sig-default">&lt;type 'float'&gt;</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Construct an array filled with ones at and below the given diagonal.

Parameters
----------
N : int
    Number of rows in the array.
M : int, optional
    Number of columns in the array.
    By default, `M` is taken equal to `N`.
k : int, optional
    The sub-diagonal below which the array is filled.
    `k` = 0 is the main diagonal, while `k` &lt; 0 is below it,
    and `k` &gt; 0 is above.  The default is 0.
dtype : dtype, optional
    Data type of the returned array.  The default is float.

Returns
-------
T : (N,M) ndarray
    Array with a lower triangle filled with ones, in other words
    ``T[i,j] == 1`` for ``i &lt;= j + k``.

Examples
--------
&gt;&gt;&gt; np.tri(3, 5, 2, dtype=int)
array([[1, 1, 1, 0, 0],
       [1, 1, 1, 1, 0],
       [1, 1, 1, 1, 1]])

&gt;&gt;&gt; np.tri(3, 5, -1)
array([[ 0.,  0.,  0.,  0.,  0.],
       [ 1.,  0.,  0.,  0.,  0.],
       [ 1.,  1.,  0.,  0.,  0.]])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="tril"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">tril</span>(<span class="sig-arg">m</span>,
        <span class="sig-arg">k</span>=<span class="sig-default">0</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Lower triangle of an array.

Return a copy of an array with elements above the `k`-th diagonal zeroed.

Parameters
----------
m : array_like, shape (M, N)
    Input array.
k : int
    Diagonal above which to zero elements.
    `k = 0` is the main diagonal, `k &lt; 0` is below it and `k &gt; 0` is above.

Returns
-------
L : ndarray, shape (M, N)
    Lower triangle of `m`, of same shape and data-type as `m`.

See Also
--------
triu

Examples
--------
&gt;&gt;&gt; np.tril([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)
array([[ 0,  0,  0],
       [ 4,  0,  0],
       [ 7,  8,  0],
       [10, 11, 12]])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="trim_zeros"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">trim_zeros</span>(<span class="sig-arg">filt</span>,
        <span class="sig-arg">trim</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string">fb</code><code class="variable-quote">'</code></span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Trim the leading and/or trailing zeros from a 1-D array or sequence.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>filt <span class="classifier-delimiter">:</span> <span class="rst-classifier">1-D array or sequence</span></dt>
<dd>Input array.</dd>
<dt>trim <span class="classifier-delimiter">:</span> <span class="rst-classifier">str, optional</span></dt>
<dd>A string with 'f' representing trim from front and 'b' to trim from
back. Default is 'fb', trim zeros from both front and back of the
array.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>trimmed <span class="classifier-delimiter">:</span> <span class="rst-classifier">1-D array or sequence</span></dt>
<dd>The result of trimming the input. The input data type is preserved.</dd>
</dl>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>a = np.array((0, 0, 0, 1, 2, 3, 0, 2, 1, 0))
<span class="py-prompt">&gt;&gt;&gt; </span>np.trim_zeros(a)
<span class="py-output">array([1, 2, 3, 0, 2, 1])</span></pre>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.trim_zeros(a, <span class="py-string">'b'</span>)
<span class="py-output">array([0, 0, 0, 1, 2, 3, 0, 2, 1])</span></pre>
<p>The input data type is preserved, list/tuple in means list/tuple out.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.trim_zeros([0, 1, 2, 0])
<span class="py-output">[1, 2]</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="triu"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">triu</span>(<span class="sig-arg">m</span>,
        <span class="sig-arg">k</span>=<span class="sig-default">0</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Upper triangle of an array.

Construct a copy of a matrix with elements below the k-th diagonal zeroed.

Please refer to the documentation for `tril`.

See Also
--------
tril

Examples
--------
&gt;&gt;&gt; np.triu([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)
array([[ 1,  2,  3],
       [ 4,  5,  6],
       [ 0,  8,  9],
       [ 0,  0, 12]])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="typename"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">typename</span>(<span class="sig-arg">char</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Return a description for the given data type code.

Parameters
----------
char : str
    Data type code.

Returns
-------
out : str
    Description of the input data type code.

See Also
--------
typecodes
dtype

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="union1d"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">union1d</span>(<span class="sig-arg">ar1</span>,
        <span class="sig-arg">ar2</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Union of 1D arrays with unique elements.

Use unique1d() to generate arrays with only unique elements to use as
inputs to this function.

Parameters
----------
ar1 : array_like, shape(M,)
    Input array.
ar2 : array_like, shape(N,)
    Input array.

Returns
-------
union : ndarray
    Unique union of input arrays.

See also
--------
numpy.lib.arraysetops : Module with a number of other functions for
                        performing set operations on arrays.

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="unique"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">unique</span>(<span class="sig-arg">x</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Return the sorted, unique elements of an array or sequence.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>x <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray or sequence</span></dt>
<dd>Input array.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray</span></dt>
<dd>The sorted, unique elements are returned in a 1-D array.</dd>
</dl>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.unique([1, 1, 2, 2, 3, 3])
<span class="py-output">array([1, 2, 3])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>a = np.array([[1, 1], [2, 3]])
<span class="py-prompt">&gt;&gt;&gt; </span>np.unique(a)
<span class="py-output">array([1, 2, 3])</span></pre>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.unique([True, True, False])
<span class="py-output">array([False,  True], dtype=bool)</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="unique1d"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">unique1d</span>(<span class="sig-arg">ar1</span>,
        <span class="sig-arg">return_index</span>=<span class="sig-default">False</span>,
        <span class="sig-arg">return_inverse</span>=<span class="sig-default">False</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Find the unique elements of an array.

Parameters
----------
ar1 : array_like
    This array will be flattened if it is not already 1-D.
return_index : bool, optional
    If True, also return the indices against `ar1` that result in the
    unique array.
return_inverse : bool, optional
    If True, also return the indices against the unique array that
    result in `ar1`.

Returns
-------
unique : ndarray
    The unique values.
unique_indices : ndarray, optional
    The indices of the unique values. Only provided if `return_index` is
    True.
unique_inverse : ndarray, optional
    The indices to reconstruct the original array. Only provided if
    `return_inverse` is True.

See Also
--------
numpy.lib.arraysetops : Module with a number of other functions
                        for performing set operations on arrays.

Examples
--------
&gt;&gt;&gt; np.unique1d([1, 1, 2, 2, 3, 3])
array([1, 2, 3])
&gt;&gt;&gt; a = np.array([[1, 1], [2, 3]])
&gt;&gt;&gt; np.unique1d(a)
array([1, 2, 3])

Reconstruct the input from unique values:

&gt;&gt;&gt; np.unique1d([1,2,6,4,2,3,2], return_index=True)
&gt;&gt;&gt; x = [1,2,6,4,2,3,2]
&gt;&gt;&gt; u, i = np.unique1d(x, return_inverse=True)
&gt;&gt;&gt; u
array([1, 2, 3, 4, 6])
&gt;&gt;&gt; i
array([0, 1, 4, 3, 1, 2, 1])
&gt;&gt;&gt; [u[p] for p in i]
[1, 2, 6, 4, 2, 3, 2]

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="unpackbits"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">unpackbits</span>(<span class="sig-arg">myarray</span>,
        <span class="sig-arg">axis</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">
Unpacks elements of a uint8 array into a binary-valued output array.

Each element of `myarray` represents a bit-field that should be unpacked
into a binary-valued output array. The shape of the output array is either
1-D (if `axis` is None) or the same shape as the input array with unpacking
done along the axis specified.

Parameters
----------
myarray : ndarray, uint8 type
   Input array.
axis : int, optional
   Unpacks along this axis.

Returns
-------
unpacked : ndarray, uint8 type
   The elements are binary-valued (0 or 1).

See Also
--------
packbits : Packs the elements of a binary-valued array into bits in a uint8
           array.

Examples
--------
&gt;&gt;&gt; a = np.array([[2], [7], [23]], dtype=np.uint8)
&gt;&gt;&gt; a
array([[ 2],
       [ 7],
       [23]], dtype=uint8)
&gt;&gt;&gt; b = np.unpackbits(a, axis=1)
&gt;&gt;&gt; b
array([[0, 0, 0, 0, 0, 0, 1, 0],
       [0, 0, 0, 0, 0, 1, 1, 1],
       [0, 0, 0, 1, 0, 1, 1, 1]], dtype=uint8)

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="unravel_index"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">unravel_index</span>(<span class="sig-arg">x</span>,
        <span class="sig-arg">dims</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Convert a flat index into an index tuple for an array of given shape.

Parameters
----------
x : int
    Flattened index.
dims : shape tuple
    Input shape.

Notes
-----
In the Examples section, since ``arr.flat[x] == arr.max()`` it may be
easier to use flattened indexing than to re-map the index to a tuple.

Examples
--------
&gt;&gt;&gt; arr = np.arange(20).reshape(5,4)
&gt;&gt;&gt; arr
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15],
       [16, 17, 18, 19]])
&gt;&gt;&gt; x = arr.argmax()
&gt;&gt;&gt; x
19
&gt;&gt;&gt; dims = arr.shape
&gt;&gt;&gt; idx = np.unravel_index(x, dims)
&gt;&gt;&gt; idx
(4, 3)
&gt;&gt;&gt; arr[idx] == arr.max()
True

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="unwrap"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">unwrap</span>(<span class="sig-arg">p</span>,
        <span class="sig-arg">discont</span>=<span class="sig-default">3.14159265359</span>,
        <span class="sig-arg">axis</span>=<span class="sig-default">-1</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Unwrap by changing deltas between values to 2*pi complement.</p>
<p>Unwrap radian phase <code class="link">p</code> by changing absolute jumps greater than
<code class="link">discont</code> to their 2*pi complement along the given axis.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>p <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Input array.</dd>
<dt>discont <span class="classifier-delimiter">:</span> <span class="rst-classifier">float</span></dt>
<dd>Maximum discontinuity between values.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="rst-classifier">integer</span></dt>
<dd>Axis along which unwrap will operate.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray</span></dt>
<dd>Output array</dd>
</dl>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="vander"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">vander</span>(<span class="sig-arg">x</span>,
        <span class="sig-arg">N</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Generate a Van der Monde matrix.

The columns of the output matrix are decreasing powers of the input
vector.  Specifically, the i-th output column is the input vector to
the power of ``N - i - 1``.

Parameters
----------
x : array_like
    Input array.
N : int, optional
    Order of (number of columns in) the output.

Returns
-------
out : ndarray
    Van der Monde matrix of order `N`.  The first column is ``x^(N-1)``,
    the second ``x^(N-2)`` and so forth.

Examples
--------
&gt;&gt;&gt; x = np.array([1, 2, 3, 5])
&gt;&gt;&gt; N = 3
&gt;&gt;&gt; np.vander(x, N)
array([[ 1,  1,  1],
       [ 4,  2,  1],
       [ 9,  3,  1],
       [25,  5,  1]])

&gt;&gt;&gt; np.column_stack([x**(N-1-i) for i in range(N)])
array([[ 1,  1,  1],
       [ 4,  2,  1],
       [ 9,  3,  1],
       [25,  5,  1]])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="var"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">var</span>(<span class="sig-arg">a</span>,
        <span class="sig-arg">axis</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">dtype</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">out</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">ddof</span>=<span class="sig-default">0</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Compute the variance along the specified axis.</p>
<p>Returns the variance of the array elements, a measure of the spread of a
distribution. The variance is computed for the flattened array by default,
otherwise over the specified axis.</p>
<div class="rst-section" id="rst-parameters">
<h1 class="heading">Parameters</h1>
<dl class="rst-docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="rst-classifier">array_like</span></dt>
<dd>Array containing numbers whose variance is desired. If <code class="link">a</code> is not an
array, a conversion is attempted.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="rst-classifier">int, optional</span></dt>
<dd>Axis along which the variance is computed. The default is to compute
the variance of the flattened array.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="rst-classifier">dtype, optional</span></dt>
<dd>Type to use in computing the variance. For arrays of integer type
the default is float32; for arrays of float types it is the same as
the array type.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray, optional</span></dt>
<dd>Alternative output array in which to place the result. It must have
the same shape as the expected output but the type is cast if
necessary.</dd>
<dt>ddof <span class="classifier-delimiter">:</span> <span class="rst-classifier">int, optional</span></dt>
<dd>&quot;Delta Degrees of Freedom&quot;: the divisor used in calculation is
<tt class="rst-docutils literal"><span class="pre">N</span> <span class="pre">-</span> <span class="pre">ddof</span></tt>, where <tt class="rst-docutils literal"><span class="pre">N</span></tt> represents the number of elements. By
default <code class="link">ddof</code> is zero.</dd>
</dl>
</div>
<div class="rst-section" id="rst-returns">
<h1 class="heading">Returns</h1>
<dl class="rst-docutils">
<dt>variance <span class="classifier-delimiter">:</span> <span class="rst-classifier">ndarray, see dtype parameter above</span></dt>
<dd>If out=None, returns a new array containing the variance; otherwise
a reference to the output array is returned.</dd>
</dl>
</div>
<div class="rst-section" id="rst-see-also">
<h1 class="heading">See Also</h1>
<p>std : Standard deviation
mean : Average</p>
</div>
<div class="rst-section" id="rst-notes">
<h1 class="heading">Notes</h1>
<p>The variance is the average of the squared deviations from the mean,
i.e.,  <tt class="rst-docutils literal"><span class="pre">var</span> <span class="pre">=</span> <span class="pre">mean(abs(x</span> <span class="pre">-</span> <span class="pre">x.mean())**2)</span></tt>.</p>
<p>The mean is normally calculated as <tt class="rst-docutils literal"><span class="pre">x.sum()</span> <span class="pre">/</span> <span class="pre">N</span></tt>, where <tt class="rst-docutils literal"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">len(x)</span></tt>.
If, however, <code class="link">ddof</code> is specified, the divisor <tt class="rst-docutils literal"><span class="pre">N</span> <span class="pre">-</span> <span class="pre">ddof</span></tt> is used
instead. In standard statistical practice, <tt class="rst-docutils literal"><span class="pre">ddof=1</span></tt> provides an
unbiased estimator of the variance of the infinite population. <tt class="rst-docutils literal"><span class="pre">ddof=0</span></tt>
provides a maximum likelihood estimate of the variance for normally
distributed variables.</p>
<p>Note that for complex numbers, the absolute value is taken before
squaring, so that the result is always real and nonnegative.</p>
</div>
<div class="rst-section" id="rst-examples">
<h1 class="heading">Examples</h1>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>a = np.array([[1,2],[3,4]])
<span class="py-prompt">&gt;&gt;&gt; </span>np.var(a)
<span class="py-output">1.25</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.var(a,0)
<span class="py-output">array([ 1.,  1.])</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>np.var(a,1)
<span class="py-output">array([ 0.25,  0.25])</span></pre>
</div>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="vdot"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">vdot</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">
Return the dot product of two vectors.

The vdot(`a`, `b`) function handles complex numbers differently than
dot(`a`, `b`).  If the first argument is complex the complex conjugate
of the first argument is used for the calculation of the dot product.

For 2-D arrays it is equivalent to matrix multiplication, and for 1-D
arrays to inner product of vectors (with complex conjugation of `a`).
For N dimensions it is a sum product over the last axis of `a` and
the second-to-last of `b`::

    dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])

Parameters
----------
a : array_like
    If `a` is complex the complex conjugate is taken before calculation
    of the dot product.
b : array_like
    Second argument to the dot product.

Returns
-------
output : ndarray
    Returns dot product of `a` and `b`.  Can be an int, float, or
    complex depending on the types of `a` and `b`.

See Also
--------
dot : Return the dot product without using the complex conjugate of the
      first argument.

Notes
-----
The dot product is the summation of element wise multiplication.

.. math::
 a \cdot b = \sum_{i=1}^n a_i^*b_i = a_1^*b_1+a_2^*b_2+\cdots+a_n^*b_n

Examples
--------
&gt;&gt;&gt; a = np.array([1+2j,3+4j])
&gt;&gt;&gt; b = np.array([5+6j,7+8j])
&gt;&gt;&gt; np.vdot(a, b)
(70-8j)
&gt;&gt;&gt; np.vdot(b, a)
(70+8j)
&gt;&gt;&gt; a = np.array([[1, 4], [5, 6]])
&gt;&gt;&gt; b = np.array([[4, 1], [2, 2]])
&gt;&gt;&gt; np.vdot(a, b)
30
&gt;&gt;&gt; np.vdot(b, a)
30

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="vsplit"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">vsplit</span>(<span class="sig-arg">ary</span>,
        <span class="sig-arg">indices_or_sections</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Split an array into multiple sub-arrays vertically (row-wise).

Please refer to the ``split`` documentation.  ``vsplit`` is equivalent
to ``split`` with `axis=0` (default), the array is always split along the
first axis regardless of the array dimension.

See Also
--------
split : Split an array into multiple sub-arrays of equal size.

Examples
--------
&gt;&gt;&gt; x = np.arange(16.0).reshape(4, 4)
&gt;&gt;&gt; x
array([[  0.,   1.,   2.,   3.],
       [  4.,   5.,   6.,   7.],
       [  8.,   9.,  10.,  11.],
       [ 12.,  13.,  14.,  15.]])
&gt;&gt;&gt; np.vsplit(x, 2)
[array([[ 0.,  1.,  2.,  3.],
       [ 4.,  5.,  6.,  7.]]),
 array([[  8.,   9.,  10.,  11.],
       [ 12.,  13.,  14.,  15.]])]
&gt;&gt;&gt; np.vsplit(x, np.array([3, 6]))
[array([[  0.,   1.,   2.,   3.],
       [  4.,   5.,   6.,   7.],
       [  8.,   9.,  10.,  11.]]),
 array([[ 12.,  13.,  14.,  15.]]),
 array([], dtype=float64)]

With a higher dimensional array the split is still along the first axis.

&gt;&gt;&gt; x = np.arange(8.0).reshape(2, 2, 2)
&gt;&gt;&gt; x
array([[[ 0.,  1.],
        [ 2.,  3.]],
       [[ 4.,  5.],
        [ 6.,  7.]]])
&gt;&gt;&gt; np.vsplit(x, 2)
[array([[[ 0.,  1.],
        [ 2.,  3.]]]),
 array([[[ 4.,  5.],
        [ 6.,  7.]]])]

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="vstack"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">vstack</span>(<span class="sig-arg">tup</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Stack arrays in sequence vertically (row wise).

Take a sequence of arrays and stack them vertically to make a single
array. Rebuild arrays divided by `vsplit`.

Parameters
----------
tup : sequence of ndarrays
    Tuple containing arrays to be stacked. The arrays must have the same
    shape along all but the first axis.

Returns
-------
stacked : ndarray
    The array formed by stacking the given arrays.

See Also
--------
hstack : Stack arrays in sequence horizontally (column wise).
dstack : Stack arrays in sequence depth wise (along third dimension).
concatenate : Join a sequence of arrays together.
vsplit : Split array into a list of multiple sub-arrays vertically.


Notes
-----
Equivalent to ``np.concatenate(tup, axis=0)``

Examples
--------
&gt;&gt;&gt; a = np.array([1, 2, 3])
&gt;&gt;&gt; b = np.array([2, 3, 4])
&gt;&gt;&gt; np.vstack((a,b))
array([[1, 2, 3],
       [2, 3, 4]])

&gt;&gt;&gt; a = np.array([[1], [2], [3]])
&gt;&gt;&gt; b = np.array([[2], [3], [4]])
&gt;&gt;&gt; np.vstack((a,b))
array([[1],
       [2],
       [3],
       [2],
       [3],
       [4]])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="where"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">where</span>(<span class="sig-arg">...</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">
where(condition, [x, y])

Return elements, either from `x` or `y`, depending on `condition`.

If only `condition` is given, return ``condition.nonzero()``.

Parameters
----------
condition : array_like, bool
    When True, yield `x`, otherwise yield `y`.
x, y : array_like, optional
    Values from which to choose.

Returns
-------
out : ndarray or tuple of ndarrays
    If both `x` and `y` are specified, the output array, shaped like
    `condition`, contains elements of `x` where `condition` is True,
    and elements from `y` elsewhere.

    If only `condition` is given, return the tuple
    ``condition.nonzero()``, the indices where `condition` is True.

See Also
--------
nonzero, choose

Notes
-----
If `x` and `y` are given and input arrays are 1-D, `where` is
equivalent to::

    [xv if c else yv for (c,xv,yv) in zip(condition,x,y)]

Examples
--------
&gt;&gt;&gt; x = np.arange(9.).reshape(3, 3)
&gt;&gt;&gt; np.where( x &gt; 5 )
(array([2, 2, 2]), array([0, 1, 2]))
&gt;&gt;&gt; x[np.where( x &gt; 3.0 )]               # Note: result is 1D.
array([ 4.,  5.,  6.,  7.,  8.])
&gt;&gt;&gt; np.where(x &lt; 5, x, -1)               # Note: broadcasting.
array([[ 0.,  1.,  2.],
       [ 3.,  4., -1.],
       [-1., -1., -1.]])

&gt;&gt;&gt; np.where([[True, False], [True, True]],
...          [[1, 2], [3, 4]],
...          [[9, 8], [7, 6]])
array([[1, 8],
       [3, 4]])

&gt;&gt;&gt; np.where([[0, 1], [1, 0]])
(array([0, 1]), array([1, 0]))

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="who"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">who</span>(<span class="sig-arg">vardict</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Print the Numpy arrays in the given dictionary.

If there is no dictionary passed in or `vardict` is None then returns
Numpy arrays in the globals() dictionary (all Numpy arrays in the
namespace).

Parameters
----------
vardict : dict, optional
    A dictionary possibly containing ndarrays.  Default is globals().

Returns
-------
out : None
    Returns 'None'.

Notes
-----
Prints out the name, shape, bytes and type of all of the ndarrays present
in `vardict`.

Examples
--------
&gt;&gt;&gt; d = {'x': arange(2.0), 'y': arange(3.0), 'txt': 'Some str', 'idx': 5}
&gt;&gt;&gt; np.whos(d)
Name            Shape            Bytes            Type
===========================================================
y               3                24               float64
x               2                16               float64
Upper bound on total bytes  =       40

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="zeros"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">zeros</span>(<span class="sig-arg">shape</span>,
        <span class="sig-arg">dtype</span>=<span class="sig-default">float</span>,
        <span class="sig-arg">order</span>=<span class="sig-default">'C'</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">
Return a new array of given shape and type, filled with zeros.

Parameters
----------
shape : {tuple of ints, int}
    Shape of the new array, e.g., ``(2, 3)`` or ``2``.
dtype : data-type, optional
    The desired data-type for the array, e.g., `numpy.int8`.  Default is
    `numpy.float64`.
order : {'C', 'F'}, optional
    Whether to store multidimensional data in C- or Fortran-contiguous
    (row- or column-wise) order in memory.

Returns
-------
out : ndarray
    Array of zeros with the given shape, dtype, and order.

See Also
--------
numpy.zeros_like : Return an array of zeros with shape and type of input.
numpy.ones_like : Return an array of ones with shape and type of input.
numpy.empty_like : Return an empty array with shape and type of input.
numpy.ones : Return a new array setting values to one.
numpy.empty : Return a new uninitialized array.

Examples
--------
&gt;&gt;&gt; np.zeros(5)
array([ 0.,  0.,  0.,  0.,  0.])

&gt;&gt;&gt; np.zeros((5,), dtype=numpy.int)
array([0, 0, 0, 0, 0])

&gt;&gt;&gt; np.zeros((2, 1))
array([[ 0.],
       [ 0.]])

&gt;&gt;&gt; s = (2,2)
&gt;&gt;&gt; np.zeros(s)
array([[ 0.,  0.],
       [ 0.,  0.]])

&gt;&gt;&gt; np.zeros((2,), dtype=[('x', 'i4'), ('y', 'i4')])
array([(0, 0), (0, 0)],
      dtype=[('x', '&lt;i4'), ('y', '&lt;i4')])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="zeros_like"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">zeros_like</span>(<span class="sig-arg">a</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <pre class="literalblock">

Returns an array of zeros with the same shape and type as a given array.

Equivalent to ``a.copy().fill(0)``.

Parameters
----------
a : array_like
    The shape and data-type of `a` defines the parameters of
    the returned array.

Returns
-------
out : ndarray
    Array of zeros with same shape and type as `a`.

See Also
--------
numpy.ones_like : Return an array of ones with shape and type of input.
numpy.empty_like : Return an empty array with shape and type of input.
numpy.zeros : Return a new array setting values to zero.
numpy.ones : Return a new array setting values to one.
numpy.empty : Return a new uninitialized array.

Examples
--------
&gt;&gt;&gt; x = np.arange(6)
&gt;&gt;&gt; x = x.reshape((2, 3))
&gt;&gt;&gt; x
array([[0, 1, 2],
       [3, 4, 5]])
&gt;&gt;&gt; np.zeros_like(x)
array([[0, 0, 0],
       [0, 0, 0]])

</pre>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<br />
<!-- ==================== VARIABLES DETAILS ==================== -->
<a name="section-VariablesDetails"></a>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td colspan="2" class="table-header">
    <table border="0" cellpadding="0" cellspacing="0" width="100%">
      <tr valign="top">
        <td align="left"><span class="table-header">Variables Details</span></td>
        <td align="right" valign="top"
         ><span class="options">[<a href="#section-VariablesDetails"
         class="privatelink" onclick="toggle_private();"
         >hide private</a>]</span></td>
      </tr>
    </table>
  </td>
</tr>
</table>
<a name="ScalarType"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <h3 class="epydoc">ScalarType</h3>
  
  <dl class="fields">
  </dl>
  <dl class="fields">
    <dt>Value:</dt>
      <dd><table><tr><td><pre class="variable">
<code class="variable-group">(</code>&lt;type 'int'&gt;<code class="variable-op">,</code>
 &lt;type 'float'&gt;<code class="variable-op">,</code>
 &lt;type 'complex'&gt;<code class="variable-op">,</code>
 &lt;type 'long'&gt;<code class="variable-op">,</code>
 &lt;type 'bool'&gt;<code class="variable-op">,</code>
 &lt;type 'str'&gt;<code class="variable-op">,</code>
 &lt;type 'unicode'&gt;<code class="variable-op">,</code>
 &lt;type 'buffer'&gt;<code class="variable-op">,</code>
<code class="variable-ellipsis">...</code>
</pre></td></tr></table>
</dd>
  </dl>
</td></tr></table>
</div>
<a name="cast"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <h3 class="epydoc">cast</h3>
  
  <dl class="fields">
  </dl>
  <dl class="fields">
    <dt>Value:</dt>
      <dd><table><tr><td><pre class="variable">
{&lt;type 'numpy.int64'&gt;: &lt;function &lt;lambda&gt; at 0x9e727d4&gt;, &lt;type 'numpy.<span class="variable-linewrap"><img src="crarr.png" alt="\" /></span>
int16'&gt;: &lt;function &lt;lambda&gt; at 0x9e7280c&gt;, &lt;type 'numpy.object_'&gt;: &lt;fu<span class="variable-linewrap"><img src="crarr.png" alt="\" /></span>
nction &lt;lambda&gt; at 0x9e72844&gt;, &lt;type 'numpy.uint32'&gt;: &lt;function &lt;lambd<span class="variable-linewrap"><img src="crarr.png" alt="\" /></span>
a&gt; at 0x9e7287c&gt;, &lt;type 'numpy.bool_'&gt;: &lt;function &lt;lambda&gt; at 0x9e728b<span class="variable-linewrap"><img src="crarr.png" alt="\" /></span>
4&gt;, &lt;type 'numpy.float96'&gt;: &lt;function &lt;lambda&gt; at 0x9e728ec&gt;, &lt;type 'n<span class="variable-linewrap"><img src="crarr.png" alt="\" /></span>
umpy.int32'&gt;: &lt;function &lt;lambda&gt; at 0x9e72924&gt;, &lt;type 'numpy.string_'&gt;<span class="variable-linewrap"><img src="crarr.png" alt="\" /></span>
: &lt;function &lt;lambda&gt; at 0x9e7295c&gt;, &lt;type 'numpy.uint32'&gt;: &lt;function &lt;<span class="variable-linewrap"><img src="crarr.png" alt="\" /></span>
lambda&gt; at 0x9e72994&gt;, &lt;type 'numpy.complex64'&gt;: &lt;function &lt;lambda&gt; at<span class="variable-linewrap"><img src="crarr.png" alt="\" /></span>
<code class="variable-ellipsis">...</code>
</pre></td></tr></table>
</dd>
  </dl>
</td></tr></table>
</div>
<a name="index_exp"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <h3 class="epydoc">index_exp</h3>
  
  <dl class="fields">
  </dl>
  <dl class="fields">
    <dt>Value:</dt>
      <dd><table><tr><td><pre class="variable">
&lt;numpy.lib.index_tricks.IndexExpression object at 0x9fa666c&gt;
</pre></td></tr></table>
</dd>
  </dl>
</td></tr></table>
</div>
<a name="nbytes"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <h3 class="epydoc">nbytes</h3>
  
  <dl class="fields">
  </dl>
  <dl class="fields">
    <dt>Value:</dt>
      <dd><table><tr><td><pre class="variable">
{&lt;type 'numpy.int64'&gt;: 8, &lt;type 'numpy.int16'&gt;: 2, &lt;type 'numpy.object<span class="variable-linewrap"><img src="crarr.png" alt="\" /></span>
_'&gt;: 4, &lt;type 'numpy.uint32'&gt;: 4, &lt;type 'numpy.bool_'&gt;: 1, &lt;type 'nump<span class="variable-linewrap"><img src="crarr.png" alt="\" /></span>
y.float96'&gt;: 12, &lt;type 'numpy.int32'&gt;: 4, &lt;type 'numpy.string_'&gt;: 0, &lt;<span class="variable-linewrap"><img src="crarr.png" alt="\" /></span>
type 'numpy.uint32'&gt;: 4, &lt;type 'numpy.complex64'&gt;: 8, &lt;type 'numpy.uni<span class="variable-linewrap"><img src="crarr.png" alt="\" /></span>
code_'&gt;: 0, &lt;type 'numpy.uint64'&gt;: 8, &lt;type 'numpy.int8'&gt;: 1, &lt;type 'n<span class="variable-linewrap"><img src="crarr.png" alt="\" /></span>
umpy.complex128'&gt;: 16, &lt;type 'numpy.uint8'&gt;: 1, &lt;type 'numpy.void'&gt;: 0<span class="variable-linewrap"><img src="crarr.png" alt="\" /></span>
, &lt;type 'numpy.float32'&gt;: 4, &lt;type 'numpy.int32'&gt;: 4, &lt;type 'numpy.com<span class="variable-linewrap"><img src="crarr.png" alt="\" /></span>
plex192'&gt;: 24, &lt;type 'numpy.uint16'&gt;: 2, &lt;type 'numpy.float64'&gt;: 8}
</pre></td></tr></table>
</dd>
  </dl>
</td></tr></table>
</div>
<a name="sctypeDict"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <h3 class="epydoc">sctypeDict</h3>
  
  <dl class="fields">
  </dl>
  <dl class="fields">
    <dt>Value:</dt>
      <dd><table><tr><td><pre class="variable">
<code class="variable-group">{</code>0<code class="variable-op">: </code>&lt;type 'numpy.bool_'&gt;<code class="variable-op">,</code>
 1<code class="variable-op">: </code>&lt;type 'numpy.int8'&gt;<code class="variable-op">,</code>
 2<code class="variable-op">: </code>&lt;type 'numpy.uint8'&gt;<code class="variable-op">,</code>
 3<code class="variable-op">: </code>&lt;type 'numpy.int16'&gt;<code class="variable-op">,</code>
 4<code class="variable-op">: </code>&lt;type 'numpy.uint16'&gt;<code class="variable-op">,</code>
 5<code class="variable-op">: </code>&lt;type 'numpy.int32'&gt;<code class="variable-op">,</code>
 6<code class="variable-op">: </code>&lt;type 'numpy.uint32'&gt;<code class="variable-op">,</code>
 7<code class="variable-op">: </code>&lt;type 'numpy.int32'&gt;<code class="variable-op">,</code>
<code class="variable-ellipsis">...</code>
</pre></td></tr></table>
</dd>
  </dl>
</td></tr></table>
</div>
<a name="sctypeNA"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <h3 class="epydoc">sctypeNA</h3>
  
  <dl class="fields">
  </dl>
  <dl class="fields">
    <dt>Value:</dt>
      <dd><table><tr><td><pre class="variable">
<code class="variable-group">{</code><code class="variable-quote">'</code><code class="variable-string">?</code><code class="variable-quote">'</code><code class="variable-op">: </code><code class="variable-quote">'</code><code class="variable-string">Bool</code><code class="variable-quote">'</code><code class="variable-op">,</code>
 <code class="variable-quote">'</code><code class="variable-string">B</code><code class="variable-quote">'</code><code class="variable-op">: </code><code class="variable-quote">'</code><code class="variable-string">UInt8</code><code class="variable-quote">'</code><code class="variable-op">,</code>
 <code class="variable-quote">'</code><code class="variable-string">Bool</code><code class="variable-quote">'</code><code class="variable-op">: </code>&lt;type 'numpy.bool_'&gt;<code class="variable-op">,</code>
 <code class="variable-quote">'</code><code class="variable-string">Complex32</code><code class="variable-quote">'</code><code class="variable-op">: </code>&lt;type 'numpy.complex64'&gt;<code class="variable-op">,</code>
 <code class="variable-quote">'</code><code class="variable-string">Complex64</code><code class="variable-quote">'</code><code class="variable-op">: </code>&lt;type 'numpy.complex128'&gt;<code class="variable-op">,</code>
 <code class="variable-quote">'</code><code class="variable-string">Complex96</code><code class="variable-quote">'</code><code class="variable-op">: </code>&lt;type 'numpy.complex192'&gt;<code class="variable-op">,</code>
 <code class="variable-quote">'</code><code class="variable-string">D</code><code class="variable-quote">'</code><code class="variable-op">: </code><code class="variable-quote">'</code><code class="variable-string">Complex64</code><code class="variable-quote">'</code><code class="variable-op">,</code>
 <code class="variable-quote">'</code><code class="variable-string">F</code><code class="variable-quote">'</code><code class="variable-op">: </code><code class="variable-quote">'</code><code class="variable-string">Complex32</code><code class="variable-quote">'</code><code class="variable-op">,</code>
<code class="variable-ellipsis">...</code>
</pre></td></tr></table>
</dd>
  </dl>
</td></tr></table>
</div>
<a name="sctypes"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <h3 class="epydoc">sctypes</h3>
  
  <dl class="fields">
  </dl>
  <dl class="fields">
    <dt>Value:</dt>
      <dd><table><tr><td><pre class="variable">
<code class="variable-group">{</code><code class="variable-quote">'</code><code class="variable-string">complex</code><code class="variable-quote">'</code><code class="variable-op">: </code><code class="variable-group">[</code>&lt;type 'numpy.complex64'&gt;<code class="variable-op">,</code>
             &lt;type 'numpy.complex128'&gt;<code class="variable-op">,</code>
             &lt;type 'numpy.complex192'&gt;<code class="variable-group">]</code><code class="variable-op">,</code>
 <code class="variable-quote">'</code><code class="variable-string">float</code><code class="variable-quote">'</code><code class="variable-op">: </code><code class="variable-group">[</code>&lt;type 'numpy.float32'&gt;<code class="variable-op">,</code>
           &lt;type 'numpy.float64'&gt;<code class="variable-op">,</code>
           &lt;type 'numpy.float96'&gt;<code class="variable-group">]</code><code class="variable-op">,</code>
 <code class="variable-quote">'</code><code class="variable-string">int</code><code class="variable-quote">'</code><code class="variable-op">: </code><code class="variable-group">[</code>&lt;type 'numpy.int8'&gt;<code class="variable-op">,</code>
         &lt;type 'numpy.int16'&gt;<code class="variable-op">,</code>
<code class="variable-ellipsis">...</code>
</pre></td></tr></table>
</dd>
  </dl>
</td></tr></table>
</div>
<a name="typeDict"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <h3 class="epydoc">typeDict</h3>
  
  <dl class="fields">
  </dl>
  <dl class="fields">
    <dt>Value:</dt>
      <dd><table><tr><td><pre class="variable">
<code class="variable-group">{</code>0<code class="variable-op">: </code>&lt;type 'numpy.bool_'&gt;<code class="variable-op">,</code>
 1<code class="variable-op">: </code>&lt;type 'numpy.int8'&gt;<code class="variable-op">,</code>
 2<code class="variable-op">: </code>&lt;type 'numpy.uint8'&gt;<code class="variable-op">,</code>
 3<code class="variable-op">: </code>&lt;type 'numpy.int16'&gt;<code class="variable-op">,</code>
 4<code class="variable-op">: </code>&lt;type 'numpy.uint16'&gt;<code class="variable-op">,</code>
 5<code class="variable-op">: </code>&lt;type 'numpy.int32'&gt;<code class="variable-op">,</code>
 6<code class="variable-op">: </code>&lt;type 'numpy.uint32'&gt;<code class="variable-op">,</code>
 7<code class="variable-op">: </code>&lt;type 'numpy.int32'&gt;<code class="variable-op">,</code>
<code class="variable-ellipsis">...</code>
</pre></td></tr></table>
</dd>
  </dl>
</td></tr></table>
</div>
<a name="typeNA"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <h3 class="epydoc">typeNA</h3>
  
  <dl class="fields">
  </dl>
  <dl class="fields">
    <dt>Value:</dt>
      <dd><table><tr><td><pre class="variable">
<code class="variable-group">{</code><code class="variable-quote">'</code><code class="variable-string">?</code><code class="variable-quote">'</code><code class="variable-op">: </code><code class="variable-quote">'</code><code class="variable-string">Bool</code><code class="variable-quote">'</code><code class="variable-op">,</code>
 <code class="variable-quote">'</code><code class="variable-string">B</code><code class="variable-quote">'</code><code class="variable-op">: </code><code class="variable-quote">'</code><code class="variable-string">UInt8</code><code class="variable-quote">'</code><code class="variable-op">,</code>
 <code class="variable-quote">'</code><code class="variable-string">Bool</code><code class="variable-quote">'</code><code class="variable-op">: </code>&lt;type 'numpy.bool_'&gt;<code class="variable-op">,</code>
 <code class="variable-quote">'</code><code class="variable-string">Complex32</code><code class="variable-quote">'</code><code class="variable-op">: </code>&lt;type 'numpy.complex64'&gt;<code class="variable-op">,</code>
 <code class="variable-quote">'</code><code class="variable-string">Complex64</code><code class="variable-quote">'</code><code class="variable-op">: </code>&lt;type 'numpy.complex128'&gt;<code class="variable-op">,</code>
 <code class="variable-quote">'</code><code class="variable-string">Complex96</code><code class="variable-quote">'</code><code class="variable-op">: </code>&lt;type 'numpy.complex192'&gt;<code class="variable-op">,</code>
 <code class="variable-quote">'</code><code class="variable-string">D</code><code class="variable-quote">'</code><code class="variable-op">: </code><code class="variable-quote">'</code><code class="variable-string">Complex64</code><code class="variable-quote">'</code><code class="variable-op">,</code>
 <code class="variable-quote">'</code><code class="variable-string">F</code><code class="variable-quote">'</code><code class="variable-op">: </code><code class="variable-quote">'</code><code class="variable-string">Complex32</code><code class="variable-quote">'</code><code class="variable-op">,</code>
<code class="variable-ellipsis">...</code>
</pre></td></tr></table>
</dd>
  </dl>
</td></tr></table>
</div>
<a name="typecodes"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <h3 class="epydoc">typecodes</h3>
  
  <dl class="fields">
  </dl>
  <dl class="fields">
    <dt>Value:</dt>
      <dd><table><tr><td><pre class="variable">
<code class="variable-group">{</code><code class="variable-quote">'</code><code class="variable-string">All</code><code class="variable-quote">'</code><code class="variable-op">: </code><code class="variable-quote">'</code><code class="variable-string">?bhilqpBHILQPfdgFDGSUVO</code><code class="variable-quote">'</code><code class="variable-op">,</code>
 <code class="variable-quote">'</code><code class="variable-string">AllFloat</code><code class="variable-quote">'</code><code class="variable-op">: </code><code class="variable-quote">'</code><code class="variable-string">fdgFDG</code><code class="variable-quote">'</code><code class="variable-op">,</code>
 <code class="variable-quote">'</code><code class="variable-string">AllInteger</code><code class="variable-quote">'</code><code class="variable-op">: </code><code class="variable-quote">'</code><code class="variable-string">bBhHiIlLqQpP</code><code class="variable-quote">'</code><code class="variable-op">,</code>
 <code class="variable-quote">'</code><code class="variable-string">Character</code><code class="variable-quote">'</code><code class="variable-op">: </code><code class="variable-quote">'</code><code class="variable-string">c</code><code class="variable-quote">'</code><code class="variable-op">,</code>
 <code class="variable-quote">'</code><code class="variable-string">Complex</code><code class="variable-quote">'</code><code class="variable-op">: </code><code class="variable-quote">'</code><code class="variable-string">FDG</code><code class="variable-quote">'</code><code class="variable-op">,</code>
 <code class="variable-quote">'</code><code class="variable-string">Float</code><code class="variable-quote">'</code><code class="variable-op">: </code><code class="variable-quote">'</code><code class="variable-string">fdg</code><code class="variable-quote">'</code><code class="variable-op">,</code>
 <code class="variable-quote">'</code><code class="variable-string">Integer</code><code class="variable-quote">'</code><code class="variable-op">: </code><code class="variable-quote">'</code><code class="variable-string">bhilqp</code><code class="variable-quote">'</code><code class="variable-op">,</code>
 <code class="variable-quote">'</code><code class="variable-string">UnsignedInteger</code><code class="variable-quote">'</code><code class="variable-op">: </code><code class="variable-quote">'</code><code class="variable-string">BHILQP</code><code class="variable-quote">'</code><code class="variable-group">}</code>
</pre></td></tr></table>
</dd>
  </dl>
</td></tr></table>
</div>
<br />
<!-- ==================== NAVIGATION BAR ==================== -->
<table class="navbar" border="0" width="100%" cellpadding="0"
       bgcolor="#a0c0ff" cellspacing="0">
  <tr valign="middle">
  <!-- Home link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="B1python-module.html">Home</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Tree link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="module-tree.html">Trees</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Index link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="identifier-index.html">Indices</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Help link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="help.html">Help</a>&nbsp;&nbsp;&nbsp;</th>

      <th class="navbar" width="100%"></th>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0" width="100%%">
  <tr>
    <td align="left" class="footer">
    Generated by Epydoc 3.0.1 on Tue Apr 27 11:02:17 2010
    </td>
    <td align="right" class="footer">
      <a target="mainFrame" href="http://epydoc.sourceforge.net"
        >http://epydoc.sourceforge.net</a>
    </td>
  </tr>
</table>

<script type="text/javascript">
  <!--
  // Private objects are initially displayed (because if
  // javascript is turned off then we want them to be
  // visible); but by default, we want to hide them.  So hide
  // them unless we have a cookie that says to show them.
  checkCookie();
  // -->
</script>
</body>
</html>
